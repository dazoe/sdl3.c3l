<*
 SDL's video subsystem is largely interested in abstracting window
 management from the underlying operating system. You can create windows,
 manage them in various ways, set them fullscreen, and get events when
 interesting things happen with them, such as the mouse or keyboard
 interacting with a window.

 The video subsystem is also interested in abstracting away some
 platform-specific differences in OpenGL: context creation, swapping
 buffers, etc. This may be crucial to your app, but also you are not
 required to use OpenGL at all. In fact, SDL can provide rendering to those
 windows as well, either with an easy-to-use
 [2D API](https://wiki.libsdl.org/SDL3/CategoryRender)
 or with a more-powerful
 [GPU API](https://wiki.libsdl.org/SDL3/CategoryGPU)
 . Of course, it can simply get out of your way and give you the window
 handles you need to use Vulkan, Direct3D, Metal, or whatever else you like
 directly, too.

 The video subsystem covers a lot of functionality, out of necessity, so it
 is worth perusing the list of functions just to see what's available, but
 most apps can get by with simply creating a window and listening for
 events, so start with SDL_CreateWindow() and SDL_PollEvent().

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryVideo
*>
module sdl;

<*
 This is a unique ID for a display for the time it is connected to the
 system, and is never reused for the lifetime of the application.
 This datatype is available since SDL 3.2.0.

 If the display is disconnected and reconnected, it will get a new ID.

 The value 0 is an invalid ID.
*>
typedef SDLDisplayID = uint;

<*
 This is a unique ID for a window.
 This datatype is available since SDL 3.2.0.

 The value 0 is an invalid ID.
*>
typedef SDLWindowID = uint;

<*
 The pointer to the global `wl_display` object used by the Wayland video
 backend.

 Can be set before the video subsystem is initialized to import an external
 `wl_display` object from an application or toolkit for use in SDL, or read
 after initialization to export the `wl_display` used by the Wayland video
 backend. Setting this property after the video subsystem has been
 initialized has no effect, and reading it when the video subsystem is
 uninitialized will either return the user provided value, if one was set
 prior to initialization, or NULL. See docs/README-wayland.md for more
 information.
*>
const SDL_PROP_GLOBAL_VIDEO_WAYLAND_WL_DISPLAY_POINTER = "SDL.video.wayland.wl_display";

<*
 System theme.
 This enum is available since SDL 3.2.0.
*>
enum SDLSystemTheme : const CInt
{
    UNKNOWN,   // Unknown system theme
    LIGHT,     // Light colored system theme
    DARK,      // Dark colored system theme
}

<*
 Internal display mode data.
 This struct is available since SDL 3.2.0.

 This lives as a field in SDL_DisplayMode, as opaque data.
*>
typedef SDLDisplayModeData = void;

<*
 The structure that defines a display mode.
 This struct is available since SDL 3.2.0.
*>
struct SDLDisplayMode
{
    SDLDisplayID display_id;        // the display this mode is associated with
    SDLPixelFormat format;         // pixel format
    int w;                         // width
    int h;                         // height
    float pixel_density;           // scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)
    float refresh_rate;            // refresh rate (or 0.0f for unspecified)
    int refresh_rate_numerator;    // precise refresh rate numerator (or 0 for unspecified)
    int refresh_rate_denominator;  // precise refresh rate denominator

    SDLDisplayModeData* internal;  // Private
}

<*
 Display orientation values; the way a display is rotated.
 This enum is available since SDL 3.2.0.
*>
enum SDLDisplayOrientation : const CInt
{
    UNKNOWN,            // The display orientation can't be determined
    LANDSCAPE,          // The display is in landscape mode, with the right side up, relative to portrait mode
    LANDSCAPE_FLIPPED,  // The display is in landscape mode, with the left side up, relative to portrait mode
    PORTRAIT,           // The display is in portrait mode
    PORTRAIT_FLIPPED,   // The display is in portrait mode, upside down
}

<*
 The struct used as an opaque handle to a window.
 This struct is available since SDL 3.2.0.
*>
typedef SDLWindow = void;

<*
 The flags on a window.
 This datatype is available since SDL 3.2.0.

 These cover a lot of true/false, or on/off, window state. Some of it is
 immutable after being set through SDL_CreateWindow(), some of it can be
 changed on existing windows by the app, and some of it might be altered by
 the user or system outside of the app's control.
*>
bitstruct SDLWindowFlags : ulong
{
	bool fullscreen           : 0; // 0x0000000000000001u,    // window is in fullscreen mode
	bool opengl               : 1; // 0x0000000000000002u,    // window usable with OpenGL context
	bool occluded             : 2; // 0x0000000000000004u,    // window is occluded
	bool hidden               : 3; // 0x0000000000000008u,    // window is neither mapped onto the desktop nor shown in the taskbar/dock/window list; SDL_ShowWindow() is required for it to become visible
	bool borderless           : 4; // 0x0000000000000010u,    // no window decoration
	bool resizable            : 5; // 0x0000000000000020u,    // window can be resized
	bool minimized            : 6; // 0x0000000000000040u,    // window is minimized
	bool maximized            : 7; // 0x0000000000000080u,    // window is maximized
	bool mouse_grabbed        : 8; // 0x0000000000000100u,    // window has grabbed mouse input
	bool input_focus          : 9; // 0x0000000000000200u,    // window has input focus
	bool mouse_focus          : 10; // 0x0000000000000400u,    // window has mouse focus
	bool external             : 11; // 0x0000000000000800u,    // window not created by SDL
	bool modal                : 12; // 0x0000000000001000u,    // window is modal
	bool high_pixel_density   : 13; // 0x0000000000002000u,    // window uses high pixel density back buffer if possible
	bool mouse_capture        : 14; // 0x0000000000004000u,    // window has mouse captured (unrelated to MOUSE_GRABBED)
	bool mouse_relative_mode  : 15; // 0x0000000000008000u,    // window has relative mode enabled
	bool always_on_top        : 16; // 0x0000000000010000u,    // window should always be above others
	bool utility              : 17; // 0x0000000000020000u,    // window should be treated as a utility window, not showing in the task bar and window list
	bool tooltip              : 18; // 0x0000000000040000u,    // window should be treated as a tooltip and does not get mouse or keyboard focus, requires a parent window
	bool popup_menu           : 19; // 0x0000000000080000u,    // window should be treated as a popup menu, requires a parent window
	bool keyboard_grabbed     : 20; // 0x0000000000100000u,    // window has grabbed keyboard input
	bool vulkan               : 28; // 0x0000000010000000u,    // window usable for Vulkan surface
	bool metal                : 29; // 0x0000000020000000u,    // window usable for Metal view
	bool transparent          : 30; // 0x0000000040000000u,    // window with transparent buffer
	bool not_focusable        : 31; // 0x0000000080000000u,    // window should not be focusable
}

<*
 A magic value used with SDL_WINDOWPOS_UNDEFINED.
 This macro is available since SDL 3.2.0.

 Generally this macro isn't used directly, but rather through
 SDL_WINDOWPOS_UNDEFINED or SDL_WINDOWPOS_UNDEFINED_DISPLAY.
*>
const WINDOW_POS_UNDEFINED_MASK = 0x1FFF0000u;

<*
 Used to indicate that you don't care what the window position is.
 This macro is available since SDL 3.2.0.

 If you _really_ don't care, SDL_WINDOWPOS_UNDEFINED is the same, but always
 uses the primary display instead of specifying one.

 @param $x : `the SDL_DisplayID of the display to use.`
*>
macro @window_pos_undefined_display($x) => WINDOW_POS_UNDEFINED_MASK | $x;

<*
 Used to indicate that you don't care what the window position/display is.
 This macro is available since SDL 3.2.0.

 This always uses the primary display.
*>
const WINDOW_POS_UNDEFINED = @window_pos_undefined_display(0);

<*
 A macro to test if the window position is marked as "undefined."
 This macro is available since SDL 3.2.0.

 @param x : `the window position value.`
*>
macro bool window_pos_is_undefined(x) => x & 0xFFFF0000 == WINDOW_POS_UNDEFINED_MASK;

<*
 A magic value used with SDL_WINDOWPOS_CENTERED.
 This macro is available since SDL 3.2.0.

 Generally this macro isn't used directly, but rather through
 SDL_WINDOWPOS_CENTERED or SDL_WINDOWPOS_CENTERED_DISPLAY.
*>
const WINDOW_POS_CENTERED_MASK = 0x2FFF0000u;

<*
 Used to indicate that the window position should be centered.
 This macro is available since SDL 3.2.0.

 SDL_WINDOWPOS_CENTERED is the same, but always uses the primary display
 instead of specifying one.

 @param $x : `the SDL_DisplayID of the display to use.`
*>
macro @window_pos_centered_display($x) => WINDOW_POS_CENTERED_MASK | $x;

<*
 Used to indicate that the window position should be centered.
 This macro is available since SDL 3.2.0.

 This always uses the primary display.
*>
const WINDOW_POS_CENTERED = @window_pos_centered_display(0);

<*
 A macro to test if the window position is marked as "centered."
 This macro is available since SDL 3.2.0.

 @param x : `the window position value.`
*>
macro bool window_pos_is_centered(x) => x & 0xFFFF0000 == WINDOW_POS_CENTERED_MASK;

<*
 Window flash operation.
 This enum is available since SDL 3.2.0.
*>
enum SDLFlashOperation : const CInt
{
   CANCEL,                   // Cancel any window flash state
   BRIEFLY,                  // Flash the window briefly to get attention
   UNTIL_FOCUSED,            // Flash the window until it gets focus
}

<*
 An opaque handle to an OpenGL context.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLGLContextState = void;
alias SDLGLContext = SDLGLContextState*;

<*
 Opaque type for an EGL display.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLEGLDisplay = void*;

<*
 Opaque type for an EGL config.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLEGLConfig = void*;

<*
 Opaque type for an EGL surface.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLEGLSurface = void*;

<*
 An EGL attribute, used when creating an EGL context.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLEGLAttrib = iptr;

<*
 An EGL integer attribute, used when creating an EGL surface.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLEGLint = CInt;

<*
 EGL platform attribute initialization callback.
 This datatype is available since SDL 3.2.0.

 This is called when SDL is attempting to create an EGL context, to let the
 app add extra attributes to its eglGetPlatformDisplay() call.

 The callback should return a pointer to an EGL attribute array terminated
 with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow
 process will fail gracefully.

 The returned pointer should be allocated with SDL_malloc() and will be
 passed to SDL_free().

 The arrays returned by each callback will be appended to the existing
 attribute arrays defined by SDL.

 @param userdata : `an app-controlled pointer that is passed to the callback.`
 @return `a newly-allocated array of attributes, terminated with 'EGL_NONE'.`
*>
alias SDLEGLAttribArrayCallback = fn SDLEGLAttrib*(void* userdata);

<*
 EGL surface/context attribute initialization callback types.
 This datatype is available since SDL 3.2.0.

 This is called when SDL is attempting to create an EGL surface, to let the
 app add extra attributes to its eglCreateWindowSurface() or
 eglCreateContext calls.

 For convenience, the EGLDisplay and EGLConfig to use are provided to the
 callback.

 The callback should return a pointer to an EGL attribute array terminated
 with `EGL_NONE`. If this function returns NULL, the SDL_CreateWindow
 process will fail gracefully.

 The returned pointer should be allocated with SDL_malloc() and will be
 passed to SDL_free().

 The arrays returned by each callback will be appended to the existing
 attribute arrays defined by SDL.

 @param userdata : `an app-controlled pointer that is passed to the callback.`
 @param display : `the EGL display to be used.`
 @param config : `the EGL config to be used.`
 @return `a newly-allocated array of attributes, terminated with 'EGL_NONE'.`
*>
alias SDLEGLIntArrayCallback = fn SDLEGLint*(void *userdata, SDLEGLDisplay display, SDLEGLConfig config);

<*
 An enumeration of OpenGL configuration attributes.
 This enum is available since SDL 3.2.0.

 While you can set most OpenGL attributes normally, the attributes listed
 above must be known before SDL creates the window that will be used with
 the OpenGL context. These attributes are set and read with
 SDL_GL_SetAttribute() and SDL_GL_GetAttribute().

 In some cases, these attributes are minimum requests; the GL does not
 promise to give you exactly what you asked for. It's possible to ask for a
 16-bit depth buffer and get a 24-bit one instead, for example, or to ask
 for no stencil buffer and still have one available. Context creation should
 fail if the GL can't provide your requested attributes at a minimum, but
 you should check to see exactly what you got.
*>
enum SDLGLAttr : const CInt
{
    RED_SIZE,                    // the minimum number of bits for the red channel of the color buffer; defaults to 8.
    GREEN_SIZE,                  // the minimum number of bits for the green channel of the color buffer; defaults to 8.
    BLUE_SIZE,                   // the minimum number of bits for the blue channel of the color buffer; defaults to 8.
    ALPHA_SIZE,                  // the minimum number of bits for the alpha channel of the color buffer; defaults to 8.
    BUFFER_SIZE,                 // the minimum number of bits for frame buffer size; defaults to 0.
    DOUBLEBUFFER,                // whether the output is single or double buffered; defaults to double buffering on.
    DEPTH_SIZE,                  // the minimum number of bits in the depth buffer; defaults to 16.
    STENCIL_SIZE,                // the minimum number of bits in the stencil buffer; defaults to 0.
    ACCUM_RED_SIZE,              // the minimum number of bits for the red channel of the accumulation buffer; defaults to 0.
    ACCUM_GREEN_SIZE,            // the minimum number of bits for the green channel of the accumulation buffer; defaults to 0.
    ACCUM_BLUE_SIZE,             // the minimum number of bits for the blue channel of the accumulation buffer; defaults to 0.
    ACCUM_ALPHA_SIZE,            // the minimum number of bits for the alpha channel of the accumulation buffer; defaults to 0.
    STEREO,                      // whether the output is stereo 3D; defaults to off.
    MULTISAMPLEBUFFERS,          // the number of buffers used for multisample anti-aliasing; defaults to 0.
    MULTISAMPLESAMPLES,          // the number of samples used around the current pixel used for multisample anti-aliasing.
    ACCELERATED_VISUAL,          // set to 1 to require hardware acceleration, set to 0 to force software rendering; defaults to allow either.
    RETAINED_BACKING,            // not used (deprecated).
    CONTEXT_MAJOR_VERSION,       // OpenGL context major version.
    CONTEXT_MINOR_VERSION,       // OpenGL context minor version.
    CONTEXT_FLAGS,               // some combination of 0 or more of elements of the SDLGLContextFlag enumeration; defaults to 0.
    CONTEXT_PROFILE_MASK,        // type of GL context (Core, Compatibility, ES). See SDLGLProfile; default value depends on platform.
    SHARE_WITH_CURRENT_CONTEXT,  // OpenGL context sharing; defaults to 0.
    FRAMEBUFFER_SRGB_CAPABLE,    // requests sRGB capable visual; defaults to 0.
    CONTEXT_RELEASE_BEHAVIOR,    // sets context the release behavior. See SDLGLContextReleaseFlag; defaults to FLUSH.
    CONTEXT_RESET_NOTIFICATION,  // set context reset notification. See SDLGLContextResetNotification; defaults to NO_NOTIFICATION.
    CONTEXT_NO_ERROR,
    FLOATBUFFERS,
    EGL_PLATFORM,
}

<*
 Possible values to be set for the SDL_GL_CONTEXT_PROFILE_MASK attribute.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLGLProfile = uint;

const SDLGLProfile GL_CONTEXT_PROFILE_CORE          = 0x0001;  // OpenGL Core Profile context
const SDLGLProfile GL_CONTEXT_PROFILE_COMPATIBILITY = 0x0002;  // OpenGL Compatibility Profile context
const SDLGLProfile GL_CONTEXT_PROFILE_ES            = 0x0004;  // GLX_CONTEXT_ES2_PROFILE_BIT_EXT

<*
 Possible flags to be set for the SDL_GL_CONTEXT_FLAGS attribute.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLGLContextFlag = uint;

const SDLGLContextFlag GL_CONTEXT_DEBUG_FLAG              = 0x0001;
const SDLGLContextFlag GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 0x0002;
const SDLGLContextFlag GL_CONTEXT_ROBUST_ACCESS_FLAG      = 0x0004;
const SDLGLContextFlag GL_CONTEXT_RESET_ISOLATION_FLAG    = 0x0008;

<*
 Possible values to be set for the SDL_GL_CONTEXT_RELEASE_BEHAVIOR
 attribute.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLGLContextReleaseFlag = uint;

const SDLGLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_NONE  = 0x0000;
const SDLGLContextReleaseFlag GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x0001;

<*
 Possible values to be set SDL_GL_CONTEXT_RESET_NOTIFICATION attribute.
 This datatype is available since SDL 3.2.0.
*>
typedef SDLGLContextResetNotification = uint;

const SDLGLContextResetNotification GL_CONTEXT_RESET_NO_NOTIFICATION = 0x0000;
const SDLGLContextResetNotification GL_CONTEXT_RESET_LOSE_CONTEXT    = 0x0001;


/* Function prototypes */

<*
 Get the number of video drivers compiled into SDL.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the number of built in video drivers.`
*>
extern fn CInt get_num_video_drivers() @extern("SDL_GetNumVideoDrivers");

<*
 Get the name of a built in video driver.
 This function is available since SDL 3.2.0.

 The video drivers are presented in the order in which they are normally
 checked during initialization.

 The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 "x11" or "windows". These never have Unicode characters, and are not meant
 to be proper names.

 threadsafety: This function should only be called on the main thread.

 @param index : `the index of a video driver.`
 @return `the name of the video driver with the given **index**.`
*>
extern fn ZString get_video_driver(CInt index) @extern("SDL_GetVideoDriver");

<*
 Get the name of the currently initialized video driver.
 This function is available since SDL 3.2.0.

 The names of drivers are all simple, low-ASCII identifiers, like "cocoa",
 "x11" or "windows". These never have Unicode characters, and are not meant
 to be proper names.

 threadsafety: This function should only be called on the main thread.

 @return `the name of the current video driver or NULL if no driver has been
          initialized.`
*>
extern fn ZString get_current_video_driver() @extern("SDL_GetCurrentVideoDriver");

<*
 Get the current system theme.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the current system theme, light, dark, or unknown.`
*>
extern fn SDLSystemTheme get_system_theme() @extern("SDL_GetSystemTheme");

<*
 Get a list of currently connected displays.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param count : `a pointer filled in with the number of displays returned, may
              be NULL.`
 @return `a 0 terminated array of display instance IDs or NULL on failure;
          call SDL_GetError() for more information. This should be freed
          with SDL_free() when it is no longer needed.`
*>
extern fn SDLDisplayID* get_displays(CInt* count) @extern("SDL_GetDisplays");

<*
 Return the primary display.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the instance ID of the primary display on success or 0 on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLDisplayID get_primary_display() @extern("SDL_GetPrimaryDisplay");

<*
 Get the properties associated with a display.
 This function is available since SDL 3.2.0.

 The following read-only properties are provided by SDL:

 - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR
   headroom above the SDR white point. This is for informational and
   diagnostic purposes only, as not all platforms provide this information
   at the display level.

 On KMS/DRM:

 - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel
   orientation" property for the display in degrees of clockwise rotation.
   Note that this is provided only as a hint, and the application is
   responsible for any coordinate transformations needed to conform to the
   requested display orientation.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLDisplayID.get_properties(display_id) @extern("SDL_GetDisplayProperties");

enum SDLPropDisplay : const inline ZString
{
	HDR_ENABLED_BOOLEAN             = "SDL.display.HDR_enabled",
	KMSDRM_PANEL_ORIENTATION_NUMBER = "SDL.display.KMSDRM.panel_orientation",
}

<*
 Get the name of a display in UTF-8 encoding.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `the name of a display or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn ZString SDLDisplayID.get_name(display_id) @extern("SDL_GetDisplayName");

<*
 Get the desktop area represented by a display.
 This function is available since SDL 3.2.0.

 The primary display is often located at (0,0), but may be placed at a
 different location depending on monitor layout.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @param rect : `the SDL_Rect structure filled in with the display bounds.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLDisplayID.get_bounds(display_id, SDLRect* rect) @extern("SDL_GetDisplayBounds");

<*
 Get the usable desktop area represented by a display, in screen
 coordinates.
 This function is available since SDL 3.2.0.

 This is the same area as SDL_GetDisplayBounds() reports, but with portions
 reserved by the system removed. For example, on Apple's macOS, this
 subtracts the area occupied by the menu bar and dock.

 Setting a window to be fullscreen generally bypasses these unusable areas,
 so these are good guidelines for the maximum space available to a
 non-fullscreen window.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @param rect : `the SDL_Rect structure filled in with the display bounds.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLDisplayID.get_usable_bounds(display_id, SDLRect* rect) @extern("SDL_GetDisplayUsableBounds");

<*
 Get the orientation of a display when it is unrotated.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `the SDL_DisplayOrientation enum value of the display, or
          'SDL_ORIENTATION_UNKNOWN' if it isn't available.`
*>
extern fn SDLDisplayOrientation SDLDisplayID.get_natural_orientation(display_id) @extern("SDL_GetNaturalDisplayOrientation");

<*
 Get the orientation of a display.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `the SDL_DisplayOrientation enum value of the display, or
          'SDL_ORIENTATION_UNKNOWN' if it isn't available.`
*>
extern fn SDLDisplayOrientation SDLDisplayID.get_current_orientation(display_id) @extern("SDL_GetCurrentDisplayOrientation");

<*
 Get the content scale of a display.
 This function is available since SDL 3.2.0.

 The content scale is the expected scale for content based on the DPI
 settings of the display. For example, a 4K display might have a 2.0 (200%)
 display scale, which means that the user expects UI elements to be twice as
 big on this display, to aid in readability.

 After window creation, SDL_GetWindowDisplayScale() should be used to query
 the content scale factor for individual windows instead of querying the
 display for a window and calling this function, as the per-window content
 scale factor may differ from the base value of the display it is on,
 particularly on high-DPI and/or multi-monitor desktop configurations.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `the content scale of the display, or 0.0f on failure; call
          SDL_GetError() for more information.`
*>
extern fn float SDLDisplayID.get_content_scale(display_id) @extern("SDL_GetDisplayContentScale");

<*
 Get a list of fullscreen display modes available on a display.
 This function is available since SDL 3.2.0.

 The display modes are sorted in this priority:

 - w -> largest to smallest
 - h -> largest to smallest
 - bits per pixel -> more colors to fewer colors
 - packed pixel layout -> largest to smallest
 - refresh rate -> highest to lowest
 - pixel density -> lowest to highest

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @param count : `a pointer filled in with the number of display modes returned,
              may be NULL.`
 @return `a NULL terminated array of display mode pointers or NULL on
          failure; call SDL_GetError() for more information. This is a
          single allocation that should be freed with SDL_free() when it is
          no longer needed.`
*>
extern fn SDLDisplayMode** SDLDisplayID.get_fullscreen_modes(display_id, CInt* count) @extern("SDL_GetFullscreenDisplayModes");

<*
 Get the closest match to the requested display mode.
 This function is available since SDL 3.2.0.

 The available display modes are scanned and `closest` is filled in with the
 closest mode matching the requested mode and returned. The mode format and
 refresh rate default to the desktop mode if they are set to 0. The modes
 are scanned with size being first priority, format being second priority,
 and finally checking the refresh rate. If all the available modes are too
 small, then false is returned.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @param w : `the width in pixels of the desired display mode.`
 @param h : `the height in pixels of the desired display mode.`
 @param refresh_rate : `the refresh rate of the desired display mode, or 0.0f
                     for the desktop refresh rate.`
 @param include_high_density_modes : `boolean to include high density modes in
                                   the search.`
 @param closest : `a pointer filled in with the closest display mode equal to
                or larger than the desired mode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLDisplayID.get_closest_fullscreen_mode(display_id, CInt w, CInt h, float refresh_rate, bool include_high_density_modes, SDLDisplayMode* closest) @extern("SDL_GetClosestFullscreenDisplayMode");

<*
 Get information about the desktop's display mode.
 This function is available since SDL 3.2.0.

 There's a difference between this function and SDL_GetCurrentDisplayMode()
 when SDL runs fullscreen and has changed the resolution. In that case this
 function will return the previous native display mode, and not the current
 display mode.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `a pointer to the desktop display mode or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLDisplayMode* SDLDisplayID.get_desktop_mode(display_id) @extern("SDL_GetDesktopDisplayMode");

<*
 Get information about the current display mode.
 This function is available since SDL 3.2.0.

 There's a difference between this function and SDL_GetDesktopDisplayMode()
 when SDL runs fullscreen and has changed the resolution. In that case this
 function will return the current display mode, and not the previous native
 display mode.

 threadsafety: This function should only be called on the main thread.

 @param display_id : `the instance ID of the display to query.`
 @return `a pointer to the desktop display mode or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLDisplayMode* SDLDisplayID.get_current_mode(display_id) @extern("SDL_GetCurrentDisplayMode");

<*
 Get the display containing a point.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param point : `the point to query.`
 @return `the instance ID of the display containing the point or 0 on
          failure; call SDL_GetError() for more information.`
*>
extern fn SDLDisplayID get_display_for_point(SDLPoint* point) @extern("SDL_GetDisplayForPoint");

<*
 Get the display primarily containing a rect.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param rect : `the rect to query.`
 @return `the instance ID of the display entirely containing the rect or
          closest to the center of the rect on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLDisplayID get_display_for_rect(SDLRect* rect) @extern("SDL_GetDisplayForRect");

<*
 Get the display associated with a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the instance ID of the display containing the center of the window
          on success or 0 on failure; call SDL_GetError() for more
          information.`
*>
extern fn SDLDisplayID SDLWindow.get_display(&window) @extern("SDL_GetDisplayForWindow");

<*
 Get the pixel density of a window.
 This function is available since SDL 3.2.0.

 This is a ratio of pixel size to window size. For example, if the window is
 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it
 would have a pixel density of 2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the pixel density or 0.0f on failure; call SDL_GetError() for more
          information.`
*>
extern fn float SDLWindow.get_pixel_density(&window) @extern("SDL_GetWindowPixelDensity");

<*
 Get the content display scale relative to a window's pixel size.
 This function is available since SDL 3.2.0.

 This is a combination of the window pixel density and the display content
 scale, and is the expected scale for displaying content in this window. For
 example, if a 3840x2160 window had a display scale of 2.0, the user expects
 the content to take twice as many pixels and be the same physical size as
 if it were being displayed in a 1920x1080 window with a display scale of
 1.0.

 Conceptually this value corresponds to the scale display setting, and is
 updated when that setting is changed, or the window moves to a display with
 a different scale setting.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the display scale, or 0.0f on failure; call SDL_GetError() for
          more information.`
*>
extern fn float SDLWindow.get_display_scale(&window) @extern("SDL_GetWindowDisplayScale");

<*
 Set the display mode to use when a window is visible and fullscreen.
 This function is available since SDL 3.2.0.

 This only affects the display mode used when the window is fullscreen. To
 change the window size when the window is not fullscreen, use
 SDL_SetWindowSize().

 If the window is currently in the fullscreen state, this request is
 asynchronous on some windowing systems and the new mode dimensions may not
 be applied immediately upon the return of this function. If an immediate
 change is required, call SDL_SyncWindow() to block until the changes have
 taken effect.

 When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an
 SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode
 dimensions.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to affect.`
 @param mode : `a pointer to the display mode to use, which can be NULL for
             borderless fullscreen desktop mode, or one of the fullscreen
             modes returned by SDL_GetFullscreenDisplayModes() to set an
             exclusive fullscreen mode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_fullscreen_mode(&window, SDLDisplayMode* mode) @extern("SDL_SetWindowFullscreenMode");

<*
 Query the display mode to use when a window is visible at fullscreen.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `a pointer to the exclusive fullscreen mode to use or NULL for
          borderless fullscreen desktop mode.`
*>
extern fn SDLDisplayMode* SDLWindow.get_fullscreen_mode(&window) @extern("SDL_GetWindowFullscreenMode");

<*
 Get the raw ICC profile data for the screen the window is currently on.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param size : `the size of the ICC profile.`
 @return `the raw ICC profile data on success or NULL on failure; call
          SDL_GetError() for more information. This should be freed with
          SDL_free() when it is no longer needed.`
*>
extern fn void* SDLWindow.get_icc_profile(&window, usz* size) @extern("SDL_GetWindowICCProfile");

<*
 Get the pixel format associated with the window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the pixel format of the window on success or
          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more
          information.`
*>
extern fn SDLPixelFormat SDLWindow.get_pixel_format(&window) @extern("SDL_GetWindowPixelFormat");

<*
 Get a list of valid windows.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param count : `a pointer filled in with the number of windows returned, may
              be NULL.`
 @return `a NULL terminated array of SDL_Window pointers or NULL on failure;
          call SDL_GetError() for more information. This is a single
          allocation that should be freed with SDL_free() when it is no
          longer needed.`
*>
extern fn SDLWindow** get_windows(CInt* count) @extern("SDL_GetWindows");

<*
 Create a window with the specified dimensions and flags.
 This function is available since SDL 3.2.0.

 The window size is a request and may be different than expected based on
 the desktop layout and window manager policies. Your application should be
 prepared to handle a window of any size.

 `flags` may be any of the following OR'd together:

 - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution
 - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context
 - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another
   window
 - `SDL_WINDOW_HIDDEN`: window is not visible
 - `SDL_WINDOW_BORDERLESS`: no window decoration
 - `SDL_WINDOW_RESIZABLE`: window can be resized
 - `SDL_WINDOW_MINIMIZED`: window is minimized
 - `SDL_WINDOW_MAXIMIZED`: window is maximized
 - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus
 - `SDL_WINDOW_INPUT_FOCUS`: window has input focus
 - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus
 - `SDL_WINDOW_EXTERNAL`: window not created by SDL
 - `SDL_WINDOW_MODAL`: window is modal
 - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back
   buffer if possible
 - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to
   MOUSE_GRABBED)
 - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others
 - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not
   showing in the task bar and window list
 - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not
   get mouse or keyboard focus, requires a parent window
 - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,
   requires a parent window
 - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input
 - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance
 - `SDL_WINDOW_METAL`: window usable with a Metal instance
 - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer
 - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable

 The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.

 On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist
 property to YES, otherwise you will not receive a High-DPI OpenGL canvas.

 The window pixel size may differ from its window coordinate size if the
 window is on a high pixel density display. Use SDL_GetWindowSize() to query
 the client area's size in window coordinates, and
 SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the
 drawable size in pixels. Note that the drawable size can vary after the
 window is created and should be queried again if you get an
 SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.

 If the window is created with any of the SDL_WINDOW_OPENGL or
 SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function
 (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the
 corresponding UnloadLibrary function is called by SDL_DestroyWindow().

 If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,
 SDL_CreateWindow() will fail, because SDL_Vulkan_LoadLibrary() will fail.

 If SDL_WINDOW_METAL is specified on an OS that does not support Metal,
 SDL_CreateWindow() will fail.

 If you intend to use this window with an SDL_Renderer, you should use
 SDL_CreateWindowAndRenderer() instead of this function, to avoid window
 flicker.

 On non-Apple devices, SDL requires you to either not link to the Vulkan
 loader or link to a dynamic library version. This limitation may be removed
 in a future version of SDL.

 threadsafety: This function should only be called on the main thread.

 @param title : `the title of the window, in UTF-8 encoding.`
 @param w : `the width of the window.`
 @param h : `the height of the window.`
 @param flags : `0, or one or more SDL_WindowFlags OR'd together.`
 @return `the window that was created or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLWindow* create_window(ZString title, CInt w, CInt h, SDLWindowFlags flags) @extern("SDL_CreateWindow");

<*
 Create a child popup window of the specified parent window.
 This function is available since SDL 3.2.0.

 The window size is a request and may be different than expected based on
 the desktop layout and window manager policies. Your application should be
 prepared to handle a window of any size.

 The flags parameter **must** contain at least one of the following:

 - `SDL_WINDOW_TOOLTIP`: The popup window is a tooltip and will not pass any
   input events.
 - `SDL_WINDOW_POPUP_MENU`: The popup window is a popup menu. The topmost
   popup menu will implicitly gain the keyboard focus.

 The following flags are not relevant to popup window creation and will be
 ignored:

 - `SDL_WINDOW_MINIMIZED`
 - `SDL_WINDOW_MAXIMIZED`
 - `SDL_WINDOW_FULLSCREEN`
 - `SDL_WINDOW_BORDERLESS`

 The following flags are incompatible with popup window creation and will
 cause it to fail:

 - `SDL_WINDOW_UTILITY`
 - `SDL_WINDOW_MODAL`

 The parent parameter **must** be non-null and a valid window. The parent of
 a popup window can be either a regular, toplevel window, or another popup
 window.

 Popup windows cannot be minimized, maximized, made fullscreen, raised,
 flash, be made a modal window, be the parent of a toplevel window, or grab
 the mouse and/or keyboard. Attempts to do so will fail.

 Popup windows implicitly do not have a border/decorations and do not appear
 on the taskbar/dock or in lists of windows such as alt-tab menus.

 By default, popup window positions will automatically be constrained to keep
 the entire window within display bounds. This can be overridden with the
 `SDL_PROP_WINDOW_CREATE_CONSTRAIN_POPUP_BOOLEAN` property.

 By default, popup menus will automatically grab keyboard focus from the parent
 when shown. This behavior can be overridden by setting the `SDL_WINDOW_NOT_FOCUSABLE`
 flag, setting the `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN` property to false, or
 toggling it after creation via the `SDL_SetWindowFocusable()` function.

 If a parent window is hidden or destroyed, any child popup windows will be
 recursively hidden or destroyed as well. Child popup windows not explicitly
 hidden will be restored when the parent is shown.

 threadsafety: This function should only be called on the main thread.

 @param parent : `the parent of the window, must not be NULL.`
 @param offset_x : `the x position of the popup window relative to the origin
                 of the parent.`
 @param offset_y : `the y position of the popup window relative to the origin
                 of the parent window.`
 @param w : `the width of the window.`
 @param h : `the height of the window.`
 @param flags : `SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more
              additional SDL_WindowFlags OR'd together.`
 @return `the window that was created or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLWindow* create_popup_window(SDLWindow* parent, CInt offset_x, CInt offset_y, CInt w, CInt h, SDLWindowFlags flags) @extern("SDL_CreatePopupWindow");

<*
 Create a window with the specified properties.
 This function is available since SDL 3.2.0.

 The window size is a request and may be different than expected based on
 the desktop layout and window manager policies. Your application should be
 prepared to handle a window of any size.

 These are the supported properties:

 - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should
   be always on top
 - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no
   window decoration
 - `SDL_PROP_WINDOW_CREATE_CONSTRAIN_POPUP_BOOLEAN`: true if the "tooltip" and
   "menu" window types should be automatically constrained to be entirely within
   display bounds (default), false if no constraints on the position are desired.
 - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the
   window will be used with an externally managed graphics context.
 - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should
   accept keyboard input (defaults true)
 - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should
   start in fullscreen mode at desktop resolution
 - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window
 - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start
   hidden
 - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window
   uses a high pixel density buffer if possible
 - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should
   start maximized
 - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu
 - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used
   with Metal rendering
 - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should
   start minimized
 - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to
   its parent
 - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts
   with grabbed mouse focus
 - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used
   with OpenGL rendering
 - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the
   parent of this window, required for windows with the "tooltip", "menu",
   and "modal" properties
 - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be
   resizable
 - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8
   encoding
 - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show
   transparent in the areas with alpha of 0
 - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip
 - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility
   window, not showing in the task bar and window list
 - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used
   with Vulkan rendering
 - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window
 - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or
   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
   relative to the parent for windows with the "tooltip" or "menu" property
   set.
 - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or
   `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is
   relative to the parent for windows with the "tooltip" or "menu" property
   set.

 These are additional supported properties on macOS:

 - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the
   `(__unsafe_unretained)` NSWindow associated with the window, if you want
   to wrap an existing window.
 - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`
   NSView associated with the window, defaults to `[window contentView]`

 These are additional supported properties on Wayland:

 - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if
   the application wants to use the Wayland surface for a custom role and
   does not want it attached to an XDG toplevel window. See
   [README/wayland](README/wayland) for more information on using custom
   surfaces.
 - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the
   application wants an associated `wl_egl_window` object to be created and
   attached to the window, even if the window does not have the OpenGL
   property or `SDL_WINDOW_OPENGL` flag set.
 - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface
   associated with the window, if you want to wrap an existing window. See
   [README/wayland](README/wayland) for more information.

 These are additional supported properties on Windows:

 - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the
   window, if you want to wrap an existing window.
 - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,
   another window to share pixel format with, useful for OpenGL windows

 These are additional supported properties with X11:

 - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated
   with the window, if you want to wrap an existing window.

 The window is implicitly shown if the "hidden" property is not set.

 Windows with the "tooltip" and "menu" properties are popup windows and have
 the behaviors and guidelines outlined in SDL_CreatePopupWindow().

 If this window is being created to be used with an SDL_Renderer, you should
 not add a graphics API specific property
 (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that
 internally when it chooses a renderer. However, SDL might need to recreate
 your window at that point, which may cause the window to appear briefly,
 and then flicker as it is recreated. The correct approach to this is to
 create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property
 set to true, then create the renderer, then show the window with
 SDL_ShowWindow().

 threadsafety: This function should only be called on the main thread.

 @param props : `the properties to use.`
 @return `the window that was created or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLWindow* create_window_with_properties(SDLPropertiesID props) @extern("SDL_CreateWindowWithProperties");

enum SDLPropWindowCreate : const inline ZString
{
	ALWAYS_ON_TOP_BOOLEAN               = "SDL.window.create.always_on_top",
	BORDERLESS_BOOLEAN                  = "SDL.window.create.borderless",
	CONSTRAIN_POPUP_BOOLEAN             = "SDL.window.create.constrain_popup",
	FOCUSABLE_BOOLEAN                   = "SDL.window.create.focusable",
	EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN   = "SDL.window.create.external_graphics_context",
	FLAGS_NUMBER                        = "SDL.window.create.flags",
	FULLSCREEN_BOOLEAN                  = "SDL.window.create.fullscreen",
	HEIGHT_NUMBER                       = "SDL.window.create.height",
	HIDDEN_BOOLEAN                      = "SDL.window.create.hidden",
	HIGH_PIXEL_DENSITY_BOOLEAN          = "SDL.window.create.high_pixel_density",
	MAXIMIZED_BOOLEAN                   = "SDL.window.create.maximized",
	MENU_BOOLEAN                        = "SDL.window.create.menu",
	METAL_BOOLEAN                       = "SDL.window.create.metal",
	MINIMIZED_BOOLEAN                   = "SDL.window.create.minimized",
	MODAL_BOOLEAN                       = "SDL.window.create.modal",
	MOUSE_GRABBED_BOOLEAN               = "SDL.window.create.mouse_grabbed",
	OPENGL_BOOLEAN                      = "SDL.window.create.opengl",
	PARENT_POINTER                      = "SDL.window.create.parent",
	RESIZABLE_BOOLEAN                   = "SDL.window.create.resizable",
	TITLE_STRING                        = "SDL.window.create.title",
	TRANSPARENT_BOOLEAN                 = "SDL.window.create.transparent",
	TOOLTIP_BOOLEAN                     = "SDL.window.create.tooltip",
	UTILITY_BOOLEAN                     = "SDL.window.create.utility",
	VULKAN_BOOLEAN                      = "SDL.window.create.vulkan",
	WIDTH_NUMBER                        = "SDL.window.create.width",
	X_NUMBER                            = "SDL.window.create.x",
	Y_NUMBER                            = "SDL.window.create.y",
	COCOA_WINDOW_POINTER                = "SDL.window.create.cocoa.window",
	COCOA_VIEW_POINTER                  = "SDL.window.create.cocoa.view",
	WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN = "SDL.window.create.wayland.surface_role_custom",
	WAYLAND_CREATE_EGL_WINDOW_BOOLEAN   = "SDL.window.create.wayland.create_egl_window",
	WAYLAND_WL_SURFACE_POINTER          = "SDL.window.create.wayland.wl_surface",
	WIN32_HWND_POINTER                  = "SDL.window.create.win32.hwnd",
	WIN32_PIXEL_FORMAT_HWND_POINTER     = "SDL.window.create.win32.pixel_format_hwnd",
	X11_WINDOW_NUMBER                   = "SDL.window.create.x11.window",
}

<*
 Get the numeric ID of a window.
 This function is available since SDL 3.2.0.

 The numeric ID is what SDL_WindowEvent references, and is necessary to map
 these events to specific SDL_Window objects.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the ID of the window on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLWindowID SDLWindow.get_id(&window) @extern("SDL_GetWindowID");

<*
 Get a window from a stored ID.
 This function is available since SDL 3.2.0.

 The numeric ID is what SDL_WindowEvent references, and is necessary to map
 these events to specific SDL_Window objects.

 threadsafety: This function should only be called on the main thread.

 @param id : `the ID of the window.`
 @return `the window associated with 'id' or NULL if it doesn't exist; call
          SDL_GetError() for more information.`
*>
extern fn SDLWindow* get_window_from_id(SDLWindowID id) @extern("SDL_GetWindowFromID");

<*
 Get parent of a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the parent of the window on success or NULL if the window has no
          parent.`
*>
extern fn SDLWindow* SDLWindow.get_parent(&window) @extern("SDL_GetWindowParent");

<*
 Get the properties associated with a window.
 This function is available since SDL 3.2.0.

 The following read-only properties are provided by SDL:

 - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped
   window
 - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR
   headroom above the SDR white point. This property can change dynamically
   when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the
   SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the
   SDR white level in scRGB colorspace, and on Apple platforms this is
   always 1.0 for EDR content. This property can change dynamically when
   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range
   that can be displayed, in terms of the SDR white point. When HDR is not
   enabled, this will be 1.0. This property can change dynamically when
   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.

 On Android:

 - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated
   with the window
 - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with
   the window

 On iOS:

 - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`
   UIWindow associated with the window
 - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
   associated with metal views on the window
 - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's
   framebuffer object. It must be bound when rendering to the screen using
   OpenGL.
 - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's
   renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.
 - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL
   view's resolve framebuffer, when MSAA is used.

 On KMS/DRM:

 - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated
   with the window (e.g. the X in /dev/dri/cardX)
 - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the
   window
 - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated
   with the window

 On macOS:

 - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`
   NSWindow associated with the window
 - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag
   associated with metal views on the window

 On OpenVR:

 - `SDL_PROP_WINDOW_OPENVR_OVERLAY_ID`: the OpenVR Overlay Handle ID for the
   associated overlay window.

 On Vivante:

 - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType
   associated with the window
 - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType
   associated with the window
 - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with
   the window

 On Windows:

 - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window
 - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window
 - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with
   the window

 On Wayland:

 Note: The `xdg_*` window objects do not internally persist across window
 show/hide calls. They will be null if the window is hidden and must be
 queried each time it is shown.

 - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with
   the window
 - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with
   the window
 - `SDL_PROP_WINDOW_WAYLAND_VIEWPORT_POINTER`: the wp_viewport associated
   with the window
 - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window
   associated with the window
 - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated
   with the window
 - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role
   associated with the window
 - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export
   handle associated with the window
 - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role
   associated with the window
 - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner
   associated with the window, in popup mode

 On X11:

 - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with
   the window
 - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with
   the window
 - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the
   window

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLWindow.get_properties(&window) @extern("SDL_GetWindowProperties");

enum SDLPropWindow : const inline ZString
{
	SHAPE_POINTER                               = "SDL.window.shape",
	HDR_ENABLED_BOOLEAN                         = "SDL.window.HDR_enabled",
	SDR_WHITE_LEVEL_FLOAT                       = "SDL.window.SDR_white_level",
	HDR_HEADROOM_FLOAT                          = "SDL.window.HDR_headroom",
	ANDROID_WINDOW_POINTER                      = "SDL.window.android.window",
	ANDROID_SURFACE_POINTER                     = "SDL.window.android.surface",
	UIKIT_WINDOW_POINTER                        = "SDL.window.uikit.window",
	UIKIT_METAL_VIEW_TAG_NUMBER                 = "SDL.window.uikit.metal_view_tag",
	UIKIT_OPENGL_FRAMEBUFFER_NUMBER             = "SDL.window.uikit.opengl.framebuffer",
	UIKIT_OPENGL_RENDERBUFFER_NUMBER            = "SDL.window.uikit.opengl.renderbuffer",
	UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER     = "SDL.window.uikit.opengl.resolve_framebuffer",
	KMSDRM_DEVICE_INDEX_NUMBER                  = "SDL.window.kmsdrm.dev_index",
	KMSDRM_DRM_FD_NUMBER                        = "SDL.window.kmsdrm.drm_fd",
	KMSDRM_GBM_DEVICE_POINTER                   = "SDL.window.kmsdrm.gbm_dev",
	COCOA_WINDOW_POINTER                        = "SDL.window.cocoa.window",
	COCOA_METAL_VIEW_TAG_NUMBER                 = "SDL.window.cocoa.metal_view_tag",
	OPENVR_OVERLAY_ID                           = "SDL.window.openvr.overlay_id",
	VIVANTE_DISPLAY_POINTER                     = "SDL.window.vivante.display",
	VIVANTE_WINDOW_POINTER                      = "SDL.window.vivante.window",
	VIVANTE_SURFACE_POINTER                     = "SDL.window.vivante.surface",
	WIN32_HWND_POINTER                          = "SDL.window.win32.hwnd",
	WIN32_HDC_POINTER                           = "SDL.window.win32.hdc",
	WIN32_INSTANCE_POINTER                      = "SDL.window.win32.instance",
	WAYLAND_DISPLAY_POINTER                     = "SDL.window.wayland.display",
	WAYLAND_SURFACE_POINTER                     = "SDL.window.wayland.surface",
	WAYLAND_VIEWPORT_POINTER                    = "SDL.window.wayland.viewport",
	WAYLAND_EGL_WINDOW_POINTER                  = "SDL.window.wayland.egl_window",
	WAYLAND_XDG_SURFACE_POINTER                 = "SDL.window.wayland.xdg_surface",
	WAYLAND_XDG_TOPLEVEL_POINTER                = "SDL.window.wayland.xdg_toplevel",
	WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING   = "SDL.window.wayland.xdg_toplevel_export_handle",
	WAYLAND_XDG_POPUP_POINTER                   = "SDL.window.wayland.xdg_popup",
	WAYLAND_XDG_POSITIONER_POINTER              = "SDL.window.wayland.xdg_positioner",
	X11_DISPLAY_POINTER                         = "SDL.window.x11.display",
	X11_SCREEN_NUMBER                           = "SDL.window.x11.screen",
	X11_WINDOW_NUMBER                           = "SDL.window.x11.window",
}

<*
 Get the window flags.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `a mask of the SDL_WindowFlags associated with 'window'.`
*>
extern fn SDLWindowFlags SDLWindow.get_flags(&window) @extern("SDL_GetWindowFlags");

<*
 Set the title of a window.
 This function is available since SDL 3.2.0.

 This string is expected to be in UTF-8 encoding.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param title : `the desired window title in UTF-8 format.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_title(&window, ZString title) @extern("SDL_SetWindowTitle");

<*
 Get the title of a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the title of the window in UTF-8 format or "" if there is no
          title.`
*>
extern fn ZString SDLWindow.get_title(&window) @extern("SDL_GetWindowTitle");

<*
 Set the icon for a window.
 This function is available since SDL 3.2.0.

 If this function is passed a surface with alternate representations, the
 surface will be interpreted as the content to be used for 100% display
 scale, and the alternate representations will be used for high DPI
 situations. For example, if the original surface is 32x32, then on a 2x
 macOS display or 200% display scale on Windows, a 64x64 version of the
 image will be used, if available. If a matching version of the image isn't
 available, the closest larger size image will be downscaled to the
 appropriate size and be used instead, if available. Otherwise, the closest
 smaller image will be upscaled and be used instead.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param icon : `an SDL_Surface structure containing the icon for the window.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_icon(&window, SDLSurface* icon) @extern("SDL_SetWindowIcon");

<*
 Request that the window's position be set.
 This function is available since SDL 3.2.0.

 If the window is in an exclusive fullscreen or maximized state, this
 request has no effect.

 This can be used to reposition fullscreen-desktop windows onto a different
 display, however, as exclusive fullscreen windows are locked to a specific
 display, they can only be repositioned programmatically via
 SDL_SetWindowFullscreenMode().

 On some windowing systems this request is asynchronous and the new
 coordinates may not have have been applied immediately upon the return of
 this function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be
 emitted with the window's new coordinates. Note that the new coordinates
 may not match the exact coordinates requested, as some windowing systems
 can restrict the position of the window in certain scenarios (e.g.
 constraining the position so the window is always within desktop bounds).
 Additionally, as this is just a request, it can be denied by the windowing
 system.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to reposition.`
 @param x : `the x coordinate of the window, or 'SDL_WINDOWPOS_CENTERED' or
          'SDL_WINDOWPOS_UNDEFINED'.`
 @param y : `the y coordinate of the window, or 'SDL_WINDOWPOS_CENTERED' or
          'SDL_WINDOWPOS_UNDEFINED'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_position(&window, CInt x, CInt y) @extern("SDL_SetWindowPosition");

<*
 Get the position of a window.
 This function is available since SDL 3.2.0.

 This is the current position of the window as last reported by the
 windowing system.

 If you do not need the value for one of the positions a NULL may be passed
 in the `x` or `y` parameter.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param x : `a pointer filled in with the x position of the window, may be
          NULL.`
 @param y : `a pointer filled in with the y position of the window, may be
          NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_position(&window, CInt* x, CInt* y) @extern("SDL_GetWindowPosition");

<*
 Request that the size of a window's client area be set.
 This function is available since SDL 3.2.0.

 If the window is in a fullscreen or maximized state, this request has no
 effect.

 To change the exclusive fullscreen mode of a window, use
 SDL_SetWindowFullscreenMode().

 On some windowing systems, this request is asynchronous and the new window
 size may not have have been applied immediately upon the return of this
 function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 emitted with the new window dimensions. Note that the new dimensions may
 not match the exact size requested, as some windowing systems can restrict
 the window size in certain scenarios (e.g. constraining the size of the
 content area to remain within the usable desktop bounds). Additionally, as
 this is just a request, it can be denied by the windowing system.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param w : `the width of the window, must be > 0.`
 @param h : `the height of the window, must be > 0.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_size(&window, CInt w, CInt h) @extern("SDL_SetWindowSize");

<*
 Get the size of a window's client area.
 This function is available since SDL 3.2.0.

 The window pixel size may differ from its window coordinate size if the
 window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()
 or SDL_GetRenderOutputSize() to get the real client area size in pixels.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query the width and height from.`
 @param w : `a pointer filled in with the width of the window, may be NULL.`
 @param h : `a pointer filled in with the height of the window, may be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowSize");

<*
 Get the safe area for this window.
 This function is available since SDL 3.2.0.

 Some devices have portions of the screen which are partially obscured or
 not interactive, possibly due to on-screen controls, curved edges, camera
 notches, TV overscan, etc. This function provides the area of the window
 which is safe to have interactable content. You should continue rendering
 into the rest of the window, but it should not contain visually important
 or interactible content.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param rect : `a pointer filled in with the client area that is safe for
             interactive content.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_safe_area(&window, SDLRect* rect) @extern("SDL_GetWindowSafeArea");

<*
 Request that the aspect ratio of a window's client area be set.
 This function is available since SDL 3.2.0.

 The aspect ratio is the ratio of width divided by height, e.g. 2560x1600
 would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are
 narrower.

 If, at the time of this request, the window in a fixed-size state, such as
 maximized or fullscreen, the request will be deferred until the window
 exits this state and becomes resizable again.

 On some windowing systems, this request is asynchronous and the new window
 aspect ratio may not have have been applied immediately upon the return of
 this function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be
 emitted with the new window dimensions. Note that the new dimensions may
 not match the exact aspect ratio requested, as some windowing systems can
 restrict the window size in certain scenarios (e.g. constraining the size
 of the content area to remain within the usable desktop bounds).
 Additionally, as this is just a request, it can be denied by the windowing
 system.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param min_aspect : `the minimum aspect ratio of the window, or 0.0f for no
                   limit.`
 @param max_aspect : `the maximum aspect ratio of the window, or 0.0f for no
                   limit.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_aspect_ratio(&window, float min_aspect, float max_aspect) @extern("SDL_SetWindowAspectRatio");

<*
 Get the size of a window's client area.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query the width and height from.`
 @param min_aspect : `a pointer filled in with the minimum aspect ratio of the
                   window, may be NULL.`
 @param max_aspect : `a pointer filled in with the maximum aspect ratio of the
                   window, may be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_aspect_ratio(&window, float* min_aspect, float* max_aspect) @extern("SDL_GetWindowAspectRatio");

<*
 Get the size of a window's borders (decorations) around the client area.
 This function is available since SDL 3.2.0.

 Note: If this function fails (returns false), the size values will be
 initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the
 window in question was borderless.

 Note: This function may fail on systems where the window has not yet been
 decorated by the display server (for example, immediately after calling
 SDL_CreateWindow). It is recommended that you wait at least until the
 window has been presented and composited, so that the window system has a
 chance to decorate the window and provide the border dimensions to SDL.

 This function also returns false if getting the information is not
 supported.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query the size values of the border
               (decorations) from.`
 @param top : `pointer to variable for storing the size of the top border; NULL
            is permitted.`
 @param left : `pointer to variable for storing the size of the left border;
             NULL is permitted.`
 @param bottom : `pointer to variable for storing the size of the bottom
               border; NULL is permitted.`
 @param right : `pointer to variable for storing the size of the right border;
              NULL is permitted.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_borders_size(&window, CInt* top, CInt* left, CInt *bottom, CInt *right) @extern("SDL_GetWindowBordersSize");

<*
 Get the size of a window's client area, in pixels.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window from which the drawable size should be queried.`
 @param w : `a pointer to variable for storing the width in pixels, may be
          NULL.`
 @param h : `a pointer to variable for storing the height in pixels, may be
          NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_size_in_pixels(&window, CInt* w, CInt* h) @extern("SDL_GetWindowSizeInPixels");

<*
 Set the minimum size of a window's client area.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param min_w : `the minimum width of the window, or 0 for no limit.`
 @param min_h : `the minimum height of the window, or 0 for no limit.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_minimum_size(&window, CInt min_w, CInt min_h) @extern("SDL_SetWindowMinimumSize");

<*
 Get the minimum size of a window's client area.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param w : `a pointer filled in with the minimum width of the window, may be
          NULL.`
 @param h : `a pointer filled in with the minimum height of the window, may be
          NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_minimum_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowMinimumSize");

<*
 Set the maximum size of a window's client area.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param max_w : `the maximum width of the window, or 0 for no limit.`
 @param max_h : `the maximum height of the window, or 0 for no limit.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_maximum_size(&window, CInt max_w, CInt max_h) @extern("SDL_SetWindowMaximumSize");

<*
 Get the maximum size of a window's client area.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param w : `a pointer filled in with the maximum width of the window, may be
          NULL.`
 @param h : `a pointer filled in with the maximum height of the window, may be
          NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_maximum_size(&window, CInt* w, CInt* h) @extern("SDL_GetWindowMaximumSize");

<*
 Set the border state of a window.
 This function is available since SDL 3.2.0.

 This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add
 or remove the border from the actual window. This is a no-op if the
 window's border already matches the requested state.

 You can't change the border state of a fullscreen window.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window of which to change the border state.`
 @param bordered : `false to remove border, true to add border.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_bordered(&window, bool bordered) @extern("SDL_SetWindowBordered");

<*
 Set the user-resizable state of a window.
 This function is available since SDL 3.2.0.

 This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and
 allow/disallow user resizing of the window. This is a no-op if the window's
 resizable state already matches the requested state.

 You can't change the resizable state of a fullscreen window.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window of which to change the resizable state.`
 @param resizable : `true to allow resizing, false to disallow.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_resizable(&window, bool resizable) @extern("SDL_SetWindowResizable");

<*
 Set the window to always be above the others.
 This function is available since SDL 3.2.0.

 This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This
 will bring the window to the front and keep the window above the rest.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window of which to change the always on top state.`
 @param on_top : `true to set the window always on top, false to disable.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_always_on_top(&window, bool on_top) @extern("SDL_SetWindowAlwaysOnTop");

<*
 Show a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to show.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.show(&window) @extern("SDL_ShowWindow");

<*
 Hide a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to hide.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.hide(&window) @extern("SDL_HideWindow");

<*
 Request that a window be raised above other windows and gain the input
 focus.
 This function is available since SDL 3.2.0.

 The result of this request is subject to desktop window manager policy,
 particularly if raising the requested window would result in stealing focus
 from another application. If the window is successfully raised and gains
 input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and
 the window will have the SDL_WINDOW_INPUT_FOCUS flag set.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to raise.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.raise(&window) @extern("SDL_RaiseWindow");

<*
 Request that the window be made as large as possible.
 This function is available since SDL 3.2.0.

 Non-resizable windows can't be maximized. The window must have the
 SDL_WINDOW_RESIZABLE flag set, or this will have no effect.

 On some windowing systems this request is asynchronous and the new window
 state may not have have been applied immediately upon the return of this
 function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be
 emitted. Note that, as this is just a request, the windowing system can
 deny the state change.

 When maximizing a window, whether the constraints set via
 SDL_SetWindowMaximumSize() are honored depends on the policy of the window
 manager. Win32 and macOS enforce the constraints when maximizing, while X11
 and Wayland window managers may vary.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to maximize.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.maximize(&window) @extern("SDL_MaximizeWindow");

<*
 Request that the window be minimized to an iconic representation.
 This function is available since SDL 3.2.0.

 If the window is in a fullscreen state, this request has no direct effect.
 It may alter the state the window is returned to when leaving fullscreen.

 On some windowing systems this request is asynchronous and the new window
 state may not have been applied immediately upon the return of this
 function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be
 emitted. Note that, as this is just a request, the windowing system can
 deny the state change.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to minimize.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.minimize(&window) @extern("SDL_MinimizeWindow");

<*
 Request that the size and position of a minimized or maximized window be
 restored.
 This function is available since SDL 3.2.0.

 If the window is in a fullscreen state, this request has no direct effect.
 It may alter the state the window is returned to when leaving fullscreen.

 On some windowing systems this request is asynchronous and the new window
 state may not have have been applied immediately upon the return of this
 function. If an immediate change is required, call SDL_SyncWindow() to
 block until the changes have taken effect.

 When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be
 emitted. Note that, as this is just a request, the windowing system can
 deny the state change.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to restore.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.restore(&window) @extern("SDL_RestoreWindow");

<*
 Request that the window's fullscreen state be changed.
 This function is available since SDL 3.2.0.

 By default a window in fullscreen state uses borderless fullscreen desktop
 mode, but a specific exclusive display mode can be set using
 SDL_SetWindowFullscreenMode().

 On some windowing systems this request is asynchronous and the new
 fullscreen state may not have have been applied immediately upon the return
 of this function. If an immediate change is required, call SDL_SyncWindow()
 to block until the changes have taken effect.

 When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or
 SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this
 is just a request, it can be denied by the windowing system.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param fullscreen : `true for fullscreen mode, false for windowed mode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_fullscreen(&window, bool fullscreen) @extern("SDL_SetWindowFullscreen");

<*
 Block until any pending window state is finalized.
 This function is available since SDL 3.2.0.

 On asynchronous windowing systems, this acts as a synchronization barrier
 for pending window state. It will attempt to wait until any pending window
 state has been applied and is guaranteed to return within finite time. Note
 that for how long it can potentially block depends on the underlying window
 system, as window state changes may involve somewhat lengthy animations
 that must complete before the window is in its final requested state.

 On windowing systems where changes are immediate, this does nothing.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window for which to wait for the pending state to be
               applied.`
 @return `true on success or false if the operation timed out before the
          window was in the requested state.`
*>
extern fn bool SDLWindow.sync(&window) @extern("SDL_SyncWindow");

<*
 Return whether the window has a surface associated with it.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `true if there is a surface associated with the window, or false
          otherwise.`
*>
extern fn bool SDLWindow.has_surface(&window) @extern("SDL_WindowHasSurface");

<*
 Get the SDL surface associated with the window.
 This function is available since SDL 3.2.0.

 A new surface will be created with the optimal format for the window, if
 necessary. This surface will be freed when the window is destroyed. Do not
 free this surface.

 This surface will be invalidated if the window is resized. After resizing a
 window this function must be called again to return a valid surface.

 You may not combine this with 3D or the rendering API on this window.

 This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the surface associated with the window, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLSurface* SDLWindow.get_surface(&window) @extern("SDL_GetWindowSurface");

<*
 Toggle VSync for the window surface.
 This function is available since SDL 3.2.0.

 When a window surface is created, vsync defaults to
 SDL_WINDOW_SURFACE_VSYNC_DISABLED.

 The `vsync` parameter can be 1 to synchronize present with every vertical
 refresh, 2 to synchronize present with every second vertical refresh, etc.,
 SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),
 or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is
 supported by every driver, so you should check the return value to see
 whether the requested setting is supported.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window.`
 @param vsync : `the vertical refresh sync interval.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_surface_vsync(&window, CInt vsync) @extern("SDL_SetWindowSurfaceVSync");

const WINDOW_SURFACE_VSYNC_DISABLED = 0;
const WINDOW_SURFACE_VSYNC_ADAPTIVE = -1;

<*
 Get VSync for the window surface.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @param vsync : `an int filled with the current vertical refresh sync interval.
              See SDL_SetWindowSurfaceVSync() for the meaning of the value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.get_surface_vsync(&window, CInt* vsync) @extern("SDL_GetWindowSurfaceVSync");

<*
 Copy the window surface to the screen.
 This function is available since SDL 3.2.0.

 This is the function you use to reflect any changes to the surface on the
 screen.

 This function is equivalent to the SDL 1.2 API SDL_Flip().

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to update.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.update_surface(&window) @extern("SDL_UpdateWindowSurface");

<*
 Copy areas of the window surface to the screen.
 This function is available since SDL 3.2.0.

 This is the function you use to reflect changes to portions of the surface
 on the screen.

 This function is equivalent to the SDL 1.2 API SDL_UpdateRects().

 Note that this function will update _at least_ the rectangles specified,
 but this is only intended as an optimization; in practice, this might
 update more of the screen (or all of the screen!), depending on what method
 SDL uses to send pixels to the system.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to update.`
 @param rects : `an array of SDL_Rect structures representing areas of the
              surface to copy, in pixels.`
 @param numrects : `the number of rectangles.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.update_surface_rects(&window, SDLRect* rects, CInt numrects) @extern("SDL_UpdateWindowSurfaceRects");

<*
 Destroy the surface associated with the window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to update.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.destroy_surface(&window) @extern("SDL_DestroyWindowSurface");

<*
 Set a window's keyboard grab mode.
 This function is available since SDL 3.2.0.

 Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or
 the Meta/Super key. Note that not all system keyboard shortcuts can be
 captured by applications (one example is Ctrl+Alt+Del on Windows).

 This is primarily intended for specialized applications such as VNC clients
 or VM frontends. Normal games should not use keyboard grab.

 When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the
 window is full-screen to ensure the user is not trapped in your
 application. If you have a custom keyboard shortcut to exit fullscreen
 mode, you may suppress this behavior with
 `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.

 If the caller enables a grab while another window is currently grabbed, the
 other window loses its grab in favor of the caller's window.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window for which the keyboard grab mode should be set.`
 @param grabbed : `this is true to grab keyboard, and false to release.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_keyboard_grab(&window, bool grabbed) @extern("SDL_SetWindowKeyboardGrab");

<*
 Set a window's mouse grab mode.
 This function is available since SDL 3.2.0.

 Mouse grab confines the mouse cursor to the window.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window for which the mouse grab mode should be set.`
 @param grabbed : `this is true to grab mouse, and false to release.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_mouse_grab(&window, bool grabbed) @extern("SDL_SetWindowMouseGrab");

<*
 Get a window's keyboard grab mode.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `true if keyboard is grabbed, and false otherwise.`
*>
extern fn bool SDLWindow.get_keyboard_grab(&window) @extern("SDL_GetWindowKeyboardGrab");

<*
 Get a window's mouse grab mode.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `true if mouse is grabbed, and false otherwise.`
*>
extern fn bool SDLWindow.get_mouse_grab(&window) @extern("SDL_GetWindowMouseGrab");

<*
 Get the window that currently has an input grab enabled.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the window if input is grabbed or NULL otherwise.`
*>
extern fn SDLWindow* get_grabbed_window() @extern("SDL_GetGrabbedWindow");

<*
 Confines the cursor to the specified area of a window.
 This function is available since SDL 3.2.0.

 Note that this does NOT grab the cursor, it only defines the area a cursor
 is restricted to when the window has mouse focus.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window that will be associated with the barrier.`
 @param rect : `a rectangle area in window-relative coordinates. If NULL the
             barrier for the specified window will be destroyed.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_mouse_rect(&window, SDLRect* rect) @extern("SDL_SetWindowMouseRect");

<*
 Get the mouse confinement rectangle of a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `a pointer to the mouse confinement rectangle of a window, or NULL
          if there isn't one.`
*>
extern fn SDLRect* SDLWindow.get_mouse_rect(&window) @extern("SDL_GetWindowMouseRect");

<*
 Set the opacity for a window.
 This function is available since SDL 3.2.0.

 The parameter `opacity` will be clamped internally between 0.0f
 (transparent) and 1.0f (opaque).

 This function also returns false if setting the opacity isn't supported.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window which will be made transparent or opaque.`
 @param opacity : `the opacity value (0.0f - transparent, 1.0f - opaque).`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_opacity(&window, float opacity) @extern("SDL_SetWindowOpacity");

<*
 Get the opacity of a window.
 This function is available since SDL 3.2.0.

 If transparency isn't supported on this platform, opacity will be returned
 as 1.0f without error.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to get the current opacity value from.`
 @return `the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on
          failure; call SDL_GetError() for more information.`
*>
extern fn float SDLWindow.get_opacity(&window) @extern("SDL_GetWindowOpacity");

<*
 Set the window as a child of a parent window.
 This function is available since SDL 3.2.0.

 If the window is already the child of an existing window, it will be
 reparented to the new owner. Setting the parent window to NULL unparents
 the window and removes child window status.

 If a parent window is hidden or destroyed, the operation will be
 recursively applied to child windows. Child windows hidden with the parent
 that did not have their hidden status explicitly set will be restored when
 the parent is shown.

 Attempting to set the parent of a window that is currently in the modal
 state will fail. Use SDL_SetWindowModal() to cancel the modal status before
 attempting to change the parent.

 Popup windows cannot change parents and attempts to do so will fail.

 Setting a parent window that is currently the sibling or descendent of the
 child window results in undefined behavior.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window that should become the child of a parent.`
 @param parent : `the new parent window for the child window.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_parent(&window, SDLWindow* parent) @extern("SDL_SetWindowParent");

<*
 Toggle the state of the window as modal.
 This function is available since SDL 3.2.0.

 To enable modal status on a window, the window must currently be the child
 window of a parent, or toggling modal status on will fail.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window on which to set the modal state.`
 @param modal : `true to toggle modal status on, false to toggle it off.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_modal(&window, bool modal) @extern("SDL_SetWindowModal");

<*
 Set whether the window may have input focus.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to set focusable state.`
 @param focusable : `true to allow input focus, false to not allow input focus.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_focusable(&window, bool focusable) @extern("SDL_SetWindowFocusable");

<*
 Display the system-level window menu.
 This function is available since SDL 3.2.0.

 This default window menu is provided by the system and on some platforms
 provides functionality for setting or changing privileged state on the
 window, such as moving it between workspaces or displays, or toggling the
 always-on-top property.

 On platforms or desktops where this is unsupported, this function does
 nothing.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window for which the menu will be displayed.`
 @param x : `the x coordinate of the menu, relative to the origin (top-left) of
          the client area.`
 @param y : `the y coordinate of the menu, relative to the origin (top-left) of
          the client area.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.show_system_menu(&window, CInt x, CInt y) @extern("SDL_ShowWindowSystemMenu");

<*
 Possible return values from the SDL_HitTest callback.
 This enum is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.
*>
enum SDLHitTestResult : const CInt
{
    NORMAL,             // Region is normal. No special properties.
    DRAGGABLE,          // Region can drag entire window.
    RESIZE_TOPLEFT,     // Region is the resizable top-left corner border.
    RESIZE_TOP,         // Region is the resizable top border.
    RESIZE_TOPRIGHT,    // Region is the resizable top-right corner border.
    RESIZE_RIGHT,       // Region is the resizable right border.
    RESIZE_BOTTOMRIGHT, // Region is the resizable bottom-right corner border.
    RESIZE_BOTTOM,      // Region is the resizable bottom border.
    RESIZE_BOTTOMLEFT,  // Region is the resizable bottom-left corner border.
    RESIZE_LEFT,         // Region is the resizable left border.
}

<*
 Callback used for hit-testing.

 @param win : `the SDL_Window where hit-testing was set on.`
 @param area : `an SDL_Point which should be hit-tested.`
 @param data : `what was passed as 'callback_data' to SDL_SetWindowHitTest().`
 @return `an SDL_HitTestResult value.`
*>
alias SDLHitTest = fn SDLHitTestResult(SDLWindow* win, SDLPoint* area, void* data);

<*
 Provide a callback that decides if a window region has special properties.
 This function is available since SDL 3.2.0.

 Normally windows are dragged and resized by decorations provided by the
 system window manager (a title bar, borders, etc), but for some apps, it
 makes sense to drag them from somewhere else inside the window itself; for
 example, one might have a borderless window that wants to be draggable from
 any part, or simulate its own title bar, etc.

 This function lets the app provide a callback that designates pieces of a
 given window as special. This callback is run during event processing if we
 need to tell the OS to treat a region of the window specially; the use of
 this callback is known as "hit testing."

 Mouse input may not be delivered to your application if it is within a
 special area; the OS will often apply that input to moving the window or
 resizing the window and not deliver it to the application.

 Specifying NULL for a callback disables hit-testing. Hit-testing is
 disabled by default.

 Platforms that don't support this functionality will return false
 unconditionally, even if you're attempting to disable hit-testing.

 Your callback may fire at any time, and its firing does not indicate any
 specific behavior (for example, on Windows, this certainly might fire when
 the OS is deciding whether to drag your window, but it fires for lots of
 other reasons, too, some unrelated to anything you probably care about _and
 when the mouse isn't actually at the location it is testing_). Since this
 can fire at any time, you should try to keep your callback efficient,
 devoid of allocations, etc.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to set hit-testing on.`
 @param callback : `the function to call when doing a hit-test.`
 @param callback_data : `an app-defined void pointer passed to **callback**.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_hit_test(&window, SDLHitTest callback, void* callback_data) @extern("SDL_SetWindowHitTest");

<*
 Set the shape of a transparent window.
 This function is available since SDL 3.2.0.

 This sets the alpha channel of a transparent window and any fully
 transparent areas are also transparent to mouse clicks. If you are using
 something besides the SDL render API, then you are responsible for drawing
 the alpha channel of the window to match the shape alpha channel to get
 consistent cross-platform results.

 The shape is copied inside this function, so you can free it afterwards. If
 your shape surface changes, you should call SDL_SetWindowShape() again to
 update the window. This is an expensive operation, so should be done
 sparingly.

 The window must have been created with the SDL_WINDOW_TRANSPARENT flag.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window.`
 @param shape : `the surface representing the shape of the window, or NULL to
              remove any current shape.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_shape(&window, SDLSurface* shape) @extern("SDL_SetWindowShape");

<*
 Request a window to demand attention from the user.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to be flashed.`
 @param operation : `the operation to perform.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.flash(&window, SDLFlashOperation operation) @extern("SDL_FlashWindow");

<*
 Destroy a window.
 This function is available since SDL 3.2.0.

 Any child windows owned by the window will be recursively destroyed as
 well.

 Note that on some platforms, the visible window may not actually be removed
 from the screen until the SDL event loop is pumped again, even though the
 SDL_Window is no longer valid after this call.

 threadsafety: This function should only be called on the main thread.


 @param window : `the window to destroy.`
*>
extern fn void SDLWindow.destroy(&window) @extern("SDL_DestroyWindow");

<*
 Check whether the screensaver is currently enabled.
 This function is available since SDL 3.2.0.

 The screensaver is disabled by default.

 The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.

 threadsafety: This function should only be called on the main thread.


 @return `true if the screensaver is enabled, false if it is disabled.`
*>
extern fn bool screen_saver_enabled() @extern("SDL_ScreenSaverEnabled");

<*
 Allow the screen to be blanked by a screen saver.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.


 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool enable_screen_saver() @extern("SDL_EnableScreenSaver");

<*
 Prevent the screen from being blanked by a screen saver.
 This function is available since SDL 3.2.0.

 If you disable the screensaver, it is automatically re-enabled when SDL
 quits.

 The screensaver is disabled by default, but this may by changed by
 SDL_HINT_VIDEO_ALLOW_SCREENSAVER.

 threadsafety: This function should only be called on the main thread.


 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool disable_screen_saver() @extern("SDL_DisableScreenSaver");

/* OpenGL support functions */

<*
 Dynamically load an OpenGL library.
 This function is available since SDL 3.2.0.

 This should be done after initializing the video driver, but before
 creating any OpenGL windows. If no OpenGL library is loaded, the default
 library will be loaded upon creation of the first OpenGL window.

 If you do this, you need to retrieve all of the GL functions used in your
 program from the dynamic library using SDL_GL_GetProcAddress().

 threadsafety: This function should only be called on the main thread.


 @param path : `the platform dependent OpenGL library name, or NULL to open the
             default OpenGL library.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_load_library(ZString path) @extern("SDL_GL_LoadLibrary");

<*
 Get an OpenGL function by name.
 This function is available since SDL 3.2.0.

 If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all
 GL functions must be retrieved this way. Usually this is used to retrieve
 function pointers to OpenGL extensions.

 There are some quirks to looking up OpenGL functions that require some
 extra care from the application. If you code carefully, you can handle
 these quirks without any platform-specific code, though:

 - On Windows, function pointers are specific to the current GL context;
   this means you need to have created a GL context and made it current
   before calling SDL_GL_GetProcAddress(). If you recreate your context or
   create a second context, you should assume that any existing function
   pointers aren't valid to use with it. This is (currently) a
   Windows-specific limitation, and in practice lots of drivers don't suffer
   this limitation, but it is still the way the wgl API is documented to
   work and you should expect crashes if you don't respect it. Store a copy
   of the function pointers that comes and goes with context lifespan.
 - On X11, function pointers returned by this function are valid for any
   context, and can even be looked up before a context is created at all.
   This means that, for at least some common OpenGL implementations, if you
   look up a function that doesn't exist, you'll get a non-NULL result that
   is _NOT_ safe to call. You must always make sure the function is actually
   available for a given GL context before calling it, by checking for the
   existence of the appropriate extension with SDL_GL_ExtensionSupported(),
   or verifying that the version of OpenGL you're using offers the function
   as core functionality.
 - Some OpenGL drivers, on all platforms, *will* return NULL if a function
   isn't supported, but you can't count on this behavior. Check for
   extensions you use, and if you get a NULL anyway, act as if that
   extension wasn't available. This is probably a bug in the driver, but you
   can code defensively for this scenario anyhow.
 - Just because you're on Linux/Unix, don't assume you'll be using X11.
   Next-gen display servers are waiting to replace it, and may or may not
   make the same promises about function pointers.
 - OpenGL function pointers must be declared `APIENTRY` as in the example
   code. This will ensure the proper calling convention is followed on
   platforms where this matters (Win32) thereby avoiding stack corruption.

 threadsafety: This function should only be called on the main thread.


 @param proc : `the name of an OpenGL function.`
 @return `a pointer to the named OpenGL function. The returned pointer
          should be cast to the appropriate function signature.`
*>
extern fn SDLFunctionPointer gl_get_proc_address(ZString proc) @extern("SDL_GL_GetProcAddress");

<*
 Get an EGL library function by name.
 This function is available since SDL 3.2.0.

 If an EGL library is loaded, this function allows applications to get entry
 points for EGL functions. This is useful to provide to an EGL API and
 extension loader.

 threadsafety: This function should only be called on the main thread.


 @param proc : `the name of an EGL function.`
 @return `a pointer to the named EGL function. The returned pointer should
          be cast to the appropriate function signature.`
*>
extern fn SDLFunctionPointer egl_get_proc_address(ZString proc) @extern("SDL_EGL_GetProcAddress");

<*
 Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.
*>
extern fn void gl_unload_library() @extern("SDL_GL_UnloadLibrary");

<*
 Check if an OpenGL extension is supported for the current context.
 This function is available since SDL 3.2.0.

 This function operates on the current GL context; you must have created a
 context and it must be current before calling this function. Do not assume
 that all contexts you create will have the same set of extensions
 available, or that recreating an existing context will offer the same
 extensions again.

 While it's probably not a massive overhead, this function is not an O(1)
 operation. Check the extensions you care about after creating the GL
 context and save that information somewhere instead of calling the function
 every time you need to know.

 threadsafety: This function should only be called on the main thread.

 @param extension : `the name of the extension to check.`
 @return `true if the extension is supported, false otherwise.`
*>
extern fn bool gl_extension_supported(ZString extension) @extern("SDL_GL_ExtensionSupported");

<*
 Reset all previously set OpenGL context attributes to their default values.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.
*>
extern fn void gl_reset_attributes() @extern("SDL_GL_ResetAttributes");

<*
 Set an OpenGL window attribute before window creation.
 This function is available since SDL 3.2.0.

 This function sets the OpenGL attribute `attr` to `value`. The requested
 attributes should be set before creating an OpenGL window. You should use
 SDL_GL_GetAttribute() to check the values after creating the OpenGL
 context, since the values obtained can differ from the requested ones.

 threadsafety: This function should only be called on the main thread.


 @param attr : `an SDL_GLAttr enum value specifying the OpenGL attribute to
             set.`
 @param value : `the desired value for the attribute.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_set_attribute(SDLGLAttr attr, CInt value) @extern("SDL_GL_SetAttribute");

<*
 Get the actual value for an attribute from the current context.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.


 @param attr : `an SDL_GLAttr enum value specifying the OpenGL attribute to
             get.`
 @param value : `a pointer filled in with the current value of 'attr'.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_get_attribute(SDLGLAttr attr, CInt *value) @extern("SDL_GL_GetAttribute");

<*
 Create an OpenGL context for an OpenGL window, and make it current.
 This function is available since SDL 3.2.0.

 Windows users new to OpenGL should note that, for historical reasons, GL
 functions added after OpenGL version 1.1 are not available by default.
 Those functions must be loaded at run-time, either with an OpenGL
 extension-handling library or with SDL_GL_GetProcAddress() and its related
 functions.

 SDL_GLContext is opaque to the application.

 threadsafety: This function should only be called on the main thread.


 @param window : `the window to associate with the context.`
 @return `the OpenGL context associated with 'window' or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLGLContext gl_create_context(SDLWindow* window) @extern("SDL_GL_CreateContext");

<*
 Set up an OpenGL context for rendering into an OpenGL window.
 This function is available since SDL 3.2.0.

 The context must have been created with a compatible window.

 threadsafety: This function should only be called on the main thread.


 @param window : `the window to associate with the context.`
 @param context : `the OpenGL context to associate with the window.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_make_current(SDLWindow* window, SDLGLContext context) @extern("SDL_GL_MakeCurrent");

<*
 Get the currently active OpenGL window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the currently active OpenGL window on success or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLWindow* gl_get_current_window() @extern("SDL_GL_GetCurrentWindow");

<*
 Get the currently active OpenGL context.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.


 @return `the currently active OpenGL context or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGLContext gl_get_current_context() @extern("SDL_GL_GetCurrentContext");

<*
 Get the currently active EGL display.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the currently active EGL display or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLEGLDisplay egl_get_current_display() @extern("SDL_EGL_GetCurrentDisplay");

<*
 Get the currently active EGL config.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the currently active EGL config or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLEGLConfig egl_get_current_config() @extern("SDL_EGL_GetCurrentConfig");

<*
 Get the EGL surface associated with the window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `the EGLSurface pointer associated with the window, or NULL on
          failure.`
*>
extern fn SDLEGLSurface egl_get_window_surface(SDLWindow* window) @extern("SDL_EGL_GetWindowSurface");

<*
 Sets the callbacks for defining custom EGLAttrib arrays for EGL
 initialization.
 This function is available since SDL 3.2.0.

 Callbacks that aren't needed can be set to NULL.

 NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.

 threadsafety: This function should only be called on the main thread.

 @param platform_attrib_callback : `callback for attributes to pass to
                               eglGetPlatformDisplay. May be NULL.`
 @param surface_attrib_callback : `callback for attributes to pass to
                              eglCreateSurface. May be NULL.`
 @param context_attrib_callback : `callback for attributes to pass to
                              eglCreateContext. May be NULL.`
 @param userdata : `a pointer that is passed to the callbacks.`
*>
extern fn void egl_set_attribute_callbacks(SDLEGLAttribArrayCallback platform_attrib_callback, SDLEGLIntArrayCallback surface_attrib_callback, SDLEGLIntArrayCallback context_attrib_callback, void *userdata) @extern("SDL_EGL_SetAttributeCallbacks");

<*
 Set the swap interval for the current OpenGL context.
 This function is available since SDL 3.2.0.

 Some systems allow specifying -1 for the interval, to enable adaptive
 vsync. Adaptive vsync works the same as vsync, but if you've already missed
 the vertical retrace for a given frame, it swaps buffers immediately, which
 might be less jarring for the user during occasional framerate drops. If an
 application requests adaptive vsync and the system does not support it,
 this function will fail and return false. In such a case, you should
 probably retry the call with 1 for the interval.

 Adaptive vsync is implemented for some glX drivers with
 GLX_EXT_swap_control_tear, and for some Windows drivers with
 WGL_EXT_swap_control_tear.

 Read more on the Khronos wiki:
 https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync

 threadsafety: This function should only be called on the main thread.


 @param interval : `0 for immediate updates, 1 for updates synchronized with
                 the vertical retrace, -1 for adaptive vsync.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_set_swap_interval(CInt interval) @extern("SDL_GL_SetSwapInterval");

<*
 Get the swap interval for the current OpenGL context.
 This function is available since SDL 3.2.0.

 If the system can't determine the swap interval, or there isn't a valid
 current context, this function will set *interval to 0 as a safe default.

 threadsafety: This function should only be called on the main thread.


 @param interval : `output interval value. 0 if there is no vertical retrace
                 synchronization, 1 if the buffer swap is synchronized with
                 the vertical retrace, and -1 if late swaps happen
                 immediately instead of waiting for the next retrace.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_get_swap_interval(CInt* interval) @extern("SDL_GL_GetSwapInterval");

<*
 Update a window with OpenGL rendering.
 This function is available since SDL 3.2.0.

 This is used with double-buffered OpenGL contexts, which are the default.

 On macOS, make sure you bind 0 to the draw framebuffer before swapping the
 window, otherwise nothing will happen. If you aren't using
 glBindFramebuffer(), this is the default and you won't have to do anything
 extra.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_swap_window(SDLWindow* window) @extern("SDL_GL_SwapWindow");

<*
 Delete an OpenGL context.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.


 @param context : `the OpenGL context to be deleted.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool gl_destroy_context(SDLGLContext context) @extern("SDL_GL_DestroyContext");
