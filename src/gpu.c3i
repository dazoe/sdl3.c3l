<*
 The GPU API offers a cross-platform way for apps to talk to modern graphics
 hardware. It offers both 3D graphics and compute support, in the style of
 Metal, Vulkan, and Direct3D 12.

 A basic workflow might be something like this:

 The app creates a GPU device with SDL_CreateGPUDevice(), and assigns it to
 a window with SDL_ClaimWindowForGPUDevice()--although strictly speaking you
 can render offscreen entirely, perhaps for image processing, and not use a
 window at all.

 Next, the app prepares static data (things that are created once and used
 over and over). For example:

 - Shaders (programs that run on the GPU): use SDL_CreateGPUShader().
 - Vertex buffers (arrays of geometry data) and other rendering data: use
   SDL_CreateGPUBuffer() and SDL_UploadToGPUBuffer().
 - Textures (images): use SDL_CreateGPUTexture() and
   SDL_UploadToGPUTexture().
 - Samplers (how textures should be read from): use SDL_CreateGPUSampler().
 - Render pipelines (precalculated rendering state): use
   SDL_CreateGPUGraphicsPipeline()

 To render, the app creates one or more command buffers, with
 SDL_AcquireGPUCommandBuffer(). Command buffers collect rendering
 instructions that will be submitted to the GPU in batch. Complex scenes can
 use multiple command buffers, maybe configured across multiple threads in
 parallel, as long as they are submitted in the correct order, but many apps
 will just need one command buffer per frame.

 Rendering can happen to a texture (what other APIs call a "render target")
 or it can happen to the swapchain texture (which is just a special texture
 that represents a window's contents). The app can use
 SDL_WaitAndAcquireGPUSwapchainTexture() to render to the window.

 Rendering actually happens in a Render Pass, which is encoded into a
 command buffer. One can encode multiple render passes (or alternate between
 render and compute passes) in a single command buffer, but many apps might
 simply need a single render pass in a single command buffer. Render Passes
 can render to up to four color textures and one depth texture
 simultaneously. If the set of textures being rendered to needs to change,
 the Render Pass must be ended and a new one must be begun.

 The app calls SDL_BeginGPURenderPass(). Then it sets states it needs for
 each draw:

 - SDL_BindGPUGraphicsPipeline()
 - SDL_SetGPUViewport()
 - SDL_BindGPUVertexBuffers()
 - SDL_BindGPUVertexSamplers()
 - etc

 Then, make the actual draw commands with these states:

 - SDL_DrawGPUPrimitives()
 - SDL_DrawGPUPrimitivesIndirect()
 - SDL_DrawGPUIndexedPrimitivesIndirect()
 - etc

 After all the drawing commands for a pass are complete, the app should call
 SDL_EndGPURenderPass(). Once a render pass ends all render-related state is
 reset.

 The app can begin new Render Passes and make new draws in the same command
 buffer until the entire scene is rendered.

 Once all of the render commands for the scene are complete, the app calls
 SDL_SubmitGPUCommandBuffer() to send it to the GPU for processing.

 If the app needs to read back data from texture or buffers, the API has an
 efficient way of doing this, provided that the app is willing to tolerate
 some latency. When the app uses SDL_DownloadFromGPUTexture() or
 SDL_DownloadFromGPUBuffer(), submitting the command buffer with
 SDL_SubmitGPUCommandBufferAndAcquireFence() will return a fence handle that
 the app can poll or wait on in a thread. Once the fence indicates that the
 command buffer is done processing, it is safe to read the downloaded data.
 Make sure to call SDL_ReleaseGPUFence() when done with the fence.

 The API also has "compute" support. The app calls SDL_BeginGPUComputePass()
 with compute-writeable textures and/or buffers, which can be written to in
 a compute shader. Then it sets states it needs for the compute dispatches:

 - SDL_BindGPUComputePipeline()
 - SDL_BindGPUComputeStorageBuffers()
 - SDL_BindGPUComputeStorageTextures()

 Then, dispatch compute work:

 - SDL_DispatchGPUCompute()

 For advanced users, this opens up powerful GPU-driven workflows.

 Graphics and compute pipelines require the use of shaders, which as
 mentioned above are small programs executed on the GPU. Each backend
 (Vulkan, Metal, D3D12) requires a different shader format. When the app
 creates the GPU device, the app lets the device know which shader formats
 the app can provide. It will then select the appropriate backend depending
 on the available shader formats and the backends available on the platform.
 When creating shaders, the app must provide the correct shader format for
 the selected backend. If you would like to learn more about why the API
 works this way, there is a detailed
 [blog post](https://moonside.games/posts/layers-all-the-way-down/)
 explaining this situation.

 It is optimal for apps to pre-compile the shader formats they might use,
 but for ease of use SDL provides a separate project,
 [SDL_shadercross](https://github.com/libsdl-org/SDL_shadercross)
 , for performing runtime shader cross-compilation. It also has a CLI
 interface for offline precompilation as well.

 This is an extremely quick overview that leaves out several important
 details. Already, though, one can see that GPU programming can be quite
 complex! If you just need simple 2D graphics, the
 [Render API](https://wiki.libsdl.org/SDL3/CategoryRender)
 is much easier to use but still hardware-accelerated. That said, even for
 2D applications the performance benefits and expressiveness of the GPU API
 are significant.

 The GPU API targets a feature set with a wide range of hardware support and
 ease of portability. It is designed so that the app won't have to branch
 itself by querying feature support. If you need cutting-edge features with
 limited hardware support, this API is probably not for you.

 Examples demonstrating proper usage of this API can be found
 [here](https://github.com/TheSpydog/SDL_gpu_examples)
 .

 ## Performance considerations

 Here are some basic tips for maximizing your rendering performance.

 - Beginning a new render pass is relatively expensive. Use as few render
   passes as you can.
 - Minimize the amount of state changes. For example, binding a pipeline is
   relatively cheap, but doing it hundreds of times when you don't need to
   will slow the performance significantly.
 - Perform your data uploads as early as possible in the frame.
 - Don't churn resources. Creating and releasing resources is expensive.
   It's better to create what you need up front and cache it.
 - Don't use uniform buffers for large amounts of data (more than a matrix
   or so). Use a storage buffer instead.
 - Use cycling correctly. There is a detailed explanation of cycling further
   below.
 - Use culling techniques to minimize pixel writes. The less writing the GPU
   has to do the better. Culling can be a very advanced topic but even
   simple culling techniques can boost performance significantly.

 In general try to remember the golden rule of performance: doing things is
 more expensive than not doing things. Don't Touch The Driver!

 ## FAQ

 **Question: When are you adding more advanced features, like ray tracing or
 mesh shaders?**

 Answer: We don't have immediate plans to add more bleeding-edge features,
 but we certainly might in the future, when these features prove worthwhile,
 and reasonable to implement across several platforms and underlying APIs.
 So while these things are not in the "never" category, they are definitely
 not "near future" items either.

 **Question: Why is my shader not working?**

 Answer: A common oversight when using shaders is not properly laying out
 the shader resources/registers correctly. The GPU API is very strict with
 how it wants resources to be laid out and it's difficult for the API to
 automatically validate shaders to see if they have a compatible layout. See
 the documentation for SDL_CreateGPUShader() and
 SDL_CreateGPUComputePipeline() for information on the expected layout.

 Another common issue is not setting the correct number of samplers,
 textures, and buffers in SDL_GPUShaderCreateInfo. If possible use shader
 reflection to extract the required information from the shader
 automatically instead of manually filling in the struct's values.

 **Question: My application isn't performing very well. Is this the GPU
 API's fault?**

 Answer: No. Long answer: The GPU API is a relatively thin layer over the
 underlying graphics API. While it's possible that we have done something
 inefficiently, it's very unlikely especially if you are relatively
 inexperienced with GPU rendering. Please see the performance tips above and
 make sure you are following them. Additionally, tools like RenderDoc can be
 very helpful for diagnosing incorrect behavior and performance issues.

 ## System Requirements

 **Vulkan:** Supported on Windows, Linux, Nintendo Switch, and certain
 Android devices. Requires Vulkan 1.0 with the following extensions and
 device features:

 - `VK_KHR_swapchain`
 - `VK_KHR_maintenance1`
 - `independentBlend`
 - `imageCubeArray`
 - `depthClamp`
 - `shaderClipDistance`
 - `drawIndirectFirstInstance`

 **D3D12:** Supported on Windows 10 or newer, Xbox One (GDK), and Xbox
 Series X|S (GDK). Requires a GPU that supports DirectX 12 Feature Level 11_0 and
 Resource Binding Tier 2 or above.

 **Metal:** Supported on macOS 10.14+ and iOS/tvOS 13.0+. Hardware
 requirements vary by operating system:

 - macOS requires an Apple Silicon or
   [Intel Mac2 family](https://developer.apple.com/documentation/metal/mtlfeatureset/mtlfeatureset_macos_gpufamily2_v1?language=objc)
   GPU
 - iOS/tvOS requires an A9 GPU or newer
 - iOS Simulator and tvOS Simulator are unsupported

 ## Uniform Data

 Uniforms are for passing data to shaders. The uniform data will be constant
 across all executions of the shader.

 There are 4 available uniform slots per shader stage (where the stages are
 vertex, fragment, and compute). Uniform data pushed to a slot on a stage
 keeps its value throughout the command buffer until you call the relevant
 Push function on that slot again.

 For example, you could write your vertex shaders to read a camera matrix
 from uniform binding slot 0, push the camera matrix at the start of the
 command buffer, and that data will be used for every subsequent draw call.

 It is valid to push uniform data during a render or compute pass.

 Uniforms are best for pushing small amounts of data. If you are pushing
 more than a matrix or two per call you should consider using a storage
 buffer instead.

 ## A Note On Cycling

 When using a command buffer, operations do not occur immediately - they
 occur some time after the command buffer is submitted.

 When a resource is used in a pending or active command buffer, it is
 considered to be "bound". When a resource is no longer used in any pending
 or active command buffers, it is considered to be "unbound".

 If data resources are bound, it is unspecified when that data will be
 unbound unless you acquire a fence when submitting the command buffer and
 wait on it. However, this doesn't mean you need to track resource usage
 manually.

 All of the functions and structs that involve writing to a resource have a
 "cycle" bool. SDL_GPUTransferBuffer, SDL_GPUBuffer, and SDL_GPUTexture all
 effectively function as ring buffers on internal resources. When cycle is
 true, if the resource is bound, the cycle rotates to the next unbound
 internal resource, or if none are available, a new one is created. This
 means you don't have to worry about complex state tracking and
 synchronization as long as cycling is correctly employed.

 For example: you can call SDL_MapGPUTransferBuffer(), write texture data,
 SDL_UnmapGPUTransferBuffer(), and then SDL_UploadToGPUTexture(). The next
 time you write texture data to the transfer buffer, if you set the cycle
 param to true, you don't have to worry about overwriting any data that is
 not yet uploaded.

 Another example: If you are using a texture in a render pass every frame,
 this can cause a data dependency between frames. If you set cycle to true
 in the SDL_GPUColorTargetInfo struct, you can prevent this data dependency.

 Cycling will never undefine already bound data. When cycling, all data in
 the resource is considered to be undefined for subsequent commands until
 that data is written again. You must take care not to read undefined data.

 Note that when cycling a texture, the entire texture will be cycled, even
 if only part of the texture is used in the call, so you must consider the
 entire texture to contain undefined data after cycling.

 You must also take care not to overwrite a section of data that has been
 referenced in a command without cycling first. It is OK to overwrite
 unreferenced data in a bound resource without cycling, but overwriting a
 section of data that has already been referenced will produce unexpected
 results.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryGPU
*>
module sdl;

/* Type Declarations */

<*
 An opaque handle representing the SDL_GPU context.
 This struct is available since SDL 3.2.0.
*>
typedef SDLGPUDevice = void;

<*
 An opaque handle representing a buffer.
 This struct is available since SDL 3.2.0.

 Used for vertices, indices, indirect draw commands, and general compute
 data.
*>
typedef SDLGPUBuffer = void;

<*
 An opaque handle representing a transfer buffer.
 This struct is available since SDL 3.2.0.

 Used for transferring data to and from the device.
*>
typedef SDLGPUTransferBuffer = void;

<*
 An opaque handle representing a texture.
 This struct is available since SDL 3.2.0.
*>
typedef SDLGPUTexture = void;

<*
 An opaque handle representing a sampler.
 This struct is available since SDL 3.2.0.
*>
typedef SDLGPUSampler = void;

<*
 An opaque handle representing a compiled shader object.
 This struct is available since SDL 3.2.0.
*>
typedef SDLGPUShader = void;

<*
 An opaque handle representing a compute pipeline.
 This struct is available since SDL 3.2.0.

 Used during compute passes.
*>
typedef SDLGPUComputePipeline = void;

<*
 An opaque handle representing a graphics pipeline.
 This struct is available since SDL 3.2.0.

 Used during render passes.
*>
typedef SDLGPUGraphicsPipeline = void;

<*
 An opaque handle representing a command buffer.
 This struct is available since SDL 3.2.0.

 Most state is managed via command buffers. When setting state using a
 command buffer, that state is local to the command buffer.

 Commands only begin execution on the GPU once SDL_SubmitGPUCommandBuffer is
 called. Once the command buffer is submitted, it is no longer valid to use
 it.

 Command buffers are executed in submission order. If you submit command
 buffer A and then command buffer B all commands in A will begin executing
 before any command in B begins executing.

 In multi-threading scenarios, you should only access a command buffer on
 the thread you acquired it from.
*>
typedef SDLGPUCommandBuffer = void;

<*
 An opaque handle representing a render pass.
 This struct is available since SDL 3.2.0.

 This handle is transient and should not be held or referenced after
 SDL_EndGPURenderPass is called.
*>
typedef SDLGPURenderPass = void;

<*
 An opaque handle representing a compute pass.
 This struct is available since SDL 3.2.0.

 This handle is transient and should not be held or referenced after
 SDL_EndGPUComputePass is called.
*>
typedef SDLGPUComputePass = void;

<*
 An opaque handle representing a copy pass.
 This struct is available since SDL 3.2.0.

 This handle is transient and should not be held or referenced after
 SDL_EndGPUCopyPass is called.
*>
typedef SDLGPUCopyPass = void;

<*
 An opaque handle representing a fence.
 This struct is available since SDL 3.2.0.
*>
typedef SDLGPUFence = void;

<*
 Specifies the primitive topology of a graphics pipeline.
 This enum is available since SDL 3.2.0.

 If you are using POINTLIST you must include a point size output in the
 vertex shader.

 - For HLSL compiling to SPIRV you must decorate a float output with
   [[vk::builtin("PointSize")]].
 - For GLSL you must set the gl_PointSize builtin.
 - For MSL you must include a float output with the [[point_size]]
   decorator.

 Note that sized point topology is totally unsupported on D3D12. Any size
 other than 1 will be ignored. In general, you should avoid using point
 topology for both compatibility and performance reasons. You WILL regret
 using it.
*>
enum SDLGPUPrimitiveType : const CInt
{
    TRIANGLELIST,  /**< A series of separate triangles. */
    TRIANGLESTRIP, /**< A series of connected triangles. */
    LINELIST,      /**< A series of separate lines. */
    LINESTRIP,     /**< A series of connected lines. */
    POINTLIST,     /**< A series of separate points. */
}

<*
 Specifies how the contents of a texture attached to a render pass are
 treated at the beginning of the render pass.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPULoadOp : const CInt
{
    LOAD,      /**< The previous contents of the texture will be preserved. */
    CLEAR,     /**< The contents of the texture will be cleared to a color. */
    DONT_CARE, /**< The previous contents of the texture need not be preserved. The contents will be undefined. */
}

<*
 Specifies how the contents of a texture attached to a render pass are
 treated at the end of the render pass.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUStoreOp : const CInt
{
    STORE,             /**< The contents generated during the render pass will be written to memory. */
    DONT_CARE,         /**< The contents generated during the render pass are not needed and may be discarded. The contents will be undefined. */
    RESOLVE,           /**< The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture may then be discarded and will be undefined. */
    RESOLVE_AND_STORE, /**< The multisample contents generated during the render pass will be resolved to a non-multisample texture. The contents in the multisample texture will be written to memory. */
}

<*
 Specifies the size of elements in an index buffer.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUIndexElementSize : const CInt
{
    SIZE_16BIT, /**< The index elements are 16-bit. */
    SIZE_32BIT, /**< The index elements are 32-bit. */
}

<*
 Specifies the pixel format of a texture.
 This enum is available since SDL 3.2.0.

 Texture format support varies depending on driver, hardware, and usage
 flags. In general, you should use SDL_GPUTextureSupportsFormat to query if
 a format is supported before using it. However, there are a few guaranteed
 formats.

 FIXME: Check universal support for 32-bit component formats FIXME: Check
 universal support for SIMULTANEOUS_READ_WRITE

 For SAMPLER usage, the following formats are universally supported:

 - R8G8B8A8_UNORM
 - B8G8R8A8_UNORM
 - R8_UNORM
 - R8_SNORM
 - R8G8_UNORM
 - R8G8_SNORM
 - R8G8B8A8_SNORM
 - R16_FLOAT
 - R16G16_FLOAT
 - R16G16B16A16_FLOAT
 - R32_FLOAT
 - R32G32_FLOAT
 - R32G32B32A32_FLOAT
 - R11G11B10_UFLOAT
 - R8G8B8A8_UNORM_SRGB
 - B8G8R8A8_UNORM_SRGB
 - D16_UNORM

 For COLOR_TARGET usage, the following formats are universally supported:

 - R8G8B8A8_UNORM
 - B8G8R8A8_UNORM
 - R8_UNORM
 - R16_FLOAT
 - R16G16_FLOAT
 - R16G16B16A16_FLOAT
 - R32_FLOAT
 - R32G32_FLOAT
 - R32G32B32A32_FLOAT
 - R8_UINT
 - R8G8_UINT
 - R8G8B8A8_UINT
 - R16_UINT
 - R16G16_UINT
 - R16G16B16A16_UINT
 - R8_INT
 - R8G8_INT
 - R8G8B8A8_INT
 - R16_INT
 - R16G16_INT
 - R16G16B16A16_INT
 - R8G8B8A8_UNORM_SRGB
 - B8G8R8A8_UNORM_SRGB

 For STORAGE usages, the following formats are universally supported:

 - R8G8B8A8_UNORM
 - R8G8B8A8_SNORM
 - R16G16B16A16_FLOAT
 - R32_FLOAT
 - R32G32_FLOAT
 - R32G32B32A32_FLOAT
 - R8G8B8A8_UINT
 - R16G16B16A16_UINT
 - R8G8B8A8_INT
 - R16G16B16A16_INT

 For DEPTH_STENCIL_TARGET usage, the following formats are universally
 supported:

 - D16_UNORM
 - Either (but not necessarily both!) D24_UNORM or D32_FLOAT
 - Either (but not necessarily both!) D24_UNORM_S8_UINT or D32_FLOAT_S8_UINT

 Unless D16_UNORM is sufficient for your purposes, always check which of
 D24/D32 is supported before creating a depth-stencil texture!
*>
enum SDLGPUTextureFormat : const CInt
{
    INVALID,

    /* Unsigned Normalized Float Color Formats */
    A8_UNORM,
    R8_UNORM,
    R8G8_UNORM,
    R8G8B8A8_UNORM,
    R16_UNORM,
    R16G16_UNORM,
    R16G16B16A16_UNORM,
    R10G10B10A2_UNORM,
    B5G6R5_UNORM,
    B5G5R5A1_UNORM,
    B4G4R4A4_UNORM,
    B8G8R8A8_UNORM,
    /* Compressed Unsigned Normalized Float Color Formats */
    BC1_RGBA_UNORM,
    BC2_RGBA_UNORM,
    BC3_RGBA_UNORM,
    BC4_R_UNORM,
    BC5_RG_UNORM,
    BC7_RGBA_UNORM,
    /* Compressed Signed Float Color Formats */
    BC6H_RGB_FLOAT,
    /* Compressed Unsigned Float Color Formats */
    BC6H_RGB_UFLOAT,
    /* Signed Normalized Float Color Formats  */
    R8_SNORM,
    R8G8_SNORM,
    R8G8B8A8_SNORM,
    R16_SNORM,
    R16G16_SNORM,
    R16G16B16A16_SNORM,
    /* Signed Float Color Formats */
    R16_FLOAT,
    R16G16_FLOAT,
    R16G16B16A16_FLOAT,
    R32_FLOAT,
    R32G32_FLOAT,
    R32G32B32A32_FLOAT,
    /* Unsigned Float Color Formats */
    R11G11B10_UFLOAT,
    /* Unsigned Integer Color Formats */
    R8_UINT,
    R8G8_UINT,
    R8G8B8A8_UINT,
    R16_UINT,
    R16G16_UINT,
    R16G16B16A16_UINT,
    R32_UINT,
    R32G32_UINT,
    R32G32B32A32_UINT,
    /* Signed Integer Color Formats */
    R8_INT,
    R8G8_INT,
    R8G8B8A8_INT,
    R16_INT,
    R16G16_INT,
    R16G16B16A16_INT,
    R32_INT,
    R32G32_INT,
    R32G32B32A32_INT,
    /* SRGB Unsigned Normalized Color Formats */
    R8G8B8A8_UNORM_SRGB,
    B8G8R8A8_UNORM_SRGB,
    /* Compressed SRGB Unsigned Normalized Color Formats */
    BC1_RGBA_UNORM_SRGB,
    BC2_RGBA_UNORM_SRGB,
    BC3_RGBA_UNORM_SRGB,
    BC7_RGBA_UNORM_SRGB,
    /* Depth Formats */
    D16_UNORM,
    D24_UNORM,
    D32_FLOAT,
    D24_UNORM_S8_UINT,
    D32_FLOAT_S8_UINT,
    /* Compressed ASTC Normalized Float Color Formats*/
    ASTC_4X4_UNORM,
    ASTC_5X4_UNORM,
    ASTC_5X5_UNORM,
    ASTC_6X5_UNORM,
    ASTC_6X6_UNORM,
    ASTC_8X5_UNORM,
    ASTC_8X6_UNORM,
    ASTC_8X8_UNORM,
    ASTC_10X5_UNORM,
    ASTC_10X6_UNORM,
    ASTC_10X8_UNORM,
    ASTC_10X10_UNORM,
    ASTC_12X10_UNORM,
    ASTC_12X12_UNORM,
    /* Compressed SRGB ASTC Normalized Float Color Formats*/
    ASTC_4X4_UNORM_SRGB,
    ASTC_5X4_UNORM_SRGB,
    ASTC_5X5_UNORM_SRGB,
    ASTC_6X5_UNORM_SRGB,
    ASTC_6X6_UNORM_SRGB,
    ASTC_8X5_UNORM_SRGB,
    ASTC_8X6_UNORM_SRGB,
    ASTC_8X8_UNORM_SRGB,
    ASTC_10X5_UNORM_SRGB,
    ASTC_10X6_UNORM_SRGB,
    ASTC_10X8_UNORM_SRGB,
    ASTC_10X10_UNORM_SRGB,
    ASTC_12X10_UNORM_SRGB,
    ASTC_12X12_UNORM_SRGB,
    /* Compressed ASTC Signed Float Color Formats*/
    ASTC_4X4_FLOAT,
    ASTC_5X4_FLOAT,
    ASTC_5X5_FLOAT,
    ASTC_6X5_FLOAT,
    ASTC_6X6_FLOAT,
    ASTC_8X5_FLOAT,
    ASTC_8X6_FLOAT,
    ASTC_8X8_FLOAT,
    ASTC_10X5_FLOAT,
    ASTC_10X6_FLOAT,
    ASTC_10X8_FLOAT,
    ASTC_10X10_FLOAT,
    ASTC_12X10_FLOAT,
    ASTC_12X12_FLOAT,
}

<*
 Specifies how a texture is intended to be used by the client.
 This datatype is available since SDL 3.2.0.

 A texture must have at least one usage flag. Note that some usage flag
 combinations are invalid.

 With regards to compute storage usage, READ | WRITE means that you can have
 shader A that only writes into the texture and shader B that only reads
 from the texture and bind the same texture to either shader respectively.
 SIMULTANEOUS means that you can do reads and writes within the same shader
 or compute pass. It also implies that atomic ops can be used, since those
 are read-modify-write operations. If you use SIMULTANEOUS, you are
 responsible for avoiding data races, as there is no data synchronization
 within a compute pass. Note that SIMULTANEOUS usage is only supported by a
 limited number of texture formats.
*>
bitstruct SDLGPUTextureUsageFlags : uint {
	bool sampler                                  : 0; /**< Texture supports sampling. */
	bool color_target                             : 1; /**< Texture is a color render target. */
	bool depth_stencil_target                     : 2; /**< Texture is a depth stencil target. */
	bool graphics_storage_read                    : 3; /**< Texture supports storage reads in graphics stages. */
	bool compute_storage_read                     : 4; /**< Texture supports storage reads in the compute stage. */
	bool compute_storage_write                    : 5; /**< Texture supports storage writes in the compute stage. */
	bool compute_storage_simultaneous_read_write  : 6; /**< Texture supports reads and writes in the same compute shader. This is NOT equivalent to READ | WRITE. */
}

<*
 Specifies the type of a texture.

 This enum is available since SDL 3.2.0.
*>
enum SDLGPUTextureType : const CInt
{
    TYPE_2D,         /**< The texture is a 2-dimensional image. */
    TYPE_2D_ARRAY,   /**< The texture is a 2-dimensional array image. */
    TYPE_3D,         /**< The texture is a 3-dimensional image. */
    TYPE_CUBE,       /**< The texture is a cube image. */
    TYPE_CUBE_ARRAY, /**< The texture is a cube array image. */
}

<*
 Specifies the sample count of a texture.
 This enum is available since SDL 3.2.0.

 Used in multisampling. Note that this value only applies when the texture
 is used as a render target.
*>
enum SDLGPUSampleCount : const CInt
{
    COUNT_1,  /**< No multisampling. */
    COUNT_2,  /**< MSAA 2x */
    COUNT_4,  /**< MSAA 4x */
    COUNT_8,  /**< MSAA 8x */
}


<*
 Specifies the face of a cube map.
 This enum is available since SDL 3.2.0.

 Can be passed in as the layer field in texture-related structs.
*>
enum SDLGPUCubeMapFace : const CInt
{
    POSITIVEX,
    NEGATIVEX,
    POSITIVEY,
    NEGATIVEY,
    POSITIVEZ,
    NEGATIVEZ,
}

<*
 Specifies how a buffer is intended to be used by the client.
 This datatype is available since SDL 3.2.0.

 A buffer must have at least one usage flag. Note that some usage flag
 combinations are invalid.

 Unlike textures, READ | WRITE can be used for simultaneous read-write
 usage. The same data synchronization concerns as textures apply.

 If you use a STORAGE flag, the data in the buffer must respect std140
 layout conventions. In practical terms this means you must ensure that vec3
 and vec4 fields are 16-byte aligned.
*>
bitstruct SDLGPUBufferUsageFlags : uint {
	bool vertex                : 0; /**< Buffer is a vertex buffer. */
	bool index                 : 1; /**< Buffer is an index buffer. */
	bool indirect              : 2; /**< Buffer is an indirect buffer. */
	bool graphics_storage_read : 3; /**< Buffer supports storage reads in graphics stages. */
	bool compute_storage_read  : 4; /**< Buffer supports storage reads in the compute stage. */
	bool compute_storage_write : 5; /**< Buffer supports storage writes in the compute stage. */
}

<*
 Specifies how a transfer buffer is intended to be used by the client.
 This enum is available since SDL 3.2.0.

 Note that mapping and copying FROM an upload transfer buffer or TO a
 download transfer buffer is undefined behavior.
*>
enum SDLGPUTransferBufferUsage : const CInt
{
    UPLOAD,
    DOWNLOAD,
}

<*
 Specifies which stage a shader program corresponds to.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUShaderStage : const CInt
{
    VERTEX,
    FRAGMENT,
}

<*
 Specifies the format of shader code.
 This datatype is available since SDL 3.2.0.

 Each format corresponds to a specific backend that accepts it.
*>
bitstruct SDLGPUShaderFormat : uint {
	// bool invalid = 0;
	bool private   : 0; /**< Shaders for NDA'd platforms. */
	bool spirv     : 1; /**< SPIR-V shaders for Vulkan. */
	bool dxbc      : 2; /**< DXBC SM5_1 shaders for D3D12. */
	bool dxil      : 3; /**< DXIL SM6_0 shaders for D3D12. */
	bool msl       : 4; /**< MSL shaders for Metal. */
	bool metallib  : 5; /**< Precompiled metallib shaders for Metal. */
}

<*
 Specifies the format of a vertex attribute.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUVertexElementFormat : const CInt
{
    INVALID,

    /* 32-bit Signed Integers */
    INT,
    INT2,
    INT3,
    INT4,

    /* 32-bit Unsigned Integers */
    UINT,
    UINT2,
    UINT3,
    UINT4,

    /* 32-bit Floats */
    FLOAT,
    FLOAT2,
    FLOAT3,
    FLOAT4,

    /* 8-bit Signed Integers */
    BYTE2,
    BYTE4,

    /* 8-bit Unsigned Integers */
    UBYTE2,
    UBYTE4,

    /* 8-bit Signed Normalized */
    BYTE2_NORM,
    BYTE4_NORM,

    /* 8-bit Unsigned Normalized */
    UBYTE2_NORM,
    UBYTE4_NORM,

    /* 16-bit Signed Integers */
    SHORT2,
    SHORT4,

    /* 16-bit Unsigned Integers */
    USHORT2,
    USHORT4,

    /* 16-bit Signed Normalized */
    SHORT2_NORM,
    SHORT4_NORM,

    /* 16-bit Unsigned Normalized */
    USHORT2_NORM,
    USHORT4_NORM,

    /* 16-bit Floats */
    HALF2,
    HALF4,
}

<*
 Specifies the rate at which vertex attributes are pulled from buffers.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUVertexInputRate : const CInt
{
    VERTEX,   /**< Attribute addressing is a function of the vertex index. */
    INSTANCE, /**< Attribute addressing is a function of the instance index. */
}

<*
 Specifies the fill mode of the graphics pipeline.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUFillMode : const CInt
{
    FILL,  /**< Polygons will be rendered via rasterization. */
    LINE,  /**< Polygon edges will be drawn as line segments. */
}

<*
 Specifies the facing direction in which triangle faces will be culled.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUCullMode : const CInt
{
    NONE,   /**< No triangles are culled. */
    FRONT,  /**< Front-facing triangles are culled. */
    BACK,   /**< Back-facing triangles are culled. */
}

<*
 Specifies the vertex winding that will cause a triangle to be determined to
 be front-facing.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUFrontFace : const CInt
{
    COUNTER_CLOCKWISE,  /**< A triangle with counter-clockwise vertex winding will be considered front-facing. */
    CLOCKWISE,          /**< A triangle with clockwise vertex winding will be considered front-facing. */
}

<*
 Specifies a comparison operator for depth, stencil and sampler operations.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUCompareOp : const CInt
{
    INVALID,
    NEVER,             /**< The comparison always evaluates false. */
    LESS,              /**< The comparison evaluates reference < test. */
    EQUAL,             /**< The comparison evaluates reference == test. */
    LESS_OR_EQUAL,     /**< The comparison evaluates reference <= test. */
    GREATER,           /**< The comparison evaluates reference > test. */
    NOT_EQUAL,         /**< The comparison evaluates reference != test. */
    GREATER_OR_EQUAL,  /**< The comparison evaluates reference >= test. */
    ALWAYS,            /**< The comparison always evaluates true. */
}

<*
 Specifies what happens to a stored stencil value if stencil tests fail or
 pass.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUStencilOp : const CInt
{
    INVALID,
    KEEP,                 /**< Keeps the current value. */
    ZERO,                 /**< Sets the value to 0. */
    REPLACE,              /**< Sets the value to reference. */
    INCREMENT_AND_CLAMP,  /**< Increments the current value and clamps to the maximum value. */
    DECREMENT_AND_CLAMP,  /**< Decrements the current value and clamps to 0. */
    INVERT,               /**< Bitwise-inverts the current value. */
    INCREMENT_AND_WRAP,   /**< Increments the current value and wraps back to 0. */
    DECREMENT_AND_WRAP,   /**< Decrements the current value and wraps to the maximum value. */
}

<*
 Specifies the operator to be used when pixels in a render target are
 blended with existing pixels in the texture.
 This enum is available since SDL 3.2.0.

 The source color is the value written by the fragment shader. The
 destination color is the value currently existing in the texture.
*>
enum SDLGPUBlendOp : const CInt
{
    INVALID,
    ADD,               /**< (source * source_factor) + (destination * destination_factor) */
    SUBTRACT,          /**< (source * source_factor) - (destination * destination_factor) */
    REVERSE_SUBTRACT,  /**< (destination * destination_factor) - (source * source_factor) */
    MIN,               /**< min(source, destination) */
    MAX,               /**< max(source, destination) */
}

<*
 Specifies a blending factor to be used when pixels in a render target are
 blended with existing pixels in the texture.
 This enum is available since SDL 3.2.0.

 The source color is the value written by the fragment shader. The
 destination color is the value currently existing in the texture.
*>
enum SDLGPUBlendFactor : const CInt
{
    INVALID,
    ZERO,                      /**< 0 */
    ONE,                       /**< 1 */
    SRC_COLOR,                 /**< source color */
    ONE_MINUS_SRC_COLOR,       /**< 1 - source color */
    DST_COLOR,                 /**< destination color */
    ONE_MINUS_DST_COLOR,       /**< 1 - destination color */
    SRC_ALPHA,                 /**< source alpha */
    ONE_MINUS_SRC_ALPHA,       /**< 1 - source alpha */
    DST_ALPHA,                 /**< destination alpha */
    ONE_MINUS_DST_ALPHA,       /**< 1 - destination alpha */
    CONSTANT_COLOR,            /**< blend constant */
    ONE_MINUS_CONSTANT_COLOR,  /**< 1 - blend constant */
    SRC_ALPHA_SATURATE,        /**< min(source alpha, 1 - destination alpha) */
}

<*
 Specifies which color components are written in a graphics pipeline.
 This datatype is available since SDL 3.2.0.
*>
bitstruct SDLGPUColorComponentFlags : char {
	bool r : 0; /**< the red component */
	bool g : 1; /**< the green component */
	bool b : 2; /**< the blue component */
	bool a : 3; /**< the alpha component */
}

<*
 Specifies a filter operation used by a sampler.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUFilter : const CInt
{
    NEAREST,  /**< Point filtering. */
    LINEAR,    /**< Linear filtering. */
}

<*
 Specifies a mipmap mode used by a sampler.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUSamplerMipmapMode : const CInt
{
    NEAREST,  /**< Point filtering. */
    LINEAR,   /**< Linear filtering. */
}

<*
 Specifies behavior of texture sampling when the coordinates exceed the 0-1
 range.
 This enum is available since SDL 3.2.0.
*>
enum SDLGPUSamplerAddressMode : const CInt
{
    REPEAT,           /**< Specifies that the coordinates will wrap around. */
    MIRRORED_REPEAT,  /**< Specifies that the coordinates will wrap around mirrored. */
    CLAMP_TO_EDGE,    /**< Specifies that the coordinates will clamp to the 0-1 range. */
}

<*
 Specifies the timing that will be used to present swapchain textures to the
 OS.
 This enum is available since SDL 3.2.0.

 VSYNC mode will always be supported. IMMEDIATE and MAILBOX modes may not be
 supported on certain systems.

 It is recommended to query SDL_WindowSupportsGPUPresentMode after claiming
 the window if you wish to change the present mode to IMMEDIATE or MAILBOX.

 - VSYNC: Waits for vblank before presenting. No tearing is possible. If
   there is a pending image to present, the new image is enqueued for
   presentation. Disallows tearing at the cost of visual latency.
 - IMMEDIATE: Immediately presents. Lowest latency option, but tearing may
   occur.
 - MAILBOX: Waits for vblank before presenting. No tearing is possible. If
   there is a pending image to present, the pending image is replaced by the
   new image. Similar to VSYNC, but with reduced visual latency.
*>
enum SDLGPUPresentMode : const CInt
{
    VSYNC,
    IMMEDIATE,
    MAILBOX,
}

<*
 Specifies the texture format and colorspace of the swapchain textures.
 This enum is available since SDL 3.2.0.

 SDR will always be supported. Other compositions may not be supported on
 certain systems.

 It is recommended to query SDL_WindowSupportsGPUSwapchainComposition after
 claiming the window if you wish to change the swapchain composition from
 SDR.

 - SDR: B8G8R8A8 or R8G8B8A8 swapchain. Pixel values are in sRGB encoding.
 - SDR_LINEAR: B8G8R8A8_SRGB or R8G8B8A8_SRGB swapchain. Pixel values are
   stored in memory in sRGB encoding but accessed in shaders in "linear
   sRGB" encoding which is sRGB but with a linear transfer function.
 - HDR_EXTENDED_LINEAR: R16G16B16A16_FLOAT swapchain. Pixel values are in
   extended linear sRGB encoding and permits values outside of the [0, 1]
   range.
 - HDR10_ST2084: A2R10G10B10 or A2B10G10R10 swapchain. Pixel values are in
   BT.2020 ST2084 (PQ) encoding.
*>
enum SDLGPUSwapchainComposition : const CInt
{
    SDR,
    SDR_LINEAR,
    HDR_EXTENDED_LINEAR,
    HDR10_ST2084,
}

/* Structures */

<*
 A structure specifying a viewport.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUViewport
{
    float x;          /**< The left offset of the viewport. */
    float y;          /**< The top offset of the viewport. */
    float w;          /**< The width of the viewport. */
    float h;          /**< The height of the viewport. */
    float min_depth;  /**< The minimum depth of the viewport. */
    float max_depth;  /**< The maximum depth of the viewport. */
}

<*
 A structure specifying parameters related to transferring data to or from a
 texture.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUTextureTransferInfo
{
    SDLGPUTransferBuffer* transfer_buffer;  /**< The transfer buffer used in the transfer operation. */
    uint offset;                            /**< The starting byte of the image data in the transfer buffer. */
    uint pixels_per_row;                    /**< The number of pixels from one row to the next. */
    uint rows_per_layer;                    /**< The number of rows from one layer/depth-slice to the next. */
}

<*
 A structure specifying a location in a transfer buffer.
 This struct is available since SDL 3.2.0.

 Used when transferring buffer data to or from a transfer buffer.
*>
struct SDLGPUTransferBufferLocation
{
    SDLGPUTransferBuffer* transfer_buffer;  /**< The transfer buffer used in the transfer operation. */
    uint offset;                            /**< The starting byte of the buffer data in the transfer buffer. */
}

<*
 A structure specifying a location in a texture.
 This struct is available since SDL 3.2.0.

 Used when copying data from one texture to another.
*>
struct SDLGPUTextureLocation
{
    SDLGPUTexture* texture;  /**< The texture used in the copy operation. */
    uint mip_level;          /**< The mip level index of the location. */
    uint layer;              /**< The layer index of the location. */
    uint x;                  /**< The left offset of the location. */
    uint y;                  /**< The top offset of the location. */
    uint z;                  /**< The front offset of the location. */
}

<*
 A structure specifying a region of a texture.
 This struct is available since SDL 3.2.0.

 Used when transferring data to or from a texture.
*>
struct SDLGPUTextureRegion
{
    SDLGPUTexture* texture;  /**< The texture used in the copy operation. */
    uint mip_level;          /**< The mip level index to transfer. */
    uint layer;              /**< The layer index to transfer. */
    uint x;                  /**< The left offset of the region. */
    uint y;                  /**< The top offset of the region. */
    uint z;                  /**< The front offset of the region. */
    uint w;                  /**< The width of the region. */
    uint h;                  /**< The height of the region. */
    uint d;                  /**< The depth of the region. */
}

<*
 A structure specifying a region of a texture used in the blit operation.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUBlitRegion
{
    SDLGPUTexture* texture;     /**< The texture. */
    uint mip_level;             /**< The mip level index of the region. */
    uint layer_or_depth_plane;  /**< The layer index or depth plane of the region. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. */
    uint x;                     /**< The left offset of the region. */
    uint y;                     /**< The top offset of the region.  */
    uint w;                     /**< The width of the region. */
    uint h;                     /**< The height of the region. */
}

<*
 A structure specifying a location in a buffer.
 This struct is available since SDL 3.2.0.

 Used when copying data between buffers.
*>
struct SDLGPUBufferLocation
{
    SDLGPUBuffer* buffer;  /**< The buffer. */
    uint offset;           /**< The starting byte within the buffer. */
}

<*
 A structure specifying a region of a buffer.
 This struct is available since SDL 3.2.0.

 Used when transferring data to or from buffers.
*>
struct SDLGPUBufferRegion
{
    SDLGPUBuffer* buffer;  /**< The buffer. */
    uint offset;           /**< The starting byte within the buffer. */
    uint size;             /**< The size in bytes of the region. */
}

<*
 A structure specifying the parameters of an indirect draw command.
 This struct is available since SDL 3.2.0.

 Note that the `first_vertex` and `first_instance` parameters are NOT
 compatible with built-in vertex/instance ID variables in shaders (for
 example, SV_VertexID); GPU APIs and shader languages do not define these
 built-in variables consistently, so if your shader depends on them, the
 only way to keep behavior consistent and portable is to always pass 0 for
 the correlating parameter in the draw calls.
*>
struct SDLGPUIndirectDrawCommand
{
    uint num_vertices;   /**< The number of vertices to draw. */
    uint num_instances;  /**< The number of instances to draw. */
    uint first_vertex;   /**< The index of the first vertex to draw. */
    uint first_instance; /**< The ID of the first instance to draw. */
}

<*
 A structure specifying the parameters of an indexed indirect draw command.
 This struct is available since SDL 3.2.0.

 Note that the `first_vertex` and `first_instance` parameters are NOT
 compatible with built-in vertex/instance ID variables in shaders (for
 example, SV_VertexID); GPU APIs and shader languages do not define these
 built-in variables consistently, so if your shader depends on them, the
 only way to keep behavior consistent and portable is to always pass 0 for
 the correlating parameter in the draw calls.
*>
struct SDLGPUIndexedIndirectDrawCommand
{
    uint num_indices;    /**< The number of indices to draw per instance. */
    uint num_instances;  /**< The number of instances to draw. */
    uint first_index;    /**< The base index within the index buffer. */
    int vertex_offset;   /**< The value added to the vertex index before indexing into the vertex buffer. */
    uint first_instance; /**< The ID of the first instance to draw. */
}

<*
 A structure specifying the parameters of an indexed dispatch command.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUIndirectDispatchCommand
{
    uint groupcount_x;  /**< The number of local workgroups to dispatch in the X dimension. */
    uint groupcount_y;  /**< The number of local workgroups to dispatch in the Y dimension. */
    uint groupcount_z;  /**< The number of local workgroups to dispatch in the Z dimension. */
}

/* State structures */

<*
 A structure specifying the parameters of a sampler.
 This function is available since SDL 3.2.0.

 Note that mip_lod_bias is a no-op for the Metal driver. For Metal, LOD bias
 must be applied via shader instead.
*>
struct SDLGPUSamplerCreateInfo
{
    SDLGPUFilter min_filter;                   /**< The minification filter to apply to lookups. */
    SDLGPUFilter mag_filter;                   /**< The magnification filter to apply to lookups. */
    SDLGPUSamplerMipmapMode mipmap_mode;       /**< The mipmap filter to apply to lookups. */
    SDLGPUSamplerAddressMode address_mode_u;   /**< The addressing mode for U coordinates outside [0, 1). */
    SDLGPUSamplerAddressMode address_mode_v;   /**< The addressing mode for V coordinates outside [0, 1). */
    SDLGPUSamplerAddressMode address_mode_w;   /**< The addressing mode for W coordinates outside [0, 1). */
    float mip_lod_bias;                        /**< The bias to be added to mipmap LOD calculation. */
    float max_anisotropy;                      /**< The anisotropy value clamp used by the sampler. If enable_anisotropy is false, this is ignored. */
    SDLGPUCompareOp compare_op;                /**< The comparison operator to apply to fetched data before filtering. */
    float min_lod;                             /**< Clamps the minimum of the computed LOD value. */
    float max_lod;                             /**< Clamps the maximum of the computed LOD value. */
    bool enable_anisotropy;                    /**< true to enable anisotropic filtering. */
    bool enable_compare;                       /**< true to enable comparison against a reference value during lookups. */
    char padding1;
    char padding2;

    SDLPropertiesID props;                     /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of vertex buffers used in a graphics
 pipeline.
 This struct is available since SDL 3.2.0.

 When you call SDL_BindGPUVertexBuffers, you specify the binding slots of
 the vertex buffers. For example if you called SDL_BindGPUVertexBuffers with
 a first_slot of 2 and num_bindings of 3, the binding slots 2, 3, 4 would be
 used by the vertex buffers you pass in.

 Vertex attributes are linked to buffers via the buffer_slot field of
 SDL_GPUVertexAttribute. For example, if an attribute has a buffer_slot of
 0, then that attribute belongs to the vertex buffer bound at slot 0.
*>
struct SDLGPUVertexBufferDescription
{
    uint slot;                         /**< The binding slot of the vertex buffer. */
    uint pitch;                        /**< The size of a single element + the offset between elements. */
    SDLGPUVertexInputRate input_rate;  /**< Whether attribute addressing is a function of the vertex index or instance index. */
    uint instance_step_rate;           /**< Reserved for future use. Must be set to 0. */
}

<*
 A structure specifying a vertex attribute.
 This struct is available since SDL 3.2.0.

 All vertex attribute locations provided to an SDL_GPUVertexInputState must
 be unique.
*>
struct SDLGPUVertexAttribute
{
    uint location;                     /**< The shader input location index. */
    uint buffer_slot;                  /**< The binding slot of the associated vertex buffer. */
    SDLGPUVertexElementFormat format;  /**< The size and type of the attribute data. */
    uint offset;                       /**< The byte offset of this attribute relative to the start of the vertex element. */
}

<*
 A structure specifying the parameters of a graphics pipeline vertex input
 state.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUVertexInputState
{
    SDLGPUVertexBufferDescription* vertex_buffer_descriptions;   /**< A pointer to an array of vertex buffer descriptions. */
    uint num_vertex_buffers;                                     /**< The number of vertex buffer descriptions in the above array. */
    SDLGPUVertexAttribute* vertex_attributes;                    /**< A pointer to an array of vertex attribute descriptions. */
    uint num_vertex_attributes;                                  /**< The number of vertex attribute descriptions in the above array. */
}

<*
 A structure specifying the stencil operation state of a graphics pipeline.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUStencilOpState
{
    SDLGPUStencilOp fail_op;        /**< The action performed on samples that fail the stencil test. */
    SDLGPUStencilOp pass_op;        /**< The action performed on samples that pass the depth and stencil tests. */
    SDLGPUStencilOp depth_fail_op;  /**< The action performed on samples that pass the stencil test and fail the depth test. */
    SDLGPUCompareOp compare_op;     /**< The comparison operator used in the stencil test. */
}

<*
 A structure specifying the blend state of a color target.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUColorTargetBlendState
{
    SDLGPUBlendFactor src_color_blendfactor;      /**< The value to be multiplied by the source RGB value. */
    SDLGPUBlendFactor dst_color_blendfactor;      /**< The value to be multiplied by the destination RGB value. */
    SDLGPUBlendOp color_blend_op;                 /**< The blend operation for the RGB components. */
    SDLGPUBlendFactor src_alpha_blendfactor;      /**< The value to be multiplied by the source alpha. */
    SDLGPUBlendFactor dst_alpha_blendfactor;      /**< The value to be multiplied by the destination alpha. */
    SDLGPUBlendOp alpha_blend_op;                 /**< The blend operation for the alpha component. */
    SDLGPUColorComponentFlags color_write_mask;   /**< A bitmask specifying which of the RGBA components are enabled for writing. Writes to all channels if enable_color_write_mask is false. */
    bool enable_blend;                            /**< Whether blending is enabled for the color target. */
    bool enable_color_write_mask;                 /**< Whether the color write mask is enabled. */
    char padding1;
    char padding2;
}


<*
 A structure specifying code and metadata for creating a shader object.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUShaderCreateInfo
{
    usz code_size;                /**< The size in bytes of the code pointed to. */
    char* code;                   /**< A pointer to shader code. */
    ZString entrypoint;           /**< A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. */
    SDLGPUShaderFormat format;    /**< The format of the shader code. */
    SDLGPUShaderStage stage;      /**< The stage the shader program corresponds to. */
    uint num_samplers;            /**< The number of samplers defined in the shader. */
    uint num_storage_textures;    /**< The number of storage textures defined in the shader. */
    uint num_storage_buffers;     /**< The number of storage buffers defined in the shader. */
    uint num_uniform_buffers;     /**< The number of uniform buffers defined in the shader. */

    SDLPropertiesID props;        /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of a texture.
 This struct is available since SDL 3.2.0.

 Usage flags can be bitwise OR'd together for combinations of usages. Note
 that certain usage combinations are invalid, for example SAMPLER and
 GRAPHICS_STORAGE.
*>
struct SDLGPUTextureCreateInfo
{
    SDLGPUTextureType type;           /**< The base dimensionality of the texture. */
    SDLGPUTextureFormat format;       /**< The pixel format of the texture. */
    SDLGPUTextureUsageFlags usage;    /**< How the texture is intended to be used by the client. */
    uint width;                       /**< The width of the texture. */
    uint height;                      /**< The height of the texture. */
    uint layer_count_or_depth;        /**< The layer count or depth of the texture. This value is treated as a layer count on 2D array textures, and as a depth value on 3D textures. */
    uint num_levels;                  /**< The number of mip levels in the texture. */
    SDLGPUSampleCount sample_count;   /**< The number of samples per texel. Only applies if the texture is used as a render target. */

    SDLPropertiesID props;            /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of a buffer.
 This struct is available since SDL 3.2.0.

 Usage flags can be bitwise OR'd together for combinations of usages. Note
 that certain combinations are invalid, for example VERTEX and INDEX.
*>
struct SDLGPUBufferCreateInfo
{
    SDLGPUBufferUsageFlags usage;  /**< How the buffer is intended to be used by the client. */
    uint size;                     /**< The size in bytes of the buffer. */

    SDLPropertiesID props;         /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of a transfer buffer.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUTransferBufferCreateInfo
{
    SDLGPUTransferBufferUsage usage;  /**< How the transfer buffer is intended to be used by the client. */
    uint size;                        /**< The size in bytes of the transfer buffer. */

    SDLPropertiesID props;            /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

/* Pipeline state structures */

<*
 A structure specifying the parameters of the graphics pipeline rasterizer
 state.
 This struct is available since SDL 3.2.0.

 Note that SDL_GPU_FILLMODE_LINE is not supported on many Android devices.
 For those devices, the fill mode will automatically fall back to FILL.

 Also note that the D3D12 driver will enable depth clamping even if
 enable_depth_clip is true. If you need this clamp+clip behavior, consider
 enabling depth clip and then manually clamping depth in your fragment
 shaders on Metal and Vulkan.
*>
struct SDLGPURasterizerState
{
    SDLGPUFillMode fill_mode;         /**< Whether polygons will be filled in or drawn as lines. */
    SDLGPUCullMode cull_mode;         /**< The facing direction in which triangles will be culled. */
    SDLGPUFrontFace front_face;       /**< The vertex winding that will cause a triangle to be determined as front-facing. */
    float depth_bias_constant_factor; /**< A scalar factor controlling the depth value added to each fragment. */
    float depth_bias_clamp;           /**< The maximum depth bias of a fragment. */
    float depth_bias_slope_factor;    /**< A scalar factor applied to a fragment's slope in depth calculations. */
    bool enable_depth_bias;           /**< true to bias fragment depth values. */
    bool enable_depth_clip;           /**< true to enable depth clip, false to enable depth clamp. */
    char padding1;
    char padding2;
}

<*
 A structure specifying the parameters of the graphics pipeline multisample
 state.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUMultisampleState
{
    SDLGPUSampleCount sample_count;  /**< The number of samples to be used in rasterization. */
    uint sample_mask;                /**< Reserved for future use. Must be set to 0. */
    bool enable_mask;                /**< Reserved for future use. Must be set to false. */
    char padding1;
    char padding2;
    char padding3;
}

<*
 A structure specifying the parameters of the graphics pipeline depth
 stencil state.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUDepthStencilState
{
    SDLGPUCompareOp compare_op;                /**< The comparison operator used for depth testing. */
    SDLGPUStencilOpState back_stencil_state;   /**< The stencil op state for back-facing triangles. */
    SDLGPUStencilOpState front_stencil_state;  /**< The stencil op state for front-facing triangles. */
    char compare_mask;                         /**< Selects the bits of the stencil values participating in the stencil test. */
    char write_mask;                           /**< Selects the bits of the stencil values updated by the stencil test. */
    bool enable_depth_test;                    /**< true enables the depth test. */
    bool enable_depth_write;                   /**< true enables depth writes. Depth writes are always disabled when enable_depth_test is false. */
    bool enable_stencil_test;                  /**< true enables the stencil test. */
    char padding1;
    char padding2;
    char padding3;
}

<*
 A structure specifying the parameters of color targets used in a graphics
 pipeline.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUColorTargetDescription
{
    SDLGPUTextureFormat format;               /**< The pixel format of the texture to be used as a color target. */
    SDLGPUColorTargetBlendState blend_state;  /**< The blend state to be used for the color target. */
}

<*
 A structure specifying the descriptions of render targets used in a
 graphics pipeline.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUGraphicsPipelineTargetInfo
{
    SDLGPUColorTargetDescription* color_target_descriptions;   /**< A pointer to an array of color target descriptions. */
    uint num_color_targets;                                    /**< The number of color target descriptions in the above array. */
    SDLGPUTextureFormat depth_stencil_format;                  /**< The pixel format of the depth-stencil target. Ignored if has_depth_stencil_target is false. */
    bool has_depth_stencil_target;                             /**< true specifies that the pipeline uses a depth-stencil target. */
    char padding1;
    char padding2;
    char padding3;
}

<*
 A structure specifying the parameters of a graphics pipeline state.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUGraphicsPipelineCreateInfo
{
    SDLGPUShader* vertex_shader;                   /**< The vertex shader used by the graphics pipeline. */
    SDLGPUShader* fragment_shader;                 /**< The fragment shader used by the graphics pipeline. */
    SDLGPUVertexInputState vertex_input_state;     /**< The vertex layout of the graphics pipeline. */
    SDLGPUPrimitiveType primitive_type;            /**< The primitive topology of the graphics pipeline. */
    SDLGPURasterizerState rasterizer_state;        /**< The rasterizer state of the graphics pipeline. */
    SDLGPUMultisampleState multisample_state;      /**< The multisample state of the graphics pipeline. */
    SDLGPUDepthStencilState depth_stencil_state;   /**< The depth-stencil state of the graphics pipeline. */
    SDLGPUGraphicsPipelineTargetInfo target_info;  /**< Formats and blend modes for the render targets of the graphics pipeline. */

    SDLPropertiesID props;                         /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of a compute pipeline state.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUComputePipelineCreateInfo
{
    usz code_size;                        /**< The size in bytes of the compute shader code pointed to. */
    char* code;                           /**< A pointer to compute shader code. */
    ZString entrypoint;                   /**< A pointer to a null-terminated UTF-8 string specifying the entry point function name for the shader. */
    SDLGPUShaderFormat format;            /**< The format of the compute shader code. */
    uint num_samplers;                    /**< The number of samplers defined in the shader. */
    uint num_readonly_storage_textures;   /**< The number of readonly storage textures defined in the shader. */
    uint num_readonly_storage_buffers;    /**< The number of readonly storage buffers defined in the shader. */
    uint num_readwrite_storage_textures;  /**< The number of read-write storage textures defined in the shader. */
    uint num_readwrite_storage_buffers;   /**< The number of read-write storage buffers defined in the shader. */
    uint num_uniform_buffers;             /**< The number of uniform buffers defined in the shader. */
    uint threadcount_x;                   /**< The number of threads in the X dimension. This should match the value in the shader. */
    uint threadcount_y;                   /**< The number of threads in the Y dimension. This should match the value in the shader. */
    uint threadcount_z;                   /**< The number of threads in the Z dimension. This should match the value in the shader. */

    SDLPropertiesID props;                /**< A properties ID for extensions. Should be 0 if no extensions are needed. */
}

<*
 A structure specifying the parameters of a color target used by a render
 pass.
 This struct is available since SDL 3.2.0.

 The load_op field determines what is done with the texture at the beginning
 of the render pass.

 - LOAD: Loads the data currently in the texture. Not recommended for
   multisample textures as it requires significant memory bandwidth.
 - CLEAR: Clears the texture to a single color.
 - DONT_CARE: The driver will do whatever it wants with the texture memory.
   This is a good option if you know that every single pixel will be touched
   in the render pass.

 The store_op field determines what is done with the color results of the
 render pass.

 - STORE: Stores the results of the render pass in the texture. Not
   recommended for multisample textures as it requires significant memory
   bandwidth.
 - DONT_CARE: The driver will do whatever it wants with the texture memory.
   This is often a good option for depth/stencil textures.
 - RESOLVE: Resolves a multisample texture into resolve_texture, which must
   have a sample count of 1. Then the driver may discard the multisample
   texture memory. This is the most performant method of resolving a
   multisample target.
 - RESOLVE_AND_STORE: Resolves a multisample texture into the
   resolve_texture, which must have a sample count of 1. Then the driver
   stores the multisample texture's contents. Not recommended as it requires
   significant memory bandwidth.
*>
struct SDLGPUColorTargetInfo
{
    SDLGPUTexture* texture;         /**< The texture that will be used as a color target by a render pass. */
    uint mip_level;                 /**< The mip level to use as a color target. */
    uint layer_or_depth_plane;      /**< The layer index or depth plane to use as a color target. This value is treated as a layer index on 2D array and cube textures, and as a depth plane on 3D textures. */
    SDLFColor clear_color;          /**< The color to clear the color target to at the start of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
    SDLGPULoadOp load_op;           /**< What is done with the contents of the color target at the beginning of the render pass. */
    SDLGPUStoreOp store_op;         /**< What is done with the results of the render pass. */
    SDLGPUTexture* resolve_texture; /**< The texture that will receive the results of a multisample resolve operation. Ignored if a RESOLVE* store_op is not used. */
    uint resolve_mip_level;         /**< The mip level of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. */
    uint resolve_layer;             /**< The layer index of the resolve texture to use for the resolve operation. Ignored if a RESOLVE* store_op is not used. */
    bool cycle;                     /**< true cycles the texture if the texture is bound and load_op is not LOAD */
    bool cycle_resolve_texture;     /**< true cycles the resolve texture if the resolve texture is bound. Ignored if a RESOLVE* store_op is not used. */
    char padding1;
    char padding2;
}

<*
 A structure specifying the parameters of a depth-stencil target used by a
 render pass.
 This struct is available since SDL 3.2.0.

 The load_op field determines what is done with the depth contents of the
 texture at the beginning of the render pass.

 - LOAD: Loads the depth values currently in the texture.
 - CLEAR: Clears the texture to a single depth.
 - DONT_CARE: The driver will do whatever it wants with the memory. This is
   a good option if you know that every single pixel will be touched in the
   render pass.

 The store_op field determines what is done with the depth results of the
 render pass.

 - STORE: Stores the depth results in the texture.
 - DONT_CARE: The driver will do whatever it wants with the depth results.
   This is often a good option for depth/stencil textures that don't need to
   be reused again.

 The stencil_load_op field determines what is done with the stencil contents
 of the texture at the beginning of the render pass.

 - LOAD: Loads the stencil values currently in the texture.
 - CLEAR: Clears the stencil values to a single value.
 - DONT_CARE: The driver will do whatever it wants with the memory. This is
   a good option if you know that every single pixel will be touched in the
   render pass.

 The stencil_store_op field determines what is done with the stencil results
 of the render pass.

 - STORE: Stores the stencil results in the texture.
 - DONT_CARE: The driver will do whatever it wants with the stencil results.
   This is often a good option for depth/stencil textures that don't need to
   be reused again.

 Note that depth/stencil targets do not support multisample resolves.
*>
struct SDLGPUDepthStencilTargetInfo
{
    SDLGPUTexture* texture;               /**< The texture that will be used as the depth stencil target by the render pass. */
    float clear_depth;                    /**< The value to clear the depth component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
    SDLGPULoadOp load_op;                 /**< What is done with the depth contents at the beginning of the render pass. */
    SDLGPUStoreOp store_op;               /**< What is done with the depth results of the render pass. */
    SDLGPULoadOp stencil_load_op;         /**< What is done with the stencil contents at the beginning of the render pass. */
    SDLGPUStoreOp stencil_store_op;       /**< What is done with the stencil results of the render pass. */
    bool cycle;                           /**< true cycles the texture if the texture is bound and any load ops are not LOAD */
    char clear_stencil;                   /**< The value to clear the stencil component to at the beginning of the render pass. Ignored if SDL_GPU_LOADOP_CLEAR is not used. */
    char padding1;
    char padding2;
}

<*
 A structure containing parameters for a blit command.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUBlitInfo {
    SDLGPUBlitRegion source;       /**< The source region for the blit. */
    SDLGPUBlitRegion destination;  /**< The destination region for the blit. */
    SDLGPULoadOp load_op;          /**< What is done with the contents of the destination before the blit. */
    SDLFColor clear_color;         /**< The color to clear the destination region to before the blit. Ignored if load_op is not SDL_GPU_LOADOP_CLEAR. */
    SDLFlipMode flip_mode;         /**< The flip mode for the source region. */
    SDLGPUFilter filter;           /**< The filter mode used when blitting. */
    bool cycle;                    /**< true cycles the destination texture if it is already bound. */
    char padding1;
    char padding2;
    char padding3;
}

/* Binding structs */

<*
 A structure specifying parameters in a buffer binding call.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUBufferBinding
{
    SDLGPUBuffer* buffer;  /**< The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_VERTEX for SDL_BindGPUVertexBuffers, or SDL_GPU_BUFFERUSAGE_INDEX for SDL_BindGPUIndexBuffer. */
    uint offset;           /**< The starting byte of the data to bind in the buffer. */
}

<*
 A structure specifying parameters in a sampler binding call.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUTextureSamplerBinding
{
    SDLGPUTexture* texture;  /**< The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER. */
    SDLGPUSampler* sampler;  /**< The sampler to bind. */
}

<*
 A structure specifying parameters related to binding buffers in a compute
 pass.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUStorageBufferReadWriteBinding
{
    SDLGPUBuffer* buffer;  /**< The buffer to bind. Must have been created with SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE. */
    bool cycle;            /**< true cycles the buffer if it is already bound. */
    char padding1;
    char padding2;
    char padding3;
}

<*
 A structure specifying parameters related to binding textures in a compute
 pass.
 This struct is available since SDL 3.2.0.
*>
struct SDLGPUStorageTextureReadWriteBinding
{
    SDLGPUTexture* texture;  /**< The texture to bind. Must have been created with SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE or SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE. */
    uint mip_level;          /**< The mip level index to bind. */
    uint layer;              /**< The layer index to bind. */
    bool cycle;              /**< true cycles the texture if it is already bound. */
    char padding1;
    char padding2;
    char padding3;
}

/* Functions */

/* Device */

<*
 Checks for GPU runtime support.
 This function is available since SDL 3.2.0.

 @param format_flags : `a bitflag indicating which shader formats the app is
                        able to provide.`
 @param name : `the preferred GPU driver, or NULL to let SDL pick the optimal
                driver.`
 @return `true if supported, false otherwise.`
*>
extern fn bool gpu_supports_shader_formats(SDLGPUShaderFormat format_flags, ZString name) @extern("SDL_GPUSupportsShaderFormats");

<*
 Checks for GPU runtime support.
 This function is available since SDL 3.2.0.

 @param props : `the properties to use.`
 @return `true if supported, false otherwise.`
*>
extern fn bool gpu_supports_properties(SDLPropertiesID props) @extern("SDL_GPUSupportsProperties");

<*
 Creates a GPU context.
 This function is available since SDL 3.2.0.

 @param format_flags : `a bitflag indicating which shader formats the app is
                        able to provide.`
 @param debug_mode : `enable debug mode properties and validations.`
 @param name : `the preferred GPU driver, or NULL to let SDL pick the optimal
                driver.`
 @return `a GPU context on success or NULL on failure; call SDL_GetError()
          for more information.`
*>
extern fn SDLGPUDevice* create_gpu_device(SDLGPUShaderFormat format_flags, bool debug_mode, ZString name) @extern("SDL_CreateGPUDevice");

<*
 Creates a GPU context.
 This function is available since SDL 3.2.0.

 These are the supported properties:

 - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOLEAN`: enable debug mode
   properties and validations, defaults to true.
 - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOLEAN`: enable to prefer
   energy efficiency over maximum GPU performance, defaults to false.
 - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to
   use, if a specific one is desired.

 These are the current shader format properties:

 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOLEAN`: The app is able to
   provide shaders for an NDA platform.
 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOLEAN`: The app is able to
   provide SPIR-V shaders if applicable.
 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOLEAN`: The app is able to
   provide DXBC shaders if applicable
 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOLEAN`: The app is able to
   provide DXIL shaders if applicable.
 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOLEAN`: The app is able to
   provide MSL shaders if applicable.
 - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOLEAN`: The app is able to
   provide Metal shader libraries if applicable.

 With the D3D12 renderer:

 - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to
   use for all vertex semantics, default is "TEXCOORD".

 @param props : `the properties to use.`
 @return `a GPU context on success or NULL on failure; call SDL_GetError()
          for more information.`
*>
extern fn SDLGPUDevice* create_gpu_device_with_properties(SDLPropertiesID props) @extern("SDL_CreateGPUDeviceWithProperties");

enum SDLPropGPUDeviceCreate : const inline ZString
{
	DEBUGMODE_BOOLEAN =          "SDL.gpu.device.create.debugmode",
	PREFERLOWPOWER_BOOLEAN =     "SDL.gpu.device.create.preferlowpower",
	NAME_STRING =                "SDL.gpu.device.create.name",
	SHADERS_PRIVATE_BOOLEAN =    "SDL.gpu.device.create.shaders.private",
	SHADERS_SPIRV_BOOLEAN =      "SDL.gpu.device.create.shaders.spirv",
	SHADERS_DXBC_BOOLEAN =       "SDL.gpu.device.create.shaders.dxbc",
	SHADERS_DXIL_BOOLEAN =       "SDL.gpu.device.create.shaders.dxil",
	SHADERS_MSL_BOOLEAN =        "SDL.gpu.device.create.shaders.msl",
	SHADERS_METALLIB_BOOLEAN =   "SDL.gpu.device.create.shaders.metallib",
	D3D12_SEMANTIC_NAME_STRING = "SDL.gpu.device.create.d3d12.semantic",
}

<*
 Destroys a GPU context previously returned by SDL_CreateGPUDevice.
 This function is available since SDL 3.2.0.

 @param device : `a GPU Context to destroy.`
*>
extern fn void SDLGPUDevice.destroy(&device) @extern("SDL_DestroyGPUDevice");

<*
 Get the number of GPU drivers compiled into SDL.
 This function is available since SDL 3.2.0.

 @return `the number of built in GPU drivers.`
*>
extern fn CInt get_num_gpu_drivers() @extern("SDL_GetNumGPUDrivers");

<*
 Get the name of a built in GPU driver.
 This function is available since SDL 3.2.0.

 The GPU drivers are presented in the order in which they are normally
 checked during initialization.

 The names of drivers are all simple, low-ASCII identifiers, like "vulkan",
 "metal" or "direct3d12". These never have Unicode characters, and are not
 meant to be proper names.

 @param index : `the index of a GPU driver.`
 @return `the name of the GPU driver with the given **index**.`
*>
extern fn ZString get_gpu_driver(CInt index) @extern("SDL_GetGPUDriver");

<*
 Returns the name of the backend used to create this GPU context.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context to query.`
 @return `the name of the device's driver, or NULL on error.`
*>
extern fn ZString SDLGPUDevice.get_driver(&device) @extern("SDL_GetGPUDeviceDriver");

<*
 Returns the supported shader formats for this GPU context.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context to query.`
 @return `a bitflag indicating which shader formats the driver is able to
          consume.`
*>
extern fn SDLGPUShaderFormat SDLGPUDevice.get_shader_formats(&device) @extern("SDL_GetGPUShaderFormats");

/* State Creation */

<*
 Creates a pipeline object to be used in a compute workflow.
 This function is available since SDL 3.2.0.

 Shader resource bindings must be authored to follow a particular order
 depending on the shader format.

 For SPIR-V shaders, use the following resource sets:

 - 0: Sampled textures, followed by read-only storage textures, followed by
   read-only storage buffers
 - 1: Read-write storage textures, followed by read-write storage buffers
 - 2: Uniform buffers

 For DXBC and DXIL shaders, use the following register order:

 - (t[n], space0): Sampled textures, followed by read-only storage textures,
   followed by read-only storage buffers
 - (u[n], space1): Read-write storage textures, followed by read-write
   storage buffers
 - (b[n], space2): Uniform buffers

 For MSL/metallib, use the following order:

 - [[buffer]]: Uniform buffers, followed by read-only storage buffers,
   followed by read-write storage buffers
 - [[texture]]: Sampled textures, followed by read-only storage textures,
   followed by read-write storage textures

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_COMPUTEPIPELINE_CREATE_NAME_STRING`: a name that can be
   displayed in debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the compute pipeline to
                      create.`
 @return `a compute pipeline object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUComputePipeline* SDLGPUDevice.create_compute_pipeline(&device, SDLGPUComputePipelineCreateInfo* createinfo) @extern("SDL_CreateGPUComputePipeline");

enum SDLPropGPUComputePipelineCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.computepipeline.create.name",
}

<*
 Creates a pipeline object to be used in a graphics workflow.
 This function is available since SDL 3.2.0.

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_GRAPHICSPIPELINE_CREATE_NAME_STRING`: a name that can be
   displayed in debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the graphics pipeline to
                      create.`
 @return `a graphics pipeline object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUGraphicsPipeline* SDLGPUDevice.create_graphics_pipeline(&device, SDLGPUGraphicsPipelineCreateInfo* createinfo) @extern("SDL_CreateGPUGraphicsPipeline");
enum SDLPropGPUGraphicsPipelineCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.graphicspipeline.create.name",
}

<*
 Creates a sampler object to be used when binding textures in a graphics
 workflow.
 This function is available since SDL 3.2.0.

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_SAMPLER_CREATE_NAME_STRING`: a name that can be displayed
   in debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the sampler to create.`
 @return `a sampler object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUSampler* SDLGPUDevice.create_sampler(&device, SDLGPUSamplerCreateInfo* createinfo) @extern("SDL_CreateGPUSampler");
enum SDLPropGPUSamplerCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.sampler.create.name",
}

<*
 Creates a shader to be used when creating a graphics pipeline.
 This function is available since SDL 3.2.0.

 Shader resource bindings must be authored to follow a particular order
 depending on the shader format.

 For SPIR-V shaders, use the following resource sets:

 For vertex shaders:

 - 0: Sampled textures, followed by storage textures, followed by storage
   buffers
 - 1: Uniform buffers

 For fragment shaders:

 - 2: Sampled textures, followed by storage textures, followed by storage
   buffers
 - 3: Uniform buffers

 For DXBC and DXIL shaders, use the following register order:

 For vertex shaders:

 - (t[n], space0): Sampled textures, followed by storage textures, followed
   by storage buffers
 - (s[n], space0): Samplers with indices corresponding to the sampled
   textures
 - (b[n], space1): Uniform buffers

 For pixel shaders:

 - (t[n], space2): Sampled textures, followed by storage textures, followed
   by storage buffers
 - (s[n], space2): Samplers with indices corresponding to the sampled
   textures
 - (b[n], space3): Uniform buffers

 For MSL/metallib, use the following order:

 - [[texture]]: Sampled textures, followed by storage textures
 - [[sampler]]: Samplers with indices corresponding to the sampled textures
 - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0
   is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.
   Rather than manually authoring vertex buffer indices, use the
   [[stage_in]] attribute which will automatically use the vertex input
   information from the SDL_GPUGraphicsPipeline.

 Shader semantics other than system-value semantics do not matter in D3D12
 and for ease of use the SDL implementation assumes that non system-value
 semantics will all be TEXCOORD. If you are using HLSL as the shader source
 language, your vertex semantics should start at TEXCOORD0 and increment
 like so: TEXCOORD1, TEXCOORD2, etc. If you wish to change the semantic
 prefix to something other than TEXCOORD you can use
 SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING with
 SDL_CreateGPUDeviceWithProperties().

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_SHADER_CREATE_NAME_STRING`: a name that can be displayed in
   debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the shader to create.`
 @return `a shader object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUShader* SDLGPUDevice.create_shader(&device, SDLGPUShaderCreateInfo* createinfo) @extern("SDL_CreateGPUShader");
enum SDLPropGPUShaderCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.shader.create.name",
}

<*
 Creates a texture object to be used in graphics or compute workflows.
 This function is available since SDL 3.2.0.

 The contents of this texture are undefined until data is written to the
 texture.

 Note that certain combinations of usage flags are invalid. For example, a
 texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.

 If you request a sample count higher than the hardware supports, the
 implementation will automatically fall back to the highest available sample
 count.

 There are optional properties that can be provided through
 SDL_GPUTextureCreateInfo's `props`. These are the supported properties:

 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_R_FLOAT`: (Direct3D 12 only) if
   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
   to a color with this red intensity. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_G_FLOAT`: (Direct3D 12 only) if
   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
   to a color with this green intensity. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_B_FLOAT`: (Direct3D 12 only) if
   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
   to a color with this blue intensity. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_A_FLOAT`: (Direct3D 12 only) if
   the texture usage is SDL_GPU_TEXTUREUSAGE_COLOR_TARGET, clear the texture
   to a color with this alpha intensity. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_DEPTH_FLOAT`: (Direct3D 12 only)
   if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET, clear
   the texture to a depth of this value. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_D3D12_CLEAR_STENCIL_NUMBER`: (Direct3D 12
   only) if the texture usage is SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
   clear the texture to a stencil of this Uint8 value. Defaults to zero.
 - `SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING`: a name that can be displayed
   in debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the texture to create.`
 @return `a texture object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUTexture* SDLGPUDevice.create_texture(&device, SDLGPUTextureCreateInfo* createinfo) @extern("SDL_CreateGPUTexture");
enum SDLPropGPUTextureCreate : const inline ZString
{
	D3D12_CLEAR_R_FLOAT =         "SDL.gpu.texture.create.d3d12.clear.r",
	D3D12_CLEAR_G_FLOAT =         "SDL.gpu.texture.create.d3d12.clear.g",
	D3D12_CLEAR_B_FLOAT =         "SDL.gpu.texture.create.d3d12.clear.b",
	D3D12_CLEAR_A_FLOAT =         "SDL.gpu.texture.create.d3d12.clear.a",
	D3D12_CLEAR_DEPTH_FLOAT =     "SDL.gpu.texture.create.d3d12.clear.depth",
	D3D12_CLEAR_STENCIL_NUMBER =  "SDL.gpu.texture.create.d3d12.clear.stencil",
	NAME_STRING =                 "SDL.gpu.texture.create.name",
}

<*
 Creates a buffer object to be used in graphics or compute workflows.
 This function is available since SDL 3.2.0.

 The contents of this buffer are undefined until data is written to the
 buffer.

 Note that certain combinations of usage flags are invalid. For example, a
 buffer cannot have both the VERTEX and INDEX flags.

 If you use a STORAGE flag, the data in the buffer must respect std140
 layout conventions. In practical terms this means you must ensure that vec3
 and vec4 fields are 16-byte aligned.

 For better understanding of underlying concepts and memory management with
 SDL GPU API, you may refer
 [this blog post](https://moonside.games/posts/sdl-gpu-concepts-cycling/)
 .

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING`: a name that can be displayed in
   debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the buffer to create.`
 @return `a buffer object on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUBuffer* SDLGPUDevice.create_buffer(&device, SDLGPUBufferCreateInfo* createinfo) @extern("SDL_CreateGPUBuffer");
enum SDLPropGPUBufferCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.buffer.create.name",
}

<*
 Creates a transfer buffer to be used when uploading to or downloading from
 graphics resources.
 This function is available since SDL 3.2.0.

 Download buffers can be particularly expensive to create, so it is good
 practice to reuse them if data will be downloaded regularly.

 There are optional properties that can be provided through `props`. These
 are the supported properties:

 - `SDL_PROP_GPU_TRANSFERBUFFER_CREATE_NAME_STRING`: a name that can be
   displayed in debugging tools.

 @param device : `a GPU Context.`
 @param createinfo : `a struct describing the state of the transfer buffer to
                      create.`
 @return `a transfer buffer on success, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLGPUTransferBuffer* SDLGPUDevice.create_transfer_buffer(&device, SDLGPUTransferBufferCreateInfo* createinfo) @extern("SDL_CreateGPUTransferBuffer");
enum SDLPropGPUTransferBufferCreate : const inline ZString
{
	NAME_STRING = "SDL.gpu.transferbuffer.create.name",
}

/* Debug Naming */

<*
 Sets an arbitrary string constant to label a buffer.
 This function is available since SDL 3.2.0.

 You should use SDL_PROP_GPU_BUFFER_CREATE_NAME_STRING with
 SDL_CreateGPUBuffer instead of this function to avoid thread safety issues.

 threadsafety: This function is not thread safe, you must make sure the
               buffer is not simultaneously used by any other thread.


 @param device : `a GPU Context.`
 @param buffer : `a buffer to attach the name to.`
 @param text : `a UTF-8 string constant to mark as the name of the buffer.`
*>
extern fn void SDLGPUDevice.set_buffer_name(&device, SDLGPUBuffer* buffer, ZString text) @extern("SDL_SetGPUBufferName");

<*
 Sets an arbitrary string constant to label a texture.
 This function is available since SDL 3.2.0.

 You should use SDL_PROP_GPU_TEXTURE_CREATE_NAME_STRING with
 SDL_CreateGPUTexture instead of this function to avoid thread safety
 issues.

 threadsafety: This function is not thread safe, you must make sure the
               texture is not simultaneously used by any other thread.


 @param device : `a GPU Context.`
 @param texture : `a texture to attach the name to.`
 @param text : `a UTF-8 string constant to mark as the name of the texture.`
*>
extern fn void SDLGPUDevice.set_texture_name(&device, SDLGPUTexture* texture, ZString text) @extern("SDL_SetGPUTextureName");

<*
 Inserts an arbitrary string label into the command buffer callstream.
 This function is available since SDL 3.2.0.

 Useful for debugging.

 @param command_buffer : `a command buffer.`
 @param text : `a UTF-8 string constant to insert as the label.`
*>
extern fn void SDLGPUCommandBuffer.insert_debug_label(&command_buffer, ZString text) @extern("SDL_InsertGPUDebugLabel");

<*
 Begins a debug group with an arbitrary name.
 This function is available since SDL 3.2.0.

 Used for denoting groups of calls when viewing the command buffer
 callstream in a graphics debugging tool.

 Each call to SDL_PushGPUDebugGroup must have a corresponding call to
 SDL_PopGPUDebugGroup.

 On some backends (e.g. Metal), pushing a debug group during a
 render/blit/compute pass will create a group that is scoped to the native
 pass rather than the command buffer. For best results, if you push a debug
 group during a pass, always pop it in the same pass.

 @param command_buffer : `a command buffer.`
 @param name : `a UTF-8 string constant that names the group.`
*>
extern fn void SDLGPUCommandBuffer.push_debug_group(&command_buffer, ZString name) @extern("SDL_PushGPUDebugGroup");

<*
 Ends the most-recently pushed debug group.
 This function is available since SDL 3.2.0.

 @param command_buffer : `a command buffer.`
*>
extern fn void SDLGPUCommandBuffer.pop_debug_group(&command_buffer) @extern("SDL_PopGPUDebugGroup");

/* Disposal */

<*
 Frees the given texture as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the texture after calling this function.

 @param device : `a GPU context.`
 @param texture : `a texture to be destroyed.`
*>
extern fn void SDLGPUDevice.release_texture(&device, SDLGPUTexture* texture) @extern("SDL_ReleaseGPUTexture");

<*
 Frees the given sampler as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the sampler after calling this function.

 @param device : `a GPU context.`
 @param sampler : `a sampler to be destroyed.`
*>
extern fn void SDLGPUDevice.release_sampler(&device, SDLGPUSampler* sampler) @extern("SDL_ReleaseGPUSampler");

<*
 Frees the given buffer as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the buffer after calling this function.

 @param device : `a GPU context.`
 @param buffer : `a buffer to be destroyed.`
*>
extern fn void SDLGPUDevice.release_buffer(&device, SDLGPUBuffer* buffer) @extern("SDL_ReleaseGPUBuffer");

<*
 Frees the given transfer buffer as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the transfer buffer after calling this function.

 @param device : `a GPU context.`
 @param transfer_buffer : `a transfer buffer to be destroyed.`
*>
extern fn void SDLGPUDevice.release_transfer_buffer(&device, SDLGPUTransferBuffer* transfer_buffer) @extern("SDL_ReleaseGPUTransferBuffer");

<*
 Frees the given compute pipeline as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the compute pipeline after calling this function.

 @param device : `a GPU context.`
 @param compute_pipeline : `a compute pipeline to be destroyed.`
*>
extern fn void SDLGPUDevice.release_compute_pipeline(&device, SDLGPUComputePipeline* compute_pipeline) @extern("SDL_ReleaseGPUComputePipeline");

<*
 Frees the given shader as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the shader after calling this function.

 @param device : `a GPU context.`
 @param shader : `a shader to be destroyed.`
*>
extern fn void SDLGPUDevice.release_shader(&device, SDLGPUShader* shader) @extern("SDL_ReleaseGPUShader");

<*
 Frees the given graphics pipeline as soon as it is safe to do so.
 This function is available since SDL 3.2.0.

 You must not reference the graphics pipeline after calling this function.

 @param device : `a GPU context.`
 @param graphics_pipeline : `a graphics pipeline to be destroyed.`
*>
extern fn void SDLGPUDevice.release_graphics_pipeline(&device, SDLGPUGraphicsPipeline* graphics_pipeline) @extern("SDL_ReleaseGPUGraphicsPipeline");

<*
 Acquire a command buffer.
 This function is available since SDL 3.2.0.

 This command buffer is managed by the implementation and should not be
 freed by the user. The command buffer may only be used on the thread it was
 acquired on. The command buffer should be submitted on the thread it was
 acquired on.

 It is valid to acquire multiple command buffers on the same thread at once.
 In fact a common design pattern is to acquire two command buffers per frame
 where one is dedicated to render and compute passes and the other is
 dedicated to copy passes and other preparatory work such as generating
 mipmaps. Interleaving commands between the two command buffers reduces the
 total amount of passes overall which improves rendering performance.

 @param device : `a GPU context.`
 @return `a command buffer, or NULL on failure; call SDL_GetError() for more
          information.`
*>
extern fn SDLGPUCommandBuffer* SDLGPUDevice.acquire_command_buffer(&device) @extern("SDL_AcquireGPUCommandBuffer");

/* Uniform Data */

<*
 Pushes data to a vertex uniform slot on the command buffer.
 This function is available since SDL 3.2.0.

 Subsequent draw calls will use this uniform data.

 The data being pushed must respect std140 layout conventions. In practical
 terms this means you must ensure that vec3 and vec4 fields are 16-byte
 aligned.

 @param command_buffer : `a command buffer.`
 @param slot_index : `the vertex uniform slot to push data to.`
 @param data : `client data to write.`
 @param length : `the length of the data to write.`
*>
extern fn void SDLGPUCommandBuffer.push_vertex_uniform_data(&command_buffer, uint slot_index, void* data, uint length) @extern("SDL_PushGPUVertexUniformData");

<*
 Pushes data to a fragment uniform slot on the command buffer.
 This function is available since SDL 3.2.0.

 Subsequent draw calls will use this uniform data.

 The data being pushed must respect std140 layout conventions. In practical
 terms this means you must ensure that vec3 and vec4 fields are 16-byte
 aligned.

 @param command_buffer : `a command buffer.`
 @param slot_index : `the fragment uniform slot to push data to.`
 @param data : `client data to write.`
 @param length : `the length of the data to write.`
*>
extern fn void SDLGPUCommandBuffer.push_fragment_uniform_data(&command_buffer, uint slot_index, void* data, uint length) @extern("SDL_PushGPUFragmentUniformData");

<*
 Pushes data to a uniform slot on the command buffer.
 This function is available since SDL 3.2.0.

 Subsequent draw calls will use this uniform data.

 The data being pushed must respect std140 layout conventions. In practical
 terms this means you must ensure that vec3 and vec4 fields are 16-byte
 aligned.

 @param command_buffer : `a command buffer.`
 @param slot_index : `the uniform slot to push data to.`
 @param data : `client data to write.`
 @param length : `the length of the data to write.`
*>
extern fn void SDLGPUCommandBuffer.push_compute_uniform_data(&command_buffer, uint slot_index, void* data, uint length) @extern("SDL_PushGPUComputeUniformData");

/* Graphics State */

<*
 Begins a render pass on a command buffer.
 This function is available since SDL 3.2.0.

 A render pass consists of a set of texture subresources (or depth slices in
 the 3D texture case) which will be rendered to during the render pass,
 along with corresponding clear values and load/store operations. All
 operations related to graphics pipelines must take place inside of a render
 pass. A default viewport and scissor state are automatically set when this
 is called. You cannot begin another render pass, or begin a compute pass or
 copy pass until you have ended the render pass.

 @param command_buffer : `a command buffer.`
 @param color_target_infos : `an array of texture subresources with
                              corresponding clear values and load/store ops.`
 @param num_color_targets : `the number of color targets in the
                             color_target_infos array.`
 @param depth_stencil_target_info : `a texture subresource with corresponding
                                     clear value and load/store ops, may be
                                     NULL.`
 @return `a render pass handle.`
*>
extern fn SDLGPURenderPass* SDLGPUCommandBuffer.begin_render_pass(&command_buffer, SDLGPUColorTargetInfo* color_target_infos, uint num_color_targets, SDLGPUDepthStencilTargetInfo* depth_stencil_target_info) @extern("SDL_BeginGPURenderPass");

<*
 Binds a graphics pipeline on a render pass to be used in rendering.
 This function is available since SDL 3.2.0.

 A graphics pipeline must be bound before making any draw calls.

 @param render_pass : `a render pass handle.`
 @param graphics_pipeline : `the graphics pipeline to bind.`
*>
extern fn void SDLGPURenderPass.bind_graphics_pipeline(&render_pass, SDLGPUGraphicsPipeline* graphics_pipeline) @extern("SDL_BindGPUGraphicsPipeline");

<*
 Sets the current viewport state on a command buffer.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param viewport : `the viewport to set.`
*>
extern fn void SDLGPURenderPass.set_viewport(&render_pass, SDLGPUViewport* viewport) @extern("SDL_SetGPUViewport");

<*
 Sets the current scissor state on a command buffer.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param scissor : `the scissor area to set.`
*>
extern fn void SDLGPURenderPass.set_scissor(&render_pass, SDLRect* scissor) @extern("SDL_SetGPUScissor");

<*
 Sets the current blend constants on a command buffer.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param blend_constants : `the blend constant color.`
*>
extern fn void SDLGPURenderPass.set_blend_constants(&render_pass, SDLFColor blend_constants) @extern("SDL_SetGPUBlendConstants");

<*
 Sets the current stencil reference value on a command buffer.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param reference : `the stencil reference value to set.`
*>
extern fn void SDLGPURenderPass.set_stencil_reference(&render_pass, char reference) @extern("SDL_SetGPUStencilReference");

<*
 Binds vertex buffers on a command buffer for use with subsequent draw
 calls.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param first_slot : `the vertex buffer slot to begin binding from.`
 @param bindings : `an array of SDL_GPUBufferBinding structs containing vertex
                    buffers and offset values.`
 @param num_bindings : `the number of bindings in the bindings array.`
*>
extern fn void SDLGPURenderPass.bind_vertex_buffers(&render_pass, uint first_slot, SDLGPUBufferBinding* bindings, uint num_bindings) @extern("SDL_BindGPUVertexBuffers");

<*
 Binds an index buffer on a command buffer for use with subsequent draw
 calls.
 This function is available since SDL 3.2.0.

 @param render_pass : `a render pass handle.`
 @param binding : `a pointer to a struct containing an index buffer and offset.`
 @param index_element_size : `whether the index values in the buffer are 16- or
                              32-bit.`
*>
extern fn void SDLGPURenderPass.bind_index_buffer(&render_pass, SDLGPUBufferBinding* binding, SDLGPUIndexElementSize index_element_size) @extern("SDL_BindGPUIndexBuffer");

<*
 Binds texture-sampler pairs for use on the vertex shader.
 This function is available since SDL 3.2.0.

 The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the vertex sampler slot to begin binding from.`
 @param texture_sampler_bindings : `an array of texture-sampler binding
                                    structs.`
 @param num_bindings : `the number of texture-sampler pairs to bind from the
                        array.`
*>
extern fn void SDLGPURenderPass.bind_vertex_samplers(&render_pass, uint first_slot, SDLGPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings) @extern("SDL_BindGPUVertexSamplers");

<*
 Binds storage textures for use on the vertex shader.
 This function is available since SDL 3.2.0.

 These textures must have been created with
 SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the vertex storage texture slot to begin binding from.`
 @param storage_textures : `an array of storage textures.`
 @param num_bindings : `the number of storage texture to bind from the array.`
*>
extern fn void SDLGPURenderPass.bind_vertex_storage_textures(&render_pass, uint first_slot, SDLGPUTexture** storage_textures, uint num_bindings) @extern("SDL_BindGPUVertexStorageTextures");

<*
 Binds storage buffers for use on the vertex shader.
 This function is available since SDL 3.2.0.

 These buffers must have been created with
 SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the vertex storage buffer slot to begin binding from.`
 @param storage_buffers : `an array of buffers.`
 @param num_bindings : `the number of buffers to bind from the array.`
*>
extern fn void SDLGPURenderPass.bind_vertex_storage_buffers(&render_pass, uint first_slot, SDLGPUBuffer** storage_buffers, uint num_bindings) @extern("SDL_BindGPUVertexStorageBuffers");

<*
 Binds texture-sampler pairs for use on the fragment shader.
 This function is available since SDL 3.2.0.

 The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the fragment sampler slot to begin binding from.`
 @param texture_sampler_bindings : `an array of texture-sampler binding
                                    structs.`
 @param num_bindings : `the number of texture-sampler pairs to bind from the
                        array.`
*>
extern fn void SDLGPURenderPass.bind_fragment_samplers(&render_pass, uint first_slot, SDLGPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings) @extern("SDL_BindGPUFragmentSamplers");

<*
 Binds storage textures for use on the fragment shader.
 This function is available since SDL 3.2.0.

 These textures must have been created with
 SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the fragment storage texture slot to begin binding from.`
 @param storage_textures : `an array of storage textures.`
 @param num_bindings : `the number of storage textures to bind from the array.`
*>
extern fn void SDLGPURenderPass.bind_fragment_storage_textures(&render_pass, uint first_slot, SDLGPUTexture** storage_textures, uint num_bindings) @extern("SDL_BindGPUFragmentStorageTextures");

<*
 Binds storage buffers for use on the fragment shader.
 This function is available since SDL 3.2.0.

 These buffers must have been created with
 SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param render_pass : `a render pass handle.`
 @param first_slot : `the fragment storage buffer slot to begin binding from.`
 @param storage_buffers : `an array of storage buffers.`
 @param num_bindings : `the number of storage buffers to bind from the array.`
*>
extern fn void SDLGPURenderPass.bind_fragment_storage_buffers(&render_pass, uint first_slot, SDLGPUBuffer** storage_buffers, uint num_bindings) @extern("SDL_BindGPUFragmentStorageBuffers");

/* Drawing */

<*
 Draws data using bound graphics state with an index buffer and instancing
 enabled.
 This function is available since SDL 3.2.0.

 You must not call this function before binding a graphics pipeline.

 Note that the `first_vertex` and `first_instance` parameters are NOT
 compatible with built-in vertex/instance ID variables in shaders (for
 example, SV_VertexID); GPU APIs and shader languages do not define these
 built-in variables consistently, so if your shader depends on them, the
 only way to keep behavior consistent and portable is to always pass 0 for
 the correlating parameter in the draw calls.

 @param render_pass : `a render pass handle.`
 @param num_indices : `the number of indices to draw per instance.`
 @param num_instances : `the number of instances to draw.`
 @param first_index : `the starting index within the index buffer.`
 @param vertex_offset : `value added to vertex index before indexing into the
                         vertex buffer.`
 @param first_instance : `the ID of the first instance to draw.`
*>
extern fn void SDLGPURenderPass.draw_indexed_primitives(&render_pass, uint num_indices, uint num_instances, uint first_index, int vertex_offset, uint first_instance) @extern("SDL_DrawGPUIndexedPrimitives");

<*
 Draws data using bound graphics state.
 This function is available since SDL 3.2.0.

 You must not call this function before binding a graphics pipeline.

 Note that the `first_vertex` and `first_instance` parameters are NOT
 compatible with built-in vertex/instance ID variables in shaders (for
 example, SV_VertexID); GPU APIs and shader languages do not define these
 built-in variables consistently, so if your shader depends on them, the
 only way to keep behavior consistent and portable is to always pass 0 for
 the correlating parameter in the draw calls.

 @param render_pass : `a render pass handle.`
 @param num_vertices : `the number of vertices to draw.`
 @param num_instances : `the number of instances that will be drawn.`
 @param first_vertex : `the index of the first vertex to draw.`
 @param first_instance : `the ID of the first instance to draw.`
*>
extern fn void SDLGPURenderPass.draw_primitives(&render_pass, uint num_vertices, uint num_instances, uint first_vertex, uint first_instance) @extern("SDL_DrawGPUPrimitives");

<*
 Draws data using bound graphics state and with draw parameters set from a
 buffer.
 This function is available since SDL 3.2.0.

 The buffer must consist of tightly-packed draw parameter sets that each
 match the layout of SDL_GPUIndirectDrawCommand. You must not call this
 function before binding a graphics pipeline.

 @param render_pass : `a render pass handle.`
 @param buffer : `a buffer containing draw parameters.`
 @param offset : `the offset to start reading from the draw buffer.`
 @param draw_count : `the number of draw parameter sets that should be read
                      from the draw buffer.`
*>
extern fn void SDLGPURenderPass.draw_primitives_indirect(&render_pass, SDLGPUBuffer* buffer, uint offset, uint draw_count) @extern("SDL_DrawGPUPrimitivesIndirect");

<*
 Draws data using bound graphics state with an index buffer enabled and with
 draw parameters set from a buffer.
 This function is available since SDL 3.2.0.

 The buffer must consist of tightly-packed draw parameter sets that each
 match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call
 this function before binding a graphics pipeline.

 @param render_pass : `a render pass handle.`
 @param buffer : `a buffer containing draw parameters.`
 @param offset : `the offset to start reading from the draw buffer.`
 @param draw_count : `the number of draw parameter sets that should be read
                      from the draw buffer.`
*>
extern fn void SDLGPURenderPass.draw_indexed_primitives_indirect(&render_pass, SDLGPUBuffer* buffer, uint offset, uint draw_count) @extern("SDL_DrawGPUIndexedPrimitivesIndirect");

<*
 Ends the given render pass.
 This function is available since SDL 3.2.0.

 All bound graphics state on the render pass command buffer is unset. The
 render pass handle is now invalid.

 @param render_pass : `a render pass handle.`
*>
extern fn void SDLGPURenderPass.end(&render_pass) @extern("SDL_EndGPURenderPass");

/* Compute Pass */

<*
 Begins a compute pass on a command buffer.
 This function is available since SDL 3.2.0.

 A compute pass is defined by a set of texture subresources and buffers that
 may be written to by compute pipelines. These textures and buffers must
 have been created with the COMPUTE_STORAGE_WRITE bit or the
 COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture
 with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the
 texture in the compute pass. All operations related to compute pipelines
 must take place inside of a compute pass. You must not begin another
 compute pass, or a render pass or copy pass before ending the compute pass.

 A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT
 implicitly synchronized. This means you may cause data races by both
 reading and writing a resource region in a compute pass, or by writing
 multiple times to a resource region. If your compute work depends on
 reading the completed output from a previous dispatch, you MUST end the
 current compute pass and begin a new one before you can safely access the
 data. Otherwise you will receive unexpected results. Reading and writing a
 texture in the same compute pass is only supported by specific texture
 formats. Make sure you check the format support!

 @param command_buffer : `a command buffer.`
 @param storage_texture_bindings : `an array of writeable storage texture
                                    binding structs.`
 @param num_storage_texture_bindings : `the number of storage textures to bind
                                        from the array.`
 @param storage_buffer_bindings : `an array of writeable storage buffer binding
                                   structs.`
 @param num_storage_buffer_bindings : `the number of storage buffers to bind
                                       from the array.`
 @return `a compute pass handle.`
*>
extern fn SDLGPUComputePass* SDLGPUCommandBuffer.begin_compute_pass(&command_buffer, SDLGPUStorageTextureReadWriteBinding* storage_texture_bindings, uint num_storage_texture_bindings, SDLGPUStorageBufferReadWriteBinding* storage_buffer_bindings, uint num_storage_buffer_bindings) @extern("SDL_BeginGPUComputePass");

<*
 Binds a compute pipeline on a command buffer for use in compute dispatch.
 This function is available since SDL 3.2.0.

 @param compute_pass : `a compute pass handle.`
 @param compute_pipeline : `a compute pipeline to bind.`
*>
extern fn void SDLGPUComputePass.bind_compute_pipeline(&compute_pass, SDLGPUComputePipeline* compute_pipeline) @extern("SDL_BindGPUComputePipeline");

<*
 Binds texture-sampler pairs for use on the compute shader.
 This function is available since SDL 3.2.0.

 The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param compute_pass : `a compute pass handle.`
 @param first_slot : `the compute sampler slot to begin binding from.`
 @param texture_sampler_bindings : `an array of texture-sampler binding
                                    structs.`
 @param num_bindings : `the number of texture-sampler bindings to bind from the
                        array.`
*>
extern fn void SDLGPUComputePass.bind_compute_samplers(&compute_pass, uint first_slot, SDLGPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings) @extern("SDL_BindGPUComputeSamplers");

<*
 Binds storage textures as readonly for use on the compute pipeline.
 This function is available since SDL 3.2.0.

 These textures must have been created with
 SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param compute_pass : `a compute pass handle.`
 @param first_slot : `the compute storage texture slot to begin binding from.`
 @param storage_textures : `an array of storage textures.`
 @param num_bindings : `the number of storage textures to bind from the array.`
*>
extern fn void SDLGPUComputePass.bind_compute_storage_textures(&compute_pass, uint first_slot, SDLGPUTexture** storage_textures, uint num_bindings) @extern("SDL_BindGPUComputeStorageTextures");

<*
 Binds storage buffers as readonly for use on the compute pipeline.
 This function is available since SDL 3.2.0.

 These buffers must have been created with
 SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.

 Be sure your shader is set up according to the requirements documented in
 SDL_CreateGPUShader().

 @param compute_pass : `a compute pass handle.`
 @param first_slot : `the compute storage buffer slot to begin binding from.`
 @param storage_buffers : `an array of storage buffer binding structs.`
 @param num_bindings : `the number of storage buffers to bind from the array.`
*>
extern fn void SDLGPUComputePass.bind_compute_storage_buffers(&compute_pass, uint first_slot, SDLGPUBuffer** storage_buffers, uint num_bindings) @extern("SDL_BindGPUComputeStorageBuffers");

<*
 Dispatches compute work.
 This function is available since SDL 3.2.0.

 You must not call this function before binding a compute pipeline.

 A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 the dispatches write to the same resource region as each other, there is no
 guarantee of which order the writes will occur. If the write order matters,
 you MUST end the compute pass and begin another one.

 @param compute_pass : `a compute pass handle.`
 @param groupcount_x : `number of local workgroups to dispatch in the X
                        dimension.`
 @param groupcount_y : `number of local workgroups to dispatch in the Y
                        dimension.`
 @param groupcount_z : `number of local workgroups to dispatch in the Z
                        dimension.`
*>
extern fn void SDLGPUComputePass.dispatch_compute(&compute_pass, uint groupcount_x, uint groupcount_y, uint groupcount_z) @extern("SDL_DispatchGPUCompute");

<*
 Dispatches compute work with parameters set from a buffer.
 This function is available since SDL 3.2.0.

 The buffer layout should match the layout of
 SDL_GPUIndirectDispatchCommand. You must not call this function before
 binding a compute pipeline.

 A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and
 the dispatches write to the same resource region as each other, there is no
 guarantee of which order the writes will occur. If the write order matters,
 you MUST end the compute pass and begin another one.

 @param compute_pass : `a compute pass handle.`
 @param buffer : `a buffer containing dispatch parameters.`
 @param offset : `the offset to start reading from the dispatch buffer.`
*>
extern fn void SDLGPUComputePass.dispatch_compute_indirect(&compute_pass, SDLGPUBuffer* buffer, uint offset) @extern("SDL_DispatchGPUComputeIndirect");

<*
 Ends the current compute pass.
 This function is available since SDL 3.2.0.

 All bound compute state on the command buffer is unset. The compute pass
 handle is now invalid.

 @param compute_pass : `a compute pass handle.`
*>
extern fn void SDLGPUComputePass.end(&compute_pass) @extern("SDL_EndGPUComputePass");

/* TransferBuffer Data */

<*
 Maps a transfer buffer into application address space.
 This function is available since SDL 3.2.0.

 You must unmap the transfer buffer before encoding upload commands. The
 memory is owned by the graphics driver - do NOT call SDL_free() on the
 returned pointer.

 @param device : `a GPU context.`
 @param transfer_buffer : `a transfer buffer.`
 @param cycle : `if true, cycles the transfer buffer if it is already bound.`
 @return `the address of the mapped transfer buffer memory, or NULL on
          failure; call SDL_GetError() for more information.`
*>
extern fn void* SDLGPUDevice.map_transfer_buffer(&device, SDLGPUTransferBuffer* transfer_buffer, bool cycle) @extern("SDL_MapGPUTransferBuffer");

<*
 Unmaps a previously mapped transfer buffer.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param transfer_buffer : `a previously mapped transfer buffer.`
*>
extern fn void SDLGPUDevice.unmap_transfer_buffer(&device, SDLGPUTransferBuffer* transfer_buffer) @extern("SDL_UnmapGPUTransferBuffer");

/* Copy Pass */

<*
 Begins a copy pass on a command buffer.
 This function is available since SDL 3.2.0.

 All operations related to copying to or from buffers or textures take place
 inside a copy pass. You must not begin another copy pass, or a render pass
 or compute pass before ending the copy pass.

 @param command_buffer : `a command buffer.`
 @return `a copy pass handle.`
*>
extern fn SDLGPUCopyPass* SDLGPUCommandBuffer.begin_copy_pass(&command_buffer) @extern("SDL_BeginGPUCopyPass");

<*
 Uploads data from a transfer buffer to a texture.
 This function is available since SDL 3.2.0.

 The upload occurs on the GPU timeline. You may assume that the upload has
 finished in subsequent commands.

 You must align the data in the transfer buffer to a multiple of the texel
 size of the texture format.

 @param copy_pass : `a copy pass handle.`
 @param source : `the source transfer buffer with image layout information.`
 @param destination : `the destination texture region.`
 @param cycle : `if true, cycles the texture if the texture is bound, otherwise
                 overwrites the data.`
*>
extern fn void SDLGPUCopyPass.upload_to_texture(&copy_pass, SDLGPUTextureTransferInfo* source, SDLGPUTextureRegion* destination, bool cycle) @extern("SDL_UploadToGPUTexture");

<*
 Uploads data from a transfer buffer to a buffer.
 This function is available since SDL 3.2.0.

 The upload occurs on the GPU timeline. You may assume that the upload has
 finished in subsequent commands.

 @param copy_pass : `a copy pass handle.`
 @param source : `the source transfer buffer with offset.`
 @param destination : `the destination buffer with offset and size.`
 @param cycle : `if true, cycles the buffer if it is already bound, otherwise
                 overwrites the data.`
*>
extern fn void SDLGPUCopyPass.upload_to_buffer(&copy_pass, SDLGPUTransferBufferLocation* source, SDLGPUBufferRegion* destination, bool cycle) @extern("SDL_UploadToGPUBuffer");

<*
 Performs a texture-to-texture copy.
 This function is available since SDL 3.2.0.

 This copy occurs on the GPU timeline. You may assume the copy has finished
 in subsequent commands.

 @param copy_pass : `a copy pass handle.`
 @param source : `a source texture region.`
 @param destination : `a destination texture region.`
 @param w : `the width of the region to copy.`
 @param h : `the height of the region to copy.`
 @param d : `the depth of the region to copy.`
 @param cycle : `if true, cycles the destination texture if the destination
                 texture is bound, otherwise overwrites the data.`
*>
extern fn void SDLGPUCopyPass.copy_texture_to_texture(&copy_pass, SDLGPUTextureLocation* source, SDLGPUTextureLocation* destination, uint w, uint h, uint d, bool cycle) @extern("SDL_CopyGPUTextureToTexture");

<*
 Performs a buffer-to-buffer copy.
 This function is available since SDL 3.2.0.

 This copy occurs on the GPU timeline. You may assume the copy has finished
 in subsequent commands.

 @param copy_pass : `a copy pass handle.`
 @param source : `the buffer and offset to copy from.`
 @param destination : `the buffer and offset to copy to.`
 @param size : `the length of the buffer to copy.`
 @param cycle : `if true, cycles the destination buffer if it is already bound,
                 otherwise overwrites the data.`
*>
extern fn void SDLGPUCopyPass.copy_buffer_to_buffer(&copy_pass, SDLGPUBufferLocation* source, SDLGPUBufferLocation* destination, uint size, bool cycle) @extern("SDL_CopyGPUBufferToBuffer");

<*
 Copies data from a texture to a transfer buffer on the GPU timeline.
 This function is available since SDL 3.2.0.

 This data is not guaranteed to be copied until the command buffer fence is
 signaled.

 @param copy_pass : `a copy pass handle.`
 @param source : `the source texture region.`
 @param destination : `the destination transfer buffer with image layout
                       information.`
*>
extern fn void SDLGPUCopyPass.download_from_texture(&copy_pass, SDLGPUTextureRegion* source, SDLGPUTextureTransferInfo* destination) @extern("SDL_DownloadFromGPUTexture");

<*
 Copies data from a buffer to a transfer buffer on the GPU timeline.
 This function is available since SDL 3.2.0.

 This data is not guaranteed to be copied until the command buffer fence is
 signaled.

 @param copy_pass : `a copy pass handle.`
 @param source : `the source buffer with offset and size.`
 @param destination : `the destination transfer buffer with offset.`
*>
extern fn void SDLGPUCopyPass.download_from_buffer(&copy_pass, SDLGPUBufferRegion* source, SDLGPUTransferBufferLocation* destination) @extern("SDL_DownloadFromGPUBuffer");

<*
 Ends the current copy pass.
 This function is available since SDL 3.2.0.

 @param copy_pass : `a copy pass handle.`
*>
extern fn void SDLGPUCopyPass.end(&copy_pass) @extern("SDL_EndGPUCopyPass");

<*
 Generates mipmaps for the given texture.
 This function is available since SDL 3.2.0.

 This function must not be called inside of any pass.

 @param command_buffer : `a command_buffer.`
 @param texture : `a texture with more than 1 mip level.`
*>
extern fn void SDLGPUCommandBuffer.generate_mipmaps_for_texture(&command_buffer, SDLGPUTexture* texture) @extern("SDL_GenerateMipmapsForGPUTexture");

<*
 Blits from a source texture region to a destination texture region.
 This function is available since SDL 3.2.0.

 This function must not be called inside of any pass.

 @param command_buffer : `a command buffer.`
 @param info : `the blit info struct containing the blit parameters.`
*>
extern fn void SDLGPUCommandBuffer.blit_texture(&command_buffer, SDLGPUBlitInfo* info) @extern("SDL_BlitGPUTexture");

/* Submission/Presentation */

<*
 Determines whether a swapchain composition is supported by the window.
 This function is available since SDL 3.2.0.

 The window must be claimed before calling this function.

 @param device : `a GPU context.`
 @param window : `an SDL_Window.`
 @param swapchain_composition : `the swapchain composition to check.`
 @return `true if supported, false if unsupported.`
*>
extern fn bool SDLGPUDevice.window_supports_swapchain_composition(&device, SDLWindow* window, SDLGPUSwapchainComposition swapchain_composition) @extern("SDL_WindowSupportsGPUSwapchainComposition");

<*
 Determines whether a presentation mode is supported by the window.
 This function is available since SDL 3.2.0.

 The window must be claimed before calling this function.

 @param device : `a GPU context.`
 @param window : `an SDL_Window.`
 @param present_mode : `the presentation mode to check.`
 @return `true if supported, false if unsupported.`
*>
extern fn bool SDLGPUDevice.window_supports_present_mode(&device, SDLWindow* window, SDLGPUPresentMode present_mode) @extern("SDL_WindowSupportsGPUPresentMode");

<*
 Claims a window, creating a swapchain structure for it.
 This function is available since SDL 3.2.0.

 This must be called before SDL_AcquireGPUSwapchainTexture is called using
 the window. You should only call this function from the thread that created
 the window.

 The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and
 SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain
 parameters, you must call SDL_SetGPUSwapchainParameters after claiming the
 window.

 threadsafety: This function should only be called from the thread that
               created the window.


 @param device : `a GPU context.`
 @param window : `an SDL_Window.`
 @return `true on success, or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.claim_window(&device, SDLWindow* window) @extern("SDL_ClaimWindowForGPUDevice");

<*
 Unclaims a window, destroying its swapchain structure.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param window : `an SDL_Window that has been claimed.`
*>
extern fn void SDLGPUDevice.release_window(&device, SDLWindow* window) @extern("SDL_ReleaseWindowFromGPUDevice");

<*
 Changes the swapchain parameters for the given claimed window.
 This function is available since SDL 3.2.0.

 This function will fail if the requested present mode or swapchain
 composition are unsupported by the device. Check if the parameters are
 supported via SDL_WindowSupportsGPUPresentMode /
 SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.

 SDL_GPU_PRESENTMODE_VSYNC with SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always
 supported.

 @param device : `a GPU context.`
 @param window : `an SDL_Window that has been claimed.`
 @param swapchain_composition : `the desired composition of the swapchain.`
 @param present_mode : `the desired present mode for the swapchain.`
 @return `true if successful, false on error; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.set_swapchain_parameters(&device, SDLWindow* window, SDLGPUSwapchainComposition swapchain_composition, SDLGPUPresentMode present_mode) @extern("SDL_SetGPUSwapchainParameters");

<*
 Configures the maximum allowed number of frames in flight.
 This function is available since SDL 3.2.0.

 The default value when the device is created is 2. This means that after
 you have submitted 2 frames for presentation, if the GPU has not finished
 working on the first frame, SDL_AcquireGPUSwapchainTexture() will fill the
 swapchain texture pointer with NULL, and
 SDL_WaitAndAcquireGPUSwapchainTexture() will block.

 Higher values increase throughput at the expense of visual latency. Lower
 values decrease visual latency at the expense of throughput.

 Note that calling this function will stall and flush the command queue to
 prevent synchronization issues.

 The minimum value of allowed frames in flight is 1, and the maximum is 3.

 @param device : `a GPU context.`
 @param allowed_frames_in_flight : `the maximum number of frames that can be
                                    pending on the GPU.`
 @return `true if successful, false on error; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.set_allowed_frames_in_flight(&device, uint allowed_frames_in_flight) @extern("SDL_SetGPUAllowedFramesInFlight");

<*
 Obtains the texture format of the swapchain for the given window.
 This function is available since SDL 3.2.0.

 Note that this format can change if the swapchain parameters change.

 @param device : `a GPU context.`
 @param window : `an SDL_Window that has been claimed.`
 @return `the texture format of the swapchain.`
*>
extern fn SDLGPUTextureFormat SDLGPUDevice.get_swapchain_texture_format(&device, SDLWindow* window) @extern("SDL_GetGPUSwapchainTextureFormat");

<*
 Acquire a texture to use in presentation.
 This function is available since SDL 3.2.0.

 When a swapchain texture is acquired on a command buffer, it will
 automatically be submitted for presentation when the command buffer is
 submitted. The swapchain texture should only be referenced by the command
 buffer used to acquire it.

 This function will fill the swapchain texture handle with NULL if too many
 frames are in flight. This is not an error.

 If you use this function, it is possible to create a situation where many
 command buffers are allocated while the rendering context waits for the GPU
 to catch up, which will cause memory usage to grow. You should use
 SDL_WaitAndAcquireGPUSwapchainTexture() unless you know what you are doing
 with timing.

 The swapchain texture is managed by the implementation and must not be
 freed by the user. You MUST NOT call this function from any thread other
 than the one that created the window.

 threadsafety: This function should only be called from the thread that
               created the window.


 @param command_buffer : `a command buffer.`
 @param window : `a window that has been claimed.`
 @param swapchain_texture : `a pointer filled in with a swapchain texture
                             handle.`
 @param swapchain_texture_width : `a pointer filled in with the swapchain
                                   texture width, may be NULL.`
 @param swapchain_texture_height : `a pointer filled in with the swapchain
                                    texture height, may be NULL.`
 @return `true on success, false on error; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUCommandBuffer.acquire_swapchain_texture(&command_buffer, SDLWindow* window, SDLGPUTexture** swapchain_texture, uint* swapchain_texture_width, uint* swapchain_texture_height) @extern("SDL_AcquireGPUSwapchainTexture");

<*
 Blocks the thread until a swapchain texture is available to be acquired.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called from the thread that
               created the window.


 @param device : `a GPU context.`
 @param window : `a window that has been claimed.`
 @return `true on success, false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.wait_for_swapchain(&device, SDLWindow* window) @extern("SDL_WaitForGPUSwapchain");

<*
 Blocks the thread until a swapchain texture is available to be acquired,
 and then acquires it.
 This function is available since SDL 3.2.0.

 When a swapchain texture is acquired on a command buffer, it will
 automatically be submitted for presentation when the command buffer is
 submitted. The swapchain texture should only be referenced by the command
 buffer used to acquire it. It is an error to call
 SDL_CancelGPUCommandBuffer() after a swapchain texture is acquired.

 This function can fill the swapchain texture handle with NULL in certain
 cases, for example if the window is minimized. This is not an error. You
 should always make sure to check whether the pointer is NULL before
 actually using it.

 The swapchain texture is managed by the implementation and must not be
 freed by the user. You MUST NOT call this function from any thread other
 than the one that created the window.

 The swapchain texture is write-only and cannot be used as a sampler or for
 another reading operation.

 threadsafety: This function should only be called from the thread that
               created the window.


 @param command_buffer : `a command buffer.`
 @param window : `a window that has been claimed.`
 @param swapchain_texture : `a pointer filled in with a swapchain texture
                             handle.`
 @param swapchain_texture_width : `a pointer filled in with the swapchain
                                   texture width, may be NULL.`
 @param swapchain_texture_height : `a pointer filled in with the swapchain
                                    texture height, may be NULL.`
 @return `true on success, false on error; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUCommandBuffer.wait_and_acquire_swapchain_texture(&command_buffer, SDLWindow* window, SDLGPUTexture** swapchain_texture, uint* swapchain_texture_width, uint* swapchain_texture_height) @extern("SDL_WaitAndAcquireGPUSwapchainTexture");

<*
 Submits a command buffer so its commands can be processed on the GPU.
 This function is available since SDL 3.2.0.

 It is invalid to use the command buffer after this is called.

 This must be called from the thread the command buffer was acquired on.

 All commands in the submission are guaranteed to begin executing before any
 command in a subsequent submission begins executing.

 @param command_buffer : `a command buffer.`
 @return `true on success, false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUCommandBuffer.submit(&command_buffer) @extern("SDL_SubmitGPUCommandBuffer");

<*
 Submits a command buffer so its commands can be processed on the GPU, and
 acquires a fence associated with the command buffer.
 This function is available since SDL 3.2.0.

 You must release this fence when it is no longer needed or it will cause a
 leak. It is invalid to use the command buffer after this is called.

 This must be called from the thread the command buffer was acquired on.

 All commands in the submission are guaranteed to begin executing before any
 command in a subsequent submission begins executing.

 @param command_buffer : `a command buffer.`
 @return `a fence associated with the command buffer, or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLGPUFence* SDLGPUCommandBuffer.submit_and_acquire_fence(&command_buffer) @extern("SDL_SubmitGPUCommandBufferAndAcquireFence");

<*
 Cancels a command buffer.
 This function is available since SDL 3.2.0.

 None of the enqueued commands are executed.

 It is an error to call this function after a swapchain texture has been
 acquired.

 This must be called from the thread the command buffer was acquired on.

 You must not reference the command buffer after calling this function.

 @param command_buffer : `a command buffer.`
 @return `true on success, false on error; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUCommandBuffer.cancel(&command_buffer) @extern("SDL_CancelGPUCommandBuffer");

<*
 Blocks the thread until the GPU is completely idle.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @return `true on success, false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.wait_for_idle(&device) @extern("SDL_WaitForGPUIdle");

<*
 Blocks the thread until the given fences are signaled.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param wait_all : `if 0, wait for any fence to be signaled, if 1, wait for all
                    fences to be signaled.`
 @param fences : `an array of fences to wait on.`
 @param num_fences : `the number of fences in the fences array.`
 @return `true on success, false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLGPUDevice.wait_for_fences(&device, bool wait_all, SDLGPUFence** fences, uint num_fences) @extern("SDL_WaitForGPUFences");

<*
 Checks the status of a fence.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param fence : `a fence.`
 @return `true if the fence is signaled, false if it is not.`
*>
extern fn bool SDLGPUDevice.query_fence(&device, SDLGPUFence* fence) @extern("SDL_QueryGPUFence");

<*
 Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.
 This function is available since SDL 3.2.0.

 You must not reference the fence after calling this function.

 @param device : `a GPU context.`
 @param fence : `a fence.`
*>
extern fn void SDLGPUDevice.release_fence(&device, SDLGPUFence* fence) @extern("SDL_ReleaseGPUFence");

/* Format Info */

<*
 Obtains the texel block size for a texture format.
 This function is available since SDL 3.2.0.

 @param format : `the texture format you want to know the texel size of.`
 @return `the texel block size of the texture format.`
*>
extern fn uint SDLGPUTextureFormat.texel_block_size(format) @extern("SDL_GPUTextureFormatTexelBlockSize");

<*
 Determines whether a texture format is supported for a given type and
 usage.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param format : `the texture format to check.`
 @param type : `the type of texture (2D, 3D, Cube).`
 @param usage : `a bitmask of all usage scenarios to check.`
 @return `whether the texture format is supported for this type and usage.`
*>
extern fn bool SDLGPUDevice.texture_supports_format(&device, SDLGPUTextureFormat format, SDLGPUTextureType type, SDLGPUTextureUsageFlags usage) @extern("SDL_GPUTextureSupportsFormat");

<*
 Determines if a sample count for a texture format is supported.
 This function is available since SDL 3.2.0.

 @param device : `a GPU context.`
 @param format : `the texture format to check.`
 @param sample_count : `the sample count to check.`
 @return `whether the sample count is supported for this texture format.`
*>
extern fn bool SDLGPUDevice.texture_supports_sample_count(&device, SDLGPUTextureFormat format, SDLGPUSampleCount sample_count) @extern("SDL_GPUTextureSupportsSampleCount");

<*
 Calculate the size in bytes of a texture format with dimensions.
 This function is available since SDL 3.2.0.

 @param format : `a texture format.`
 @param width : `width in pixels.`
 @param height : `height in pixels.`
 @param depth_or_layer_count : `depth for 3D textures or layer count otherwise.`
 @return `the size of a texture with this format and dimensions.`
*>
extern fn uint SDLGPUTextureFormat.calculate_size(format, uint width, uint height, uint depth_or_layer_count) @extern("SDL_CalculateGPUTextureFormatSize");

// TODO
// #ifdef SDL_PLATFORM_GDK

<*
 Call this to suspend GPU operation on Xbox when you receive the
 SDL_EVENT_DID_ENTER_BACKGROUND event.
 This function is available since SDL 3.2.0.

 Do NOT call any SDL_GPU functions after calling this function! This must
 also be called before calling SDL_GDKSuspendComplete.

 @param device : `a GPU context.`
*>
extern fn void SDLGPUDevice.gdk_suspend(&device) @extern("SDL_GDKSuspendGPU");

<*
 Call this to resume GPU operation on Xbox when you receive the
 SDL_EVENT_WILL_ENTER_FOREGROUND event.
 This function is available since SDL 3.2.0.

 When resuming, this function MUST be called before calling any other
 SDL_GPU functions.

 @param device : `a GPU context.`
*>
extern fn void SDLGPUDevice.gdk_resume(&device) @extern("SDL_GDKResumeGPU");
// #endif /* SDL_PLATFORM_GDK */
