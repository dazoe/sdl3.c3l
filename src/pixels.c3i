<*
 SDL offers facilities for pixel management.

 Largely these facilities deal with pixel _format_: what does this set of
 bits represent?

 If you mostly want to think of a pixel as some combination of red, green,
 blue, and maybe alpha intensities, this is all pretty straightforward, and
 in many cases, is enough information to build a perfectly fine game.

 However, the actual definition of a pixel is more complex than that:

 Pixels are a representation of a color in a particular color space.

 The first characteristic of a color space is the color type. SDL
 understands two different color types, RGB and YCbCr, or in SDL also
 referred to as YUV.

 RGB colors consist of red, green, and blue channels of color that are added
 together to represent the colors we see on the screen.

 https://en.wikipedia.org/wiki/RGB_color_model

 YCbCr colors represent colors as a Y luma brightness component and red and
 blue chroma color offsets. This color representation takes advantage of the
 fact that the human eye is more sensitive to brightness than the color in
 an image. The Cb and Cr components are often compressed and have lower
 resolution than the luma component.

 https://en.wikipedia.org/wiki/YCbCr

 When the color information in YCbCr is compressed, the Y pixels are left at
 full resolution and each Cr and Cb pixel represents an average of the color
 information in a block of Y pixels. The chroma location determines where in
 that block of pixels the color information is coming from.

 The color range defines how much of the pixel to use when converting a
 pixel into a color on the display. When the full color range is used, the
 entire numeric range of the pixel bits is significant. When narrow color
 range is used, for historical reasons, the pixel uses only a portion of the
 numeric range to represent colors.

 The color primaries and white point are a definition of the colors in the
 color space relative to the standard XYZ color space.

 https://en.wikipedia.org/wiki/CIE_1931_color_space

 The transfer characteristic, or opto-electrical transfer function (OETF),
 is the way a color is converted from mathematically linear space into a
 non-linear output signals.

 https://en.wikipedia.org/wiki/Rec._709#Transfer_characteristics

 The matrix coefficients are used to convert between YCbCr and RGB colors.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryPixels
*>
module sdl;

<*
 A fully opaque 8-bit alpha value.
 This macro is available since SDL 3.2.0.
*>
const ALPHA_OPAQUE = 255;

<*
 A fully opaque floating point alpha value.
 This macro is available since SDL 3.2.0.
*>
const ALPHA_OPAQUE_FLOAT = 1.0;

<*
 A fully transparent 8-bit alpha value.
 This macro is available since SDL 3.2.0.
*>
const ALPHA_TRANSPARENT = 0;

<*
 A fully transparent floating point alpha value.
 This macro is available since SDL 3.2.0.
*>
const ALPHA_TRANSPARENT_FLOAT = 0.0;

<*
 Pixel type.
 This enum is available since SDL 3.2.0.
*>
enum SDLPixelType : const CInt
{
    UNKNOWN,
    INDEX1,
    INDEX4,
    INDEX8,
    PACKED8,
    PACKED16,
    PACKED32,
    ARRAYU8,
    ARRAYU16,
    ARRAYU32,
    ARRAYF16,
    ARRAYF32,
    /* appended at the end for compatibility with sdl2-compat:  */
    INDEX2,
}

<*
 Bitmap pixel order, high bit -> low bit.
 This enum is available since SDL 3.2.0.
*>
enum SDLBitmapOrder : const CInt
{
    NONE,
    ORDER_4321,
    ORDER_1234,
}

<*
 Packed component order, high bit -> low bit.
 This enum is available since SDL 3.2.0.
*>
enum SDLPackedOrder : const CInt
{
    NONE,
    XRGB,
    RGBX,
    ARGB,
    RGBA,
    XBGR,
    BGRX,
    ABGR,
    BGRA,
}

<*
 Array component order, low byte -> high byte.
 This enum is available since SDL 3.2.0.
*>
enum SDLArrayOrder : const CInt
{
    NONE,
    RGB,
    RGBA,
    ARGB,
    BGR,
    BGRA,
    ABGR,
}

<*
 Packed component layout.
 This enum is available since SDL 3.2.0.
*>
enum SDLPackedLayout : const CInt
{
    NONE,
    LAYOUT_332,
    LAYOUT_4444,
    LAYOUT_1555,
    LAYOUT_5551,
    LAYOUT_565,
    LAYOUT_8888,
    LAYOUT_2101010,
    LAYOUT_1010102,
}

<*
 A macro for defining custom FourCC pixel formats.
 This macro is available since SDL 3.2.0.

 For example, defining SDL_PIXELFORMAT_YV12 looks like this:

 ```c
 SDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2')
 ```

 threadsafety: It is safe to call this macro from any thread.

 @param a : `the first character of the FourCC code.`
 @param b : `the second character of the FourCC code.`
 @param c : `the third character of the FourCC code.`
 @param d : `the fourth character of the FourCC code.`
 @return `a format value in the style of SDL_PixelFormat.`
*>
macro define_pixel_fourcc(a, b, c, d) => fourcc(a,b,c,d);

<*
 A macro for defining custom non-FourCC pixel formats.
 This macro is available since SDL 3.2.0.

 For example, defining SDL_PIXELFORMAT_RGBA8888 looks like this:

 ```c
 SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_8888, 32, 4)
 ```

 threadsafety: It is safe to call this macro from any thread.

 @param type : `the type of the new format, probably a SDL_PixelType value.`
 @param order : `the order of the new format, probably a SDL_BitmapOrder,
                 SDL_PackedOrder, or SDL_ArrayOrder value.`
 @param layout : `the layout of the new format, probably an SDL_PackedLayout
                  value or zero.`
 @param bits : `the number of bits per pixel of the new format.`
 @param bytes : `the number of bytes per pixel of the new format.`
 @returns `a format value in the style of SDL_PixelFormat.`
*>
macro SDLPixelFormat define_pixel_format(type, order, layout, bits, bytes) => (
    (1 << 28) | (type << 24) | (order << 20) | (layout << 16) |
    (bits << 8) | (bytes << 0)
);

<*
 A macro to retrieve the flags of an SDL_PixelFormat.
 This macro is available since SDL 3.2.0.

 This macro is generally not needed directly by an app, which should use
 specific tests, like SDL_ISPIXELFORMAT_FOURCC, instead.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `the flags of 'format'.`
*>
macro SDLPixelFormat.flag(format) => (format >> 28) & 0x0F;

<*
 A macro to retrieve the type of an SDL_PixelFormat.
 This macro is available since SDL 3.2.0.

 This is usually a value from the SDL_PixelType enumeration.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `the type of 'format'.`
*>
macro SDLPixelFormat.type(format) => (SDLPixelType)((format >> 24) & 0x0F);

<*
 A macro to retrieve the order of an SDL_PixelFormat.
 This macro is available since SDL 3.2.0.

 This is usually a value from the SDL_BitmapOrder, SDL_PackedOrder, or
 SDL_ArrayOrder enumerations, depending on the format type.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `the order of 'format'.`
*>
macro SDLPixelFormat.order(format) => ((format >> 20) & 0x0F);

<*
 A macro to retrieve the layout of an SDL_PixelFormat.
 This macro is available since SDL 3.2.0.

 This is usually a value from the SDL_PackedLayout enumeration, or zero if a
 layout doesn't make sense for the format type.

 threadsafety: It is safe to call this macro from any thread.

 @param format :  `an SDL_PixelFormat to check.`
 @return `the layout of 'format'.`
*>
macro SDLPackedLayout SDLPixelFormat.layout(format) =>
    (SDLPackedLayout)(format >> 16) & 0x0F;

<*
 A macro to determine an SDL_PixelFormat's bits per pixel.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 FourCC formats will report zero here, as it rarely makes sense to measure
 them per-pixel.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `the bits-per-pixel of 'format'.`
*>
macro char SDLPixelFormat.bits_per_pixel(format) => (
    (char)(format.is_fourcc() ? 0 : (format >> 8) & 0xFF));

<*
 A macro to determine an SDL_PixelFormat's bytes per pixel.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 FourCC formats do their best here, but many of them don't have a meaningful
 measurement of bytes per pixel.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `the bytes-per-pixel of 'format'.`
*>
macro char SDLPixelFormat.bytes_per_pixel(format) => (
    (char)(
        format.is_fourcc() ? (
            (
                (format == SDLPixelFormat.YUY2) ||
                (format == SDLPixelFormat.UYVY) ||
                (format == SDLPixelFormat.YVYU) ||
                (format == SDLPixelFormat.P010)
            ) ? 2 : 1
        ) : (
            format & 0xFF
        )
    )
);

<*
 A macro to determine if an SDL_PixelFormat is an indexed format.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format is indexed, false otherwise.`
*>
macro bool SDLPixelFormat.is_indexed(format) => (
    !format.is_fourcc() && (
        (format.type() == SDLPixelType.INDEX1) ||
        (format.type() == SDLPixelType.INDEX2) ||
        (format.type() == SDLPixelType.INDEX4) ||
        (format.type() == SDLPixelType.INDEX8)
    )
);

<*
 A macro to determine if an SDL_PixelFormat is a packed format.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format is packed, false otherwise.`
*>
macro bool SDLPixelFormat.is_packed(format) => (
    !format.is_fourcc() && (
        (format.type() == SDLPixelType.PACKED8) ||
        (format.type() == SDLPixelType.PACKED16) ||
        (format.type() == SDLPixelType.PACKED32)
    )
);

<*
 A macro to determine if an SDL_PixelFormat is an array format.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format is an array, false otherwise.`
*>
macro bool SDLPixelFormat.is_array(format) => (
    !format.is_fourcc() && (
        (format.type() == SDLPixelType.ARRAYU8) ||
        (format.type() == SDLPixelType.ARRAYU16) ||
        (format.type() == SDLPixelType.ARRAYU32) ||
        (format.type() == SDLPixelType.ARRAYF16) ||
        (format.type() == SDLPixelType.ARRAYF32)
    )
);

<*
 A macro to determine if an SDL_PixelFormat is a 10-bit format.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format is 10-bit, false otherwise.`
*>
macro bool SDLPixelFormat.is_10bit(format) => (
    !format.is_fourcc() && (
        (format.type() == SDLPixelType.PACKED32) &&
        (format.layout() == SDLPackedLayout.LAYOUT_2101010)
    )
);

<*
 A macro to determine if an SDL_PixelFormat is a floating point format.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format is 10-bit, false otherwise.`
*>
macro bool SDLPixelFormat.is_float(format) => (
    !format.is_fourcc() && (
        (format.type() == SDLPixelFormat.ARRAYF16) ||
        (format.type() == SDLPixelFormat.ARRAYF16)
    )
);

<*
 A macro to determine if an SDL_PixelFormat has an alpha channel.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format has alpha, false otherwise.`
*>
macro bool SDLPixelFormat.is_alpha(format) => (
    (
        format.is_packed() && (
            ((SDLPackedOrder)format.order() == SDLPackedOrder.ARGB) ||
            ((SDLPackedOrder)format.order() == SDLPackedOrder.RGBA) ||
            ((SDLPackedOrder)format.order() == SDLPackedOrder.ABGR) ||
            ((SDLPackedOrder)format.order() == SDLPackedOrder.BGRA)
        )
    ) || (
        format.is_array() && (
            ((SDLArrayOrder)format.order() == SDLArrayOrder.ARGB) ||
            ((SDLArrayOrder)format.order() == SDLArrayOrder.RGBA) ||
            ((SDLArrayOrder)format.order() == SDLArrayOrder.ABGR) ||
            ((SDLArrayOrder)format.order() == SDLArrayOrder.BGRA)
        )
    )
);

<*
 A macro to determine if an SDL_PixelFormat is a "FourCC" format.
 This macro is available since SDL 3.2.0.

 This covers custom and other unusual formats.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param format : `an SDL_PixelFormat to check.`
 @return `true if the format has alpha, false otherwise.`
*>
macro bool SDLPixelFormat.is_fourcc(format) => ((format) && (format.flag() != 1));
/* The flag is set to 1 because 0x1? is not in the printable ASCII range */

<*
 Pixel format.
 This enum is available since SDL 3.2.0.

 SDL's pixel formats have the following naming convention:

 - Names with a list of components and a single bit count, such as RGB24 and
   ABGR32, define a platform-independent encoding into bytes in the order
   specified. For example, in RGB24 data, each pixel is encoded in 3 bytes
   (red, green, blue) in that order, and in ABGR32 data, each pixel is
   encoded in 4 bytes (alpha, blue, green, red) in that order. Use these
   names if the property of a format that is important to you is the order
   of the bytes in memory or on disk.
 - Names with a bit count per component, such as ARGB8888 and XRGB1555, are
   "packed" into an appropriately-sized integer in the platform's native
   endianness. For example, ARGB8888 is a sequence of 32-bit integers; in
   each integer, the most significant bits are alpha, and the least
   significant bits are blue. On a little-endian CPU such as x86, the least
   significant bits of each integer are arranged first in memory, but on a
   big-endian CPU such as s390x, the most significant bits are arranged
   first. Use these names if the property of a format that is important to
   you is the meaning of each bit position within a native-endianness
   integer.
 - In indexed formats such as INDEX4LSB, each pixel is represented by
   encoding an index into the palette into the indicated number of bits,
   with multiple pixels packed into each byte if appropriate. In LSB
   formats, the first (leftmost) pixel is stored in the least-significant
   bits of the byte; in MSB formats, it's stored in the most-significant
   bits. INDEX8 does not need LSB/MSB variants, because each pixel exactly
   fills one byte.

 The 32-bit byte-array encodings such as RGBA32 are aliases for the
 appropriate 8888 encoding for the current platform. For example, RGBA32 is
 an alias for ABGR8888 on little-endian CPUs like x86, or an alias for
 RGBA8888 on big-endian CPUs.
*>
enum SDLPixelFormat : const CInt
{
    UNKNOWN = 0,
    INDEX1LSB = 0x11100100u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX1, SDL_BITMAPORDER_4321, 0, 1, 0), */
    INDEX1MSB = 0x11200100u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX1, SDL_BITMAPORDER_1234, 0, 1, 0), */
    INDEX2LSB = 0x1c100200u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX2, SDL_BITMAPORDER_4321, 0, 2, 0), */
    INDEX2MSB = 0x1c200200u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX2, SDL_BITMAPORDER_1234, 0, 2, 0), */
    INDEX4LSB = 0x12100400u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX4, SDL_BITMAPORDER_4321, 0, 4, 0), */
    INDEX4MSB = 0x12200400u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX4, SDL_BITMAPORDER_1234, 0, 4, 0), */
    INDEX8 = 0x13000801u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_INDEX8, 0, 0, 8, 1), */
    RGB332 = 0x14110801u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED8, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_332, 8, 1), */
    XRGB4444 = 0x15120c02u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_4444, 12, 2), */
    XBGR4444 = 0x15520c02u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XBGR, SDL_PACKEDLAYOUT_4444, 12, 2), */
    XRGB1555 = 0x15130f02u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_1555, 15, 2), */
    XBGR1555 = 0x15530f02u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XBGR, SDL_PACKEDLAYOUT_1555, 15, 2), */
    ARGB4444 = 0x15321002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_ARGB, SDL_PACKEDLAYOUT_4444, 16, 2), */
    RGBA4444 = 0x15421002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_4444, 16, 2), */
    ABGR4444 = 0x15721002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_ABGR, SDL_PACKEDLAYOUT_4444, 16, 2), */
    BGRA4444 = 0x15821002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_BGRA, SDL_PACKEDLAYOUT_4444, 16, 2), */
    ARGB1555 = 0x15331002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_ARGB, SDL_PACKEDLAYOUT_1555, 16, 2), */
    RGBA5551 = 0x15441002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_5551, 16, 2), */
    ABGR1555 = 0x15731002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_ABGR, SDL_PACKEDLAYOUT_1555, 16, 2), */
    BGRA5551 = 0x15841002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_BGRA, SDL_PACKEDLAYOUT_5551, 16, 2), */
    RGB565 = 0x15151002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_565, 16, 2), */
    BGR565 = 0x15551002u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED16, SDL_PACKEDORDER_XBGR, SDL_PACKEDLAYOUT_565, 16, 2), */
    RGB24 = 0x17101803u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU8, SDL_ARRAYORDER_RGB, 0, 24, 3), */
    BGR24 = 0x17401803u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU8, SDL_ARRAYORDER_BGR, 0, 24, 3), */
    XRGB8888 = 0x16161804u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_8888, 24, 4), */
    RGBX8888 = 0x16261804u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_RGBX, SDL_PACKEDLAYOUT_8888, 24, 4), */
    XBGR8888 = 0x16561804u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_XBGR, SDL_PACKEDLAYOUT_8888, 24, 4), */
    BGRX8888 = 0x16661804u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_BGRX, SDL_PACKEDLAYOUT_8888, 24, 4), */
    ARGB8888 = 0x16362004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_ARGB, SDL_PACKEDLAYOUT_8888, 32, 4), */
    RGBA8888 = 0x16462004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_RGBA, SDL_PACKEDLAYOUT_8888, 32, 4), */
    ABGR8888 = 0x16762004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_ABGR, SDL_PACKEDLAYOUT_8888, 32, 4), */
    BGRA8888 = 0x16862004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_BGRA, SDL_PACKEDLAYOUT_8888, 32, 4), */
    XRGB2101010 = 0x16172004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_XRGB, SDL_PACKEDLAYOUT_2101010, 32, 4), */
    XBGR2101010 = 0x16572004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_XBGR, SDL_PACKEDLAYOUT_2101010, 32, 4), */
    ARGB2101010 = 0x16372004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_ARGB, SDL_PACKEDLAYOUT_2101010, 32, 4), */
    ABGR2101010 = 0x16772004u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_PACKED32, SDL_PACKEDORDER_ABGR, SDL_PACKEDLAYOUT_2101010, 32, 4), */
    RGB48 = 0x18103006u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_RGB, 0, 48, 6), */
    BGR48 = 0x18403006u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_BGR, 0, 48, 6), */
    RGBA64 = 0x18204008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_RGBA, 0, 64, 8), */
    ARGB64 = 0x18304008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_ARGB, 0, 64, 8), */
    BGRA64 = 0x18504008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_BGRA, 0, 64, 8), */
    ABGR64 = 0x18604008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYU16, SDL_ARRAYORDER_ABGR, 0, 64, 8), */
    RGB48_FLOAT = 0x1a103006u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_RGB, 0, 48, 6), */
    BGR48_FLOAT = 0x1a403006u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_BGR, 0, 48, 6), */
    RGBA64_FLOAT = 0x1a204008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_RGBA, 0, 64, 8), */
    ARGB64_FLOAT = 0x1a304008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_ARGB, 0, 64, 8), */
    BGRA64_FLOAT = 0x1a504008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_BGRA, 0, 64, 8), */
    ABGR64_FLOAT = 0x1a604008u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF16, SDL_ARRAYORDER_ABGR, 0, 64, 8), */
    RGB96_FLOAT = 0x1b10600cu,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_RGB, 0, 96, 12), */
    BGR96_FLOAT = 0x1b40600cu,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_BGR, 0, 96, 12), */
    RGBA128_FLOAT = 0x1b208010u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_RGBA, 0, 128, 16), */
    ARGB128_FLOAT = 0x1b308010u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_ARGB, 0, 128, 16), */
    BGRA128_FLOAT = 0x1b508010u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_BGRA, 0, 128, 16), */
    ABGR128_FLOAT = 0x1b608010u,
        /* SDL_DEFINE_PIXELFORMAT(SDL_PIXELTYPE_ARRAYF32, SDL_ARRAYORDER_ABGR, 0, 128, 16), */

    YV12 = 0x32315659u,      /**< Planar mode: Y + V + U  (3 planes) */
        /* SDL_DEFINE_PIXELFOURCC('Y', 'V', '1', '2'), */
    IYUV = 0x56555949u,      /**< Planar mode: Y + U + V  (3 planes) */
        /* SDL_DEFINE_PIXELFOURCC('I', 'Y', 'U', 'V'), */
    YUY2 = 0x32595559u,      /**< Packed mode: Y0+U0+Y1+V0 (1 plane) */
        /* SDL_DEFINE_PIXELFOURCC('Y', 'U', 'Y', '2'), */
    UYVY = 0x59565955u,      /**< Packed mode: U0+Y0+V0+Y1 (1 plane) */
        /* SDL_DEFINE_PIXELFOURCC('U', 'Y', 'V', 'Y'), */
    YVYU = 0x55595659u,      /**< Packed mode: Y0+V0+Y1+U0 (1 plane) */
        /* SDL_DEFINE_PIXELFOURCC('Y', 'V', 'Y', 'U'), */
    NV12 = 0x3231564eu,      /**< Planar mode: Y + U/V interleaved  (2 planes) */
        /* SDL_DEFINE_PIXELFOURCC('N', 'V', '1', '2'), */
    NV21 = 0x3132564eu,      /**< Planar mode: Y + V/U interleaved  (2 planes) */
        /* SDL_DEFINE_PIXELFOURCC('N', 'V', '2', '1'), */
    P010 = 0x30313050u,      /**< Planar mode: Y + U/V interleaved  (2 planes) */
        /* SDL_DEFINE_PIXELFOURCC('P', '0', '1', '0'), */
    EXTERNAL_OES = 0x2053454fu,     /**< Android video texture format */
        /* SDL_DEFINE_PIXELFOURCC('O', 'E', 'S', ' ') */

    MJPG = 0x47504a4du,     /**< Motion JPEG */
        /* SDL_DEFINE_PIXELFOURCC('M', 'J', 'P', 'G') */

    /* Aliases for RGBA byte arrays of color data, for the current platform */
    RGBA32 = env::BIG_ENDIAN ? SDLPixelFormat.RGBA8888 : SDLPixelFormat.ABGR8888,
    ARGB32 = env::BIG_ENDIAN ? SDLPixelFormat.ARGB8888 : SDLPixelFormat.BGRA8888,
    BGRA32 = env::BIG_ENDIAN ? SDLPixelFormat.BGRA8888 : SDLPixelFormat.ARGB8888,
    ABGR32 = env::BIG_ENDIAN ? SDLPixelFormat.ABGR8888 : SDLPixelFormat.RGBA8888,
    RGBX32 = env::BIG_ENDIAN ? SDLPixelFormat.RGBX8888 : SDLPixelFormat.XBGR8888,
    XRGB32 = env::BIG_ENDIAN ? SDLPixelFormat.XRGB8888 : SDLPixelFormat.BGRX8888,
    BGRX32 = env::BIG_ENDIAN ? SDLPixelFormat.BGRX8888 : SDLPixelFormat.XRGB8888,
    XBGR32 = env::BIG_ENDIAN ? SDLPixelFormat.XBGR8888 : SDLPixelFormat.RGBX8888,
}

<*
 Colorspace color type.
 This enum is available since SDL 3.2.0.
*>
enum SDLColorType : const CInt
{
    UNKNOWN = 0,
    RGB = 1,
    YCBCR = 2,
}

<*
 Colorspace color range, as described by
 https://www.itu.int/rec/R-REC-BT.2100-2-201807-I/en
 This enum is available since SDL 3.2.0.
*>
enum SDLColorRange : const CInt
{
    UNKNOWN = 0,
    LIMITED = 1, /**< Narrow range, e.g. 16-235 for 8-bit RGB and luma, and 16-240 for 8-bit chroma */
    FULL = 2,    /**< Full range, e.g. 0-255 for 8-bit RGB and luma, and 1-255 for 8-bit chroma */
}

<*
 Colorspace color primaries, as described by
 https://www.itu.int/rec/T-REC-H.273-201612-S/en
 This enum is available since SDL 3.2.0.
*>
enum SDLColorPrimaries : const CInt
{
    UNKNOWN = 0,
    BT709 = 1,                  /**< ITU-R BT.709-6 */
    UNSPECIFIED = 2,
    BT470M = 4,                 /**< ITU-R BT.470-6 System M */
    BT470BG = 5,                /**< ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625 */
    BT601 = 6,                  /**< ITU-R BT.601-7 525, SMPTE 170M */
    SMPTE240 = 7,               /**< SMPTE 240M, functionally the same as SDL_COLOR_PRIMARIES_BT601 */
    GENERIC_FILM = 8,           /**< Generic film (color filters using Illuminant C) */
    BT2020 = 9,                 /**< ITU-R BT.2020-2 / ITU-R BT.2100-0 */
    XYZ = 10,                   /**< SMPTE ST 428-1 */
    SMPTE431 = 11,              /**< SMPTE RP 431-2 */
    SMPTE432 = 12,              /**< SMPTE EG 432-1 / DCI P3 */
    EBU3213 = 22,               /**< EBU Tech. 3213-E */
    CUSTOM = 31,
}

<*
 Colorspace transfer characteristics.
 This enum is available since SDL 3.2.0.

 These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
*>
enum SDLTransferCharacteristics : const CInt
{
    UNKNOWN = 0,
    BT709 = 1,         /**< Rec. ITU-R BT.709-6 / ITU-R BT1361 */
    UNSPECIFIED = 2,
    GAMMA22 = 4,       /**< ITU-R BT.470-6 System M / ITU-R BT1700 625 PAL & SECAM */
    GAMMA28 = 5,       /**< ITU-R BT.470-6 System B, G */
    BT601 = 6,         /**< SMPTE ST 170M / ITU-R BT.601-7 525 or 625 */
    SMPTE240 = 7,      /**< SMPTE ST 240M */
    LINEAR = 8,
    LOG100 = 9,
    LOG100_SQRT10 = 10,
    IEC61966 = 11,     /**< IEC 61966-2-4 */
    BT1361 = 12,       /**< ITU-R BT1361 Extended Colour Gamut */
    SRGB = 13,         /**< IEC 61966-2-1 (sRGB or sYCC) */
    BT2020_10BIT = 14, /**< ITU-R BT2020 for 10-bit system */
    BT2020_12BIT = 15, /**< ITU-R BT2020 for 12-bit system */
    PQ = 16,           /**< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems */
    SMPTE428 = 17,     /**< SMPTE ST 428-1 */
    HLG = 18,          /**< ARIB STD-B67, known as "hybrid log-gamma" (HLG) */
    CUSTOM = 31,
}

<*
 Colorspace matrix coefficients.
 This enum is available since SDL 3.2.0.

 These are as described by https://www.itu.int/rec/T-REC-H.273-201612-S/en
*>
enum SDLMatrixCoefficients : const CInt
{
    IDENTITY = 0,
    BT709 = 1,              /**< ITU-R BT.709-6 */
    UNSPECIFIED = 2,
    FCC = 4,                /**< US FCC Title 47 */
    BT470BG = 5,            /**< ITU-R BT.470-6 System B, G / ITU-R BT.601-7 625, functionally the same as SDL_MATRIX_COEFFICIENTS_BT601 */
    BT601 = 6,              /**< ITU-R BT.601-7 525 */
    SMPTE240 = 7,           /**< SMPTE 240M */
    YCGCO = 8,
    BT2020_NCL = 9,         /**< ITU-R BT.2020-2 non-constant luminance */
    BT2020_CL = 10,         /**< ITU-R BT.2020-2 constant luminance */
    SMPTE2085 = 11,         /**< SMPTE ST 2085 */
    CHROMA_DERIVED_NCL = 12,
    CHROMA_DERIVED_CL = 13,
    ICTCP = 14,             /**< ITU-R BT.2100-0 ICTCP */
    CUSTOM = 31,
}

<*
 Colorspace chroma sample location.
 This enum is available since SDL 3.2.0.
*>
enum SDLChromaLocation : const CInt
{
    NONE = 0,   /**< RGB, no chroma sampling */
    LEFT = 1,   /**< In MPEG-2, MPEG-4, and AVC, Cb and Cr are taken on midpoint of the left-edge of the 2x2 square. In other words, they have the same horizontal location as the top-left pixel, but is shifted one-half pixel down vertically. */
    CENTER = 2, /**< In JPEG/JFIF, H.261, and MPEG-1, Cb and Cr are taken at the center of the 2x2 square. In other words, they are offset one-half pixel to the right and one-half pixel down compared to the top-left pixel. */
    TOPLEFT = 3, /**< In HEVC for BT.2020 and BT.2100 content (in particular on Blu-rays), Cb and Cr are sampled at the same location as the group's top-left Y pixel ("co-sited", "co-located"). */
}

/* Colorspace definition */

<*
 A macro for defining custom SDL_Colorspace formats.
 This macro is available since SDL 3.2.0.

 For example, defining SDL_COLORSPACE_SRGB looks like this:

 ```c
 SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,
                       SDL_COLOR_RANGE_FULL,
                       SDL_COLOR_PRIMARIES_BT709,
                       SDL_TRANSFER_CHARACTERISTICS_SRGB,
                       SDL_MATRIX_COEFFICIENTS_IDENTITY,
                       SDL_CHROMA_LOCATION_NONE)
 ```

 threadsafety: It is safe to call this macro from any thread.

 @param type : `the type of the new format, probably an SDL_ColorType value.`
 @param range : `the range of the new format, probably a SDL_ColorRange value.`
 @param primaries : `the primaries of the new format, probably an
                     SDL_ColorPrimaries value.`
 @param transfer : `the transfer characteristics of the new format, probably an
                    SDL_TransferCharacteristics value.`
 @param matrix : `the matrix coefficients of the new format, probably an
                  SDL_MatrixCoefficients value.`
 @param chroma : `the chroma sample location of the new format, probably an
                  SDL_ChromaLocation value.`
 @return `a format value in the style of SDL_Colorspace.`
*>
macro SDLColorspace define_colorspace(type, range, primaries, transfer, matrix, chroma) => (
    ((uint)(type) << 28) | ((uint)(range) << 24) | ((uint)(chroma) << 20) |
    ((uint)(primaries) << 10) | ((uint)(transfer) << 5) | ((uint)(matrix) << 0)
);

<*
 A macro to retrieve the type of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_ColorType for 'cspace'.`
*>
macro SDLColorType type(cspace) => (SDLColorType)(((cspace) >> 28) & 0x0F);

<*
 A macro to retrieve the range of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_ColorRange of 'cspace'.`
*>
macro SDLColorRange range(cspace) => (SDLColorRange)(((cspace) >> 24) & 0x0F);

<*
 A macro to retrieve the chroma sample location of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_ChromaLocation of 'cspace'.`
*>
macro SDLChromaLocation SDLColorspace.chroma(cspace) => (cspace >> 20) & 0x0F;

<*
 A macro to retrieve the primaries of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_ColorPrimaries of 'cspace'.`

*>
macro SDLColorPrimaries SDLColorspace.primaries(cspace) => (cspace >> 10) & 0x1F;

<*
 A macro to retrieve the transfer characteristics of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_TransferCharacteristics of 'cspace'.`
*>
macro SDLTransferCharacteristics SDLColorspace.transfer(cspace) => (cspace >> 5) & 0x1F;

<*
 A macro to retrieve the matrix coefficients of an SDL_Colorspace.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `the SDL_MatrixCoefficients of 'cspace'.`
*>
macro SDLMatrixCoefficients SDLColorspace.matrix(cspace) => cspace & 0x1F;

<*
 A macro to determine if an SDL_Colorspace uses BT601 (or BT470BG) matrix
 coefficients.
 This macro is available since SDL 3.2.0.

 Note that this macro double-evaluates its parameter, so do not use
 expressions with side-effects here.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `true if BT601 or BT470BG, false otherwise.`

*>
macro bool SDLColorspace.is_matrix(cspace) => (
    cspace.matrix == SDLMatrixCoefficients.BT601 ||
    cspace.matrix == SDLMatrixCoefficients.BT470BG
);

<*
 A macro to determine if an SDL_Colorspace uses BT709 matrix coefficients.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `true if BT709, false otherwise.`
*>
macro bool SDLColorspace.is_matrix_bt709(cspace) => (
    cspace.matrix() == SDLMatrixCoefficients.BT709
);

<*
 A macro to determine if an SDL_Colorspace uses BT2020_NCL matrix
 coefficients.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `true if BT2020_NCL, false otherwise.`
*>
macro bool SDLColorspace.is_matrix_bt2020_ncl(cspace) => (
    cspace.matrix() == SDLMatrixCoefficients.BT2020_NCL
);

<*
 A macro to determine if an SDL_Colorspace has a limited range.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `true if limited range, false otherwise.`
*>
macro bool SDLColorspace.is_limited_range(cspace) => (
    cspace.range() != SDLColorRange.FULL
);

<*
 A macro to determine if an SDL_Colorspace has a full range.
 This macro is available since SDL 3.2.0.

 threadsafety: It is safe to call this macro from any thread.

 @param cspace : `an SDL_Colorspace to check.`
 @return `true if full range, false otherwise.`
*>
macro bool SDLColorspace.is_full_range(cspace) => (
    cspace.range() == SDLColorRange.FULL
);

<*
 Colorspace definitions.
 This enum is available since SDL 3.2.0.

 Since similar colorspaces may vary in their details (matrix, transfer
 function, etc.), this is not an exhaustive list, but rather a
 representative sample of the kinds of colorspaces supported in SDL.
*>
enum SDLColorspace : const CInt
{
    UNKNOWN = 0,

    /* sRGB is a gamma corrected colorspace, and the default colorspace for SDL rendering and 8-bit RGB surfaces */
    SRGB = 0x120005a0u, /**< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G22_NONE_P709 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT709,
                                 SDL_TRANSFER_CHARACTERISTICS_SRGB,
                                 SDL_MATRIX_COEFFICIENTS_IDENTITY,
                                 SDL_CHROMA_LOCATION_NONE), */

    /* This is a linear colorspace and the default colorspace for floating point surfaces. On Windows this is the scRGB colorspace, and on Apple platforms this is kCGColorSpaceExtendedLinearSRGB for EDR content */
    SRGB_LINEAR = 0x12000500u, /**< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G10_NONE_P709  */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT709,
                                 SDL_TRANSFER_CHARACTERISTICS_LINEAR,
                                 SDL_MATRIX_COEFFICIENTS_IDENTITY,
                                 SDL_CHROMA_LOCATION_NONE), */

    /* HDR10 is a non-linear HDR colorspace and the default colorspace for 10-bit surfaces */
    HDR10 = 0x12002600u, /**< Equivalent to DXGI_COLOR_SPACE_RGB_FULL_G2084_NONE_P2020  */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_RGB,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT2020,
                                 SDL_TRANSFER_CHARACTERISTICS_PQ,
                                 SDL_MATRIX_COEFFICIENTS_IDENTITY,
                                 SDL_CHROMA_LOCATION_NONE), */

    JPEG = 0x220004c6u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_NONE_P709_X601 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT709,
                                 SDL_TRANSFER_CHARACTERISTICS_BT601,
                                 SDL_MATRIX_COEFFICIENTS_BT601,
                                 SDL_CHROMA_LOCATION_NONE), */

    BT601_LIMITED = 0x211018c6u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_LIMITED,
                                 SDL_COLOR_PRIMARIES_BT601,
                                 SDL_TRANSFER_CHARACTERISTICS_BT601,
                                 SDL_MATRIX_COEFFICIENTS_BT601,
                                 SDL_CHROMA_LOCATION_LEFT), */

    BT601_FULL = 0x221018c6u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P601 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT601,
                                 SDL_TRANSFER_CHARACTERISTICS_BT601,
                                 SDL_MATRIX_COEFFICIENTS_BT601,
                                 SDL_CHROMA_LOCATION_LEFT), */

    BT709_LIMITED = 0x21100421u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_LIMITED,
                                 SDL_COLOR_PRIMARIES_BT709,
                                 SDL_TRANSFER_CHARACTERISTICS_BT709,
                                 SDL_MATRIX_COEFFICIENTS_BT709,
                                 SDL_CHROMA_LOCATION_LEFT), */

    BT709_FULL = 0x22100421u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P709 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT709,
                                 SDL_TRANSFER_CHARACTERISTICS_BT709,
                                 SDL_MATRIX_COEFFICIENTS_BT709,
                                 SDL_CHROMA_LOCATION_LEFT), */

    BT2020_LIMITED = 0x21102609u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_STUDIO_G22_LEFT_P2020 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_LIMITED,
                                 SDL_COLOR_PRIMARIES_BT2020,
                                 SDL_TRANSFER_CHARACTERISTICS_PQ,
                                 SDL_MATRIX_COEFFICIENTS_BT2020_NCL,
                                 SDL_CHROMA_LOCATION_LEFT), */

    BT2020_FULL = 0x22102609u, /**< Equivalent to DXGI_COLOR_SPACE_YCBCR_FULL_G22_LEFT_P2020 */
        /* SDL_DEFINE_COLORSPACE(SDL_COLOR_TYPE_YCBCR,
                                 SDL_COLOR_RANGE_FULL,
                                 SDL_COLOR_PRIMARIES_BT2020,
                                 SDL_TRANSFER_CHARACTERISTICS_PQ,
                                 SDL_MATRIX_COEFFICIENTS_BT2020_NCL,
                                 SDL_CHROMA_LOCATION_LEFT), */

    RGB_DEFAULT = SDLColorspace.SRGB, /**< The default colorspace for RGB surfaces if no colorspace is specified */
    YUV_DEFAULT = SDLColorspace.JPEG,  /**< The default colorspace for YUV surfaces if no colorspace is specified */
}

<*
 A structure that represents a color as RGBA components.
 This struct is available since SDL 3.2.0.

 The bits of this structure can be directly reinterpreted as an
 integer-packed color which uses the SDL_PIXELFORMAT_RGBA32 format
 (SDL_PIXELFORMAT_ABGR8888 on little-endian systems and
 SDL_PIXELFORMAT_RGBA8888 on big-endian systems).
*>
struct SDLColor
{
    char r;
    char g;
    char b;
    char a;
}

<*
 The bits of this structure can be directly reinterpreted as a float-packed
 color which uses the SDL_PIXELFORMAT_RGBA128_FLOAT format
 This struct is available since SDL 3.2.0.
*>
struct SDLFColor
{
    float r;
    float g;
    float b;
    float a;
}

<*
 A set of indexed colors representing a palette.
 This struct is available since SDL 3.2.0.
*>
struct SDLPalette
{
    CInt ncolors;        /**< number of elements in `colors`. */
    SDLColor* colors;  /**< an array of colors, `ncolors` long. */
    uint version;     /**< internal use only, do not touch. */
    CInt refcount;       /**< internal use only, do not touch. */
}

<*
 Details about the format of a pixel.
 This struct is available since SDL 3.2.0.
*>
struct SDLPixelFormatDetails
{
    SDLPixelFormat format;
    char bits_per_pixel;
    char bytes_per_pixel;
    char[2] padding;
    uint rmask;
    uint gmask;
    uint bmask;
    uint amask;
    char rbits;
    char gbits;
    char bbits;
    char abits;
    char rshift;
    char gshift;
    char bshift;
    char ashift;
}

<*
 Get the human readable name of a pixel format.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param format : `the pixel format to query.`
 @return `the human readable name of the specified pixel format or
          "SDL_PIXELFORMAT_UNKNOWN" if the format isn't recognized.`
*>
extern fn ZString SDLPixelFormat.get_name(format) @extern("SDL_GetPixelFormatName");

<*
 Convert one of the enumerated pixel formats to a bpp value and RGBA masks.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param format : `one of the SDL_PixelFormat values.`
 @param bpp : `a bits per pixel value; usually 15, 16, or 32.`
 @param rmask : `a pointer filled in with the red mask for the format.`
 @param gmask : `a pointer filled in with the green mask for the format.`
 @param bmask : `a pointer filled in with the blue mask for the format.`
 @param amask : `a pointer filled in with the alpha mask for the format.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLPixelFormat.get_masks(format, CInt* bpp, uint* rmask, uint* gmask, uint* bmask, uint* amask) @extern("SDL_GetMasksForPixelFormat");

<*
 Convert a bpp value and RGBA masks to an enumerated pixel format.
 This function is available since SDL 3.2.0.

 This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't
 possible.

 threadsafety: It is safe to call this function from any thread.

 @param bpp : `a bits per pixel value; usually 15, 16, or 32.`
 @param rmask : `the red mask for the format.`
 @param gmask : `the green mask for the format.`
 @param bmask : `the blue mask for the format.`
 @param amask : `the alpha mask for the format.`
 @return `the SDL_PixelFormat value corresponding to the format masks, or
          SDL_PIXELFORMAT_UNKNOWN if there isn't a match.`
*>
extern fn SDLPixelFormat get_pixel_format_for_masks(CInt bpp, uint rmask, uint gmask, uint bmask, uint amask) @extern("SDL_GetPixelFormatForMasks");

<*
 Create an SDL_PixelFormatDetails structure corresponding to a pixel format.
 This function is available since SDL 3.2.0.

 Returned structure may come from a shared global cache (i.e. not newly
 allocated), and hence should not be modified, especially the palette. Weird
 errors such as `Blit combination not supported` may occur.

 threadsafety: It is safe to call this function from any thread.

 @param format : `one of the SDL_PixelFormat values.`
 @return `a pointer to a SDL_PixelFormatDetails structure or NULL on
          failure; call SDL_GetError() for more information.`
*>
extern fn SDLPixelFormatDetails* SDLPixelFormat.get_details(format) @extern("SDL_GetPixelFormatDetails");

<*
 Create a palette structure with the specified number of color entries.
 This function is available since SDL 3.2.0.

 The palette entries are initialized to white.

 threadsafety: It is safe to call this function from any thread.

 @param ncolors : `represents the number of color entries in the color palette.`
 @return `a new SDL_Palette structure on success or NULL on failure (e.g. if
          there wasn't enough memory); call SDL_GetError() for more
          information.`
*>
extern fn SDLPalette* create_palette(CInt ncolors) @extern("SDL_CreatePalette");

<*
 Set a range of colors in a palette.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread, as long as
               the palette is not modified or destroyed in another thread.

 @param palette : `the SDL_Palette structure to modify.`
 @param colors : `an array of SDL_Color structures to copy into the palette.`
 @param firstcolor : `the index of the first palette entry to modify.`
 @param ncolors : `the number of entries to modify.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLPalette.set_colors(&palette, SDLColor* colors, CInt firstcolor, CInt ncolors) @extern("SDL_SetPaletteColors");

<*
 Free a palette created with SDL_CreatePalette().
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread, as long as
               the palette is not modified or destroyed in another thread.

 @param palette : `the SDL_Palette structure to be freed.`
*>
extern fn void SDLPalette.destroy(&palette) @extern("SDL_DestroyPalette");

<*
 Map an RGB triple to an opaque pixel value for a given pixel format.
 This function is available since SDL 3.2.0.

 This function maps the RGB color value to the specified pixel format and
 returns the pixel value best approximating the given RGB color value for
 the given pixel format.

 If the format has a palette (8-bit) the index of the closest matching color
 in the palette will be returned.

 If the specified pixel format has an alpha component it will be returned as
 all 1 bits (fully opaque).

 If the pixel format bpp (color depth) is less than 32-bpp then the unused
 upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 format the return value can be assigned to a Uint16, and similarly a Uint8
 for an 8-bpp format).

 threadsafety: It is safe to call this function from any thread, as long as
               the palette is not modified.

 @param format : `a pointer to SDL_PixelFormatDetails describing the pixel
                  format.`
 @param palette : `an optional palette for indexed formats, may be NULL.`
 @param r : `the red component of the pixel in the range 0-255.`
 @param g : `the green component of the pixel in the range 0-255.`
 @param b : `the blue component of the pixel in the range 0-255.`
 @return `a pixel value.`
*>
extern fn uint map_rgb(SDLPixelFormatDetails*  format, SDLPalette* palette, char r, char g, char b) @extern("SDL_MapRGB");

<*
 Map an RGBA quadruple to a pixel value for a given pixel format.
 This function is available since SDL 3.2.0.

 This function maps the RGBA color value to the specified pixel format and
 returns the pixel value best approximating the given RGBA color value for
 the given pixel format.

 If the specified pixel format has no alpha component the alpha value will
 be ignored (as it will be in formats with a palette).

 If the format has a palette (8-bit) the index of the closest matching color
 in the palette will be returned.

 If the pixel format bpp (color depth) is less than 32-bpp then the unused
 upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 format the return value can be assigned to a Uint16, and similarly a Uint8
 for an 8-bpp format).

 threadsafety: It is safe to call this function from any thread, as long as
               the palette is not modified.

 @param format : `a pointer to SDL_PixelFormatDetails describing the pixel
                  format.`
 @param palette : `an optional palette for indexed formats, may be NULL.`
 @param r : `the red component of the pixel in the range 0-255.`
 @param g : `the green component of the pixel in the range 0-255.`
 @param b : `the blue component of the pixel in the range 0-255.`
 @param a : `the alpha component of the pixel in the range 0-255.`
 @return `a pixel value.`
*>
extern fn uint map_rgba(SDLPixelFormatDetails* format, SDLPalette* palette, char r, char g, char b, char a) @extern("SDL_MapRGBA");

<*
 Get RGB values from a pixel in the specified format.
 This function is available since SDL 3.2.0.

 This function uses the entire 8-bit [0..255] range when converting color
 components from pixel formats with less than 8-bits per RGB component
 (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).

 threadsafety: It is safe to call this function from any thread, as long as
               the palette is not modified.

 @param pixel: `a pixel value.`
 @param format: `a pointer to SDL_PixelFormatDetails describing the pixel
                 format.`
 @param palette: `an optional palette for indexed formats, may be NULL.`
 @param r: `a pointer filled in with the red component, may be NULL.`
 @param g: `a pointer filled in with the green component, may be NULL.`
 @param b: `a pointer filled in with the blue component, may be NULL.`
*>
extern fn void get_rgb(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, char* r, char* g, char* b) @extern("SDL_Get_RGB");

<*
 Get RGBA values from a pixel in the specified format.
 This function is available since SDL 3.2.0.

 This function uses the entire 8-bit [0..255] range when converting color
 components from pixel formats with less than 8-bits per RGB component
 (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,
 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).

 If the surface has no alpha component, the alpha will be returned as 0xff
 (100% opaque).

 threadsafety It is safe to call this function from any thread, as long as
               the palette is not modified.

 @param pixel : `a pixel value.`
 @param format : `a pointer to SDL_PixelFormatDetails describing the pixel
                  format.`
 @param palette : `an optional palette for indexed formats, may be NULL.`
 @param r : `a pointer filled in with the red component, may be NULL.`
 @param g : `a pointer filled in with the green component, may be NULL.`
 @param b : `a pointer filled in with the blue component, may be NULL.`
 @param a : `a pointer filled in with the alpha component, may be NULL.`
*>
extern fn void get_rgba(uint pixel, SDLPixelFormatDetails* format, SDLPalette* palette, char* r, char* g, char* b, char* a) @extern("SDL_Get_RGBA");
