<*
 SDL surfaces are buffers of pixels in system RAM. These are useful for
 passing around and manipulating images that are not stored in GPU memory.

 SDL_Surface makes serious efforts to manage images in various formats, and
 provides a reasonable toolbox for transforming the data, including copying
 between surfaces, filling rectangles in the image data, etc.

 There is also a simple .bmp loader, SDL_LoadBMP(). SDL itself does not
 provide loaders for various other file formats, but there are several
 excellent external libraries that do, including its own satellite library,
 SDL_image:

 https://github.com/libsdl-org/SDL_image

 For more information, see
 https://wiki.libsdl.org/SDL3/CategorySurface
*>
module sdl;

<*
 The flags on an SDL_Surface.
 This datatype is available since SDL 3.2.0.

 These are generally considered read-only.
*>
typedef SDLSurfaceFlags = uint;

const SURFACE_PREALLOCATED    = 0x00000001u; /**< Surface uses preallocated pixel memory */
const SURFACE_LOCK_NEEDED     = 0x00000002u; /**< Surface needs to be locked to access pixels */
const SURFACE_LOCKED          = 0x00000004u; /**< Surface is currently locked */
const SURFACE_SIMD_ALIGNED    = 0x00000008u; /**< Surface uses pixel memory allocated with SDL_aligned_alloc() */

<*
 Evaluates to true if the surface needs to be locked before access.
 This macro is available since SDL 3.2.0.
*>
macro SDLSurfaceFlags.mustlock(x)
{
    return (x & SURFACE_LOCK_NEEDED) == SURFACE_LOCK_NEEDED;
}

<*
 The scaling mode.
 This enum is available since SDL 3.2.0.
*>
enum SDLScaleMode : const CInt
{
    INVALID = -1,
    NEAREST, /**< nearest pixel sampling */
    LINEAR,   /**< linear filtering */
}

<*
 The flip mode.
 This enum is available since SDL 3.2.0.
*>
enum SDLFlipMode : const CInt
{
    NONE,          /**< Do not flip */
    HORIZONTAL,    /**< flip horizontally */
    VERTICAL,       /**< flip vertically */
}

<*
 A collection of pixels used in software blitting.
 This struct is available since SDL 3.2.0.

 Pixels are arranged in memory in rows, with the top row first. Each row
 occupies an amount of memory given by the pitch (sometimes known as the row
 stride in non-SDL APIs).

 Within each row, pixels are arranged from left to right until the width is
 reached. Each pixel occupies a number of bits appropriate for its format,
 with most formats representing each pixel as one or more whole bytes (in
 some indexed formats, instead multiple pixels are packed into each byte),
 and a byte order given by the format. After encoding all pixels, any
 remaining bytes to reach the pitch are used as padding to reach a desired
 alignment, and have undefined contents.

 When a surface holds YUV format data, the planes are assumed to be
 contiguous without padding between them, e.g. a 32x32 surface in NV12
 format with a pitch of 32 would consist of 32x32 bytes of Y plane followed
 by 32x16 bytes of UV plane.

 When a surface holds MJPG format data, pixels points at the compressed JPEG
 image and pitch is the length of that data.
*>

struct SDLSurface
{
    SDLSurfaceFlags flags;     /**< The flags of the surface, read-only */
    SDLPixelFormat format;     /**< The format of the surface, read-only */
    CInt w;                      /**< The width of the surface, read-only. */
    CInt h;                      /**< The height of the surface, read-only. */
    CInt pitch;                  /**< The distance in bytes between rows of pixels, read-only */
    void* pixels;               /**< A pointer to the pixels of the surface, the pixels are writeable if non-NULL */
 
    CInt refcount;               /**< Application reference count, used when freeing surface */
 
    void* reserved;             /**< Reserved for internal use */
}

<*
 Allocate a new surface with a specific pixel format.
 This function is available since SDL 3.2.0.

 The pixels of the new surface are initialized to zero.

 threadsafety: It is safe to call this function from any thread.

 @param width : `the width of the surface.`
 @param height : `the height of the surface.`
 @param format : `the SDL_PixelFormat for the new surface's pixel format.`
 @return `the new SDL_Surface structure that is created or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLSurface* create_surface(CInt width, CInt height, SDLPixelFormat format) @extern("SDL_CreateSurface");

<*
 Allocate a new surface with a specific pixel format and existing pixel
 data.
 This function is available since SDL 3.2.0.

 No copy is made of the pixel data. Pixel data is not managed automatically;
 you must free the surface before you free the pixel data.

 Pitch is the offset in bytes from one row of pixels to the next, e.g.
 `width*4` for `SDL_PIXELFORMAT_RGBA8888`.

 You may pass NULL for pixels and 0 for pitch to create a surface that you
 will fill in with valid values later.

 threadsafety: It is safe to call this function from any thread.

 @param width : `the width of the surface.`
 @param height : `the height of the surface.`
 @param format : `the SDL_PixelFormat for the new surface's pixel format.`
 @param pixels : `a pointer to existing pixel data.`
 @param pitch : `the number of bytes between each row, including padding.`
 @return `the new SDL_Surface structure that is created or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLSurface* create_surface_from(CInt width, CInt height, SDLPixelFormat format, void* pixels, CInt pitch) @extern("SDL_CreateSurfaceFrom");

<*
 Free a surface.
 This function is available since SDL 3.2.0.

 It is safe to pass NULL to this function.

 threadsafety: No other thread should be using the surface when it is freed.

 @param surface : `the SDL_Surface to free.`
*>
extern fn void SDLSurface.destroy(&surface) @extern("SDL_DestroySurface");

<*
 Get the properties associated with a surface.
 This function is available since SDL 3.2.0.

 The following properties are understood by SDL:

 - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
   surfaces, this defines the value of 100% diffuse white, with higher
   values being displayed in the High Dynamic Range headroom. This defaults
   to 203 for HDR10 surfaces and 1.0 for floating point surfaces.
 - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
   surfaces, this defines the maximum dynamic range used by the content, in
   terms of the SDR white point. This defaults to 0.0, which disables tone
   mapping.
 - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator
   used when compressing from a surface with high dynamic range to another
   with lower dynamic range. Currently this supports "chrome", which uses
   the same tone mapping that Chrome uses for HDR content, the form "*=N",
   where N is a floating point scale factor applied in linear space, and
   "none", which disables tone mapping. This defaults to "chrome".
 - `SDL_PROP_SURFACE_HOTSPOT_X_NUMBER`: the hotspot pixel offset from the
   left edge of the image, if this surface is being used as a cursor.
 - `SDL_PROP_SURFACE_HOTSPOT_Y_NUMBER`: the hotspot pixel offset from the
   top edge of the image, if this surface is being used as a cursor.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLSurface.get_properties(&surface) @extern("SDL_GetSurfaceProperties");

enum SDLPropSurface : const inline ZString
{
	SDR_WHITE_POINT_FLOAT   = "SDL.surface.SDR_white_point",
	HDR_HEADROOM_FLOAT      = "SDL.surface.HDR_headroom",
	TONEMAP_OPERATOR_STRING = "SDL.surface.tonemap",
	HOTSPOT_X_NUMBER        = "SDL.surface.hotspot.x",
	HOTSPOT_Y_NUMBER        = "SDL.surface.hotspot.y",
}

<*
 Set the colorspace used by a surface.
 This function is available since SDL 3.2.0.

 Setting the colorspace doesn't change the pixels, only how they are
 interpreted in color operations.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param colorspace : `an SDL_Colorspace value describing the surface
                      colorspace.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_colorspace(&surface, SDLColorspace colorspace) @extern("SDL_SetSurfaceColorspace");

<*
 Get the colorspace used by a surface.
 This function is available since SDL 3.2.0.

 The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point
 formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for
 other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to query.`
 @return `the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if
          the surface is NULL.`
*>
extern fn SDLColorspace SDLSurface.get_colorspace(&surface) @extern("SDL_GetSurfaceColorspace");

<*
 Create a palette and associate it with a surface.
 This function is available since SDL 3.2.0.

 This function creates a palette compatible with the provided surface. The
 palette is then returned for you to modify, and the surface will
 automatically use the new palette in future operations. You do not need to
 destroy the returned palette, it will be freed when the reference count
 reaches 0, usually when the surface is destroyed.

 Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or
 SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as
 white and 1 as black. Other surfaces will get a palette initialized with
 white in every entry.

 If this function is called for a surface that already has a palette, a new
 palette will be created to replace it.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @return `a new SDL_Palette structure on success or NULL on failure (e.g. if
          the surface didn't have an index format); call SDL_GetError() for
          more information.`
*>
extern fn SDLPalette* SDLSurface.create_palette(&surface) @extern("SDL_CreateSurfacePalette");

<*
 Set the palette used by a surface.
 This function is available since SDL 3.2.0.

 A single palette can be shared with many surfaces.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param palette : `the SDL_Palette structure to use.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_palette(&surface, SDLPalette* palette) @extern("SDL_SetSurfacePalette");

<*
 Get the palette used by a surface.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @return `a pointer to the palette used by the surface, or NULL if there is
          no palette used.`
*>
extern fn SDLPalette* SDLSurface.get_palette(&surface) @extern("SDL_GetSurfacePalette");

<*
 Add an alternate version of a surface.
 This function is available since SDL 3.2.0.

 This function adds an alternate version of this surface, usually used for
 content with high DPI representations like cursors or icons. The size,
 format, and content do not need to match the original surface, and these
 alternate versions will not be updated when the original surface changes.

 This function adds a reference to the alternate version, so you should call
 SDL_DestroySurface() on the image after this call.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param image : `a pointer to an alternate SDL_Surface to associate with this
                 surface.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.add_alternate_image(&surface, SDLSurface *image) @extern("SDL_AddSurfaceAlternateImage");

<*
 Return whether a surface has alternate versions available.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @return `true if alternate versions are available or false otherwise.`
*>
extern fn bool SDLSurface.has_alternate_images(&surface) @extern("SDL_SurfaceHasAlternateImages");

<*
 Get an array including all versions of a surface.
 This function is available since SDL 3.2.0.

 This returns all versions of a surface, with the surface being queried as
 the first element in the returned array.

 Freeing the array of surfaces does not affect the surfaces in the array.
 They are still referenced by the surface being queried and will be cleaned
 up normally.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to query.`
 @param count : `a pointer filled in with the number of surface pointers
                 returned, may be NULL.`
 @return `a NULL terminated array of SDL_Surface pointers or NULL on
          failure; call SDL_GetError() for more information. This should be
          freed with SDL_free() when it is no longer needed.`
*>
extern fn SDLSurface** SDLSurface.get_images(&surface, CInt* count) @extern("SDL_GetSurfaceImages");

<*
 Remove all alternate versions of a surface.
 This function is available since SDL 3.2.0.

 This function removes a reference from all the alternative versions,
 destroying them if this is the last reference to them.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
*>
extern fn void SDLSurface.remove_alternate_images(&surface) @extern("SDL_RemoveSurfaceAlternateImages");

<*
 Set up a surface for directly accessing the pixels.
 This function is available since SDL 3.2.0.

 Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to
 and read from `surface->pixels`, using the pixel format stored in
 `surface->format`. Once you are done accessing the surface, you should use
 SDL_UnlockSurface() to release it.

 Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to
 0, then you can read and write to the surface at any time, and the pixel
 format of the surface will not change.

 threadsafety: This function is not thread safe. The locking referred to by
               this function is making the pixels available for direct
               access, not thread-safe locking.

 @param surface : `the SDL_Surface structure to be locked.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.lock(&surface) @extern("SDL_LockSurface");

<*
 Release a surface after directly accessing the pixels.
 This function is available since SDL 3.2.0.

 threadsafety: This function is not thread safe. The locking referred to by
               this function is making the pixels available for direct
               access, not thread-safe locking.

 @param surface : `the SDL_Surface structure to be unlocked.`
*>
extern fn void SDLSurface.unlock(&surface) @extern("SDL_UnlockSurface");

<*
 Load a BMP image from a seekable SDL data stream.
 This function is available since SDL 3.2.0.

 The new surface should be freed with SDL_DestroySurface(). Not doing so
 will result in a memory leak.

 threadsafety: It is safe to call this function from any thread.

 @param src : `the data stream for the surface.`
 @param closeio : `if true, calls SDL_CloseIO() on 'src' before returning, even
                   in the case of an error.`
 @return `a pointer to a new SDL_Surface structure or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLSurface* SDLIOStream.load_bmp(&src, bool closeio) @extern("SDL_LoadBMP_IO");

<*
 Load a BMP image from a file.
 This function is available since SDL 3.2.0.

 The new surface should be freed with SDL_DestroySurface(). Not doing so
 will result in a memory leak.

 threadsafety: It is safe to call this function from any thread.

 @param file : `the BMP file to load.`
 @return `a pointer to a new SDL_Surface structure or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLSurface* load_bmp(ZString file) @extern("SDL_LoadBMP");

<*
 Save a surface to a seekable SDL data stream in BMP format.
 This function is available since SDL 3.2.0.

 Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 BMP directly. Other RGB formats with 8-bit or higher get converted to a
 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 not supported.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure containing the image to be saved.`
 @param dst : `a data stream to save to.`
 @param closeio : `if true, calls SDL_CloseIO() on 'dst' before returning, even
                   in the case of an error.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.save_bmp_io(&surface, SDLIOStream* dst, bool closeio) @extern("SDL_SaveBMP_IO");

<*
 Save a surface to a file.
 This function is available since SDL 3.2.0.

 Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the
 BMP directly. Other RGB formats with 8-bit or higher get converted to a
 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit
 surface before they are saved. YUV and paletted 1-bit and 4-bit formats are
 not supported.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure containing the image to be saved.`
 @param file : `a file to save to.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.save_bmp(&surface, ZString file) @extern("SDL_SaveBMP");

<*
 Set the RLE acceleration hint for a surface.
 This function is available since SDL 3.2.0.

 If RLE is enabled, color key and alpha blending blits are much faster, but
 the surface must be locked before directly accessing the pixels.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to optimize.`
 @param enabled : `true to enable RLE acceleration, false to disable it.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_rle(&surface, bool enabled) @extern("SDL_SetSurfaceRLE");

<*
 Returns whether the surface is RLE enabled.
 This function is available since SDL 3.2.0.

 It is safe to pass a NULL `surface` here; it will return false.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @return `true if the surface is RLE enabled, false otherwise.`
*>
extern fn bool SDLSurface.has_rle(&surface) @extern("SDL_SurfaceHasRLE");

<*
 Set the color key (transparent pixel) in a surface.
 This function is available since SDL 3.2.0.

 The color key defines a pixel value that will be treated as transparent in
 a blit. For example, one can use this to specify that cyan pixels should be
 considered transparent, and therefore not rendered.

 It is a pixel of the format used by the surface, as generated by
 SDL_MapRGB().

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param enabled : `true to enable color key, false to disable color key.`
 @param key : `the transparent pixel.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_color_key(&surface, bool enabled, uint key) @extern("SDL_SetSurfaceColorKey");

<*
 Returns whether the surface has a color key.
 This function is available since SDL 3.2.0.

 It is safe to pass a NULL `surface` here; it will return false.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @return `true if the surface has a color key, false otherwise.`
*>
extern fn bool SDLSurface.has_color_key(&surface) @extern("SDL_SurfaceHasColorKey");

<*
 Get the color key (transparent pixel) for a surface.
 This function is available since SDL 3.2.0.

 The color key is a pixel of the format used by the surface, as generated by
 SDL_MapRGB().

 If the surface doesn't have color key enabled this function returns false.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @param key : `a pointer filled in with the transparent pixel.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.get_color_key(&surface, uint* key) @extern("SDL_GetSurfaceColorKey");

<*
 Set an additional color value multiplied into blit operations.
 This function is available since SDL 3.2.0.

 When this surface is blitted, during the blit operation each source color
 channel is modulated by the appropriate color value according to the
 following formula:

 `srcC = srcC * (color / 255)`

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param r : `the red color value multiplied into blit operations.`
 @param g : `the green color value multiplied into blit operations.`
 @param b : `the blue color value multiplied into blit operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_color_mod(&surface, char r, char g, char b) @extern("SDL_SetSurfaceColorMod");

<*
 Get the additional color value multiplied into blit operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to query.`
 @param r : `a pointer filled in with the current red color value.`
 @param g : `a pointer filled in with the current green color value.`
 @param b : `a pointer filled in with the current blue color value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.get_color_mod(&surface, char* r, char* g, char* b) @extern("SDL_GetSurfaceColorMod");

<*
 Set an additional alpha value used in blit operations.
 This function is available since SDL 3.2.0.

 When this surface is blitted, during the blit operation the source alpha
 value is modulated by this alpha value according to the following formula:

 `srcA = srcA * (alpha / 255)`

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param alpha : `the alpha value multiplied into blit operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_alpha_mod(&surface, char alpha) @extern("SDL_SetSurfaceAlphaMod");

<*
 Get the additional alpha value used in blit operations.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @param alpha : `a pointer filled in with the current alpha value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.get_alpha_mod(&surface, char* alpha) @extern("SDL_GetSurfaceAlphaMod");

<*
 Set the blend mode used for blit operations.
 This function is available since SDL 3.2.0.

 To copy a surface to another surface (or texture) without blending with the
 existing data, the blendmode of the SOURCE surface should be set to
 `SDL_BLENDMODE_NONE`.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to update.`
 @param blendMode : `the SDL_BlendMode to use for blit blending.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.set_blend_mode(&surface, SDLBlendMode blendMode) @extern("SDL_SetSurfaceBlendMode");

<*
 Get the blend mode used for blit operations.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the SDL_Surface structure to query.`
 @param blendMode : `a pointer filled in with the current SDL_BlendMode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.get_blend_mode(&surface, SDLBlendMode* blendMode) @extern("SDL_GetSurfaceBlendMode");

<*
 Set the clipping rectangle for a surface.
 This function is available since SDL 3.2.0.

 When `surface` is the destination of a blit, only the area within the clip
 rectangle is drawn into.

 Note that blits are automatically clipped to the edges of the source and
 destination surfaces.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure to be clipped.`
 @param rect : `the SDL_Rect structure representing the clipping rectangle, or
                NULL to disable clipping.`
 @return `true if the rectangle intersects the surface, otherwise false and
          blits will be completely clipped.`
*>
extern fn bool SDLSurface.set_clip_rect(&surface, SDLRect* rect) @extern("SDL_SetSurfaceClipRect");

<*
 Get the clipping rectangle for a surface.
 This function is available since SDL 3.2.0.

 When `surface` is the destination of a blit, only the area within the clip
 rectangle is drawn into.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface structure representing the surface to be
                   clipped.`
 @param rect : `an SDL_Rect structure filled in with the clipping rectangle for
                the surface.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.get_clip_rect(&surface, SDLRect* rect) @extern("SDL_GetSurfaceClipRect");

<*
 Flip a surface vertically or horizontally.
 This function is available since SDL 3.2.0.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to flip.`
 @param flip : `the direction to flip.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.flip(&surface, SDLFlipMode flip) @extern("SDL_FlipSurface");

<*
 Creates a new surface identical to the existing surface.
 This function is available since SDL 3.2.0.

 If the original surface has alternate images, the new surface will have a
 reference to them as well.

 The returned surface should be freed with SDL_DestroySurface().

 threadsafety: This function is not thread safe.

 @param surface : `the surface to duplicate.`
 @return `a copy of the surface or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLSurface* SDLSurface.duplicate(&surface) @extern("SDL_DuplicateSurface");

<*
 Creates a new surface identical to the existing surface, scaled to the
 desired size.
 This function is available since SDL 3.2.0.

 The returned surface should be freed with SDL_DestroySurface().

 threadsafety: This function is not thread safe.

 @param surface : `the surface to duplicate and scale.`
 @param width : `the width of the new surface.`
 @param height : `the height of the new surface.`
 @param scaleMode : `the SDL_ScaleMode to be used.`
 @return `a copy of the surface or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLSurface* SDLSurface.scale(&surface, CInt width, CInt height, SDLScaleMode scaleMode) @extern("SDL_ScaleSurface");

<*
 Copy an existing surface to a new surface of the specified format.
 This function is available since SDL 3.2.0.

 This function is used to optimize images for faster *repeat* blitting. This
 is accomplished by converting the original and storing the result as a new
 surface. The new, optimized surface can then be used as the source for
 future blits, making them faster.

 If you are converting to an indexed surface and want to map colors to a
 palette, you can use SDL_ConvertSurfaceAndColorspace() instead.

 If the original surface has alternate images, the new surface will have a
 reference to them as well.

 threadsafety: This function is not thread safe.

 @param surface : `the existing SDL_Surface structure to convert.`
 @param format : `the new pixel format.`
 @return `the new SDL_Surface structure that is created or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLSurface* SDLSurface.convert(&surface, SDLPixelFormat format) @extern("SDL_ConvertSurface");

<*
 Copy an existing surface to a new surface of the specified format and
 colorspace.
 This function is available since SDL 3.2.0.

 This function converts an existing surface to a new format and colorspace
 and returns the new surface. This will perform any pixel format and
 colorspace conversion needed.

 If the original surface has alternate images, the new surface will have a
 reference to them as well.

 threadsafety: This function is not thread safe.

 @param surface : `the existing SDL_Surface structure to convert.`
 @param format : `the new pixel format.`
 @param palette : `an optional palette to use for indexed formats, may be NULL.`
 @param colorspace : `the new colorspace.`
 @param props : `an SDL_PropertiesID with additional color properties, or 0.`
 @return `the new SDL_Surface structure that is created or NULL on failure;
          call SDL_GetError() for more information.`
*>
extern fn SDLSurface* SDLSurface.convert_with_colorspace(&surface, SDLPixelFormat format, SDLPalette* palette, SDLColorspace colorspace, SDLPropertiesID props) @extern("SDL_ConvertSurfaceAndColorspace");

<*
 Copy a block of pixels of one format to another format.
 This function is available since SDL 3.2.0.

 threadsafety: The same destination pixels should not be used from two
               threads at once. It is safe to use the same source pixels
               from multiple threads.

 @param width : `the width of the block to copy, in pixels.`
 @param height : `the height of the block to copy, in pixels.`
 @param src_format : `an SDL_PixelFormat value of the 'src' pixels format.`
 @param src : `a pointer to the source pixels.`
 @param src_pitch : `the pitch of the source pixels, in bytes.`
 @param dst_format : `an SDL_PixelFormat value of the 'dst' pixels format.`
 @param dst : `a pointer to be filled in with new pixel data.`
 @param dst_pitch : `the pitch of the destination pixels, in bytes.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool convert_pixels(CInt width, CInt height, SDLPixelFormat src_format, void* src, CInt src_pitch, SDLPixelFormat dst_format, void* dst, CInt dst_pitch) @extern("SDL_ConvertPixels");

<*
 Copy a block of pixels of one format and colorspace to another format and
 colorspace.
 This function is available since SDL 3.2.0.

 threadsafety: The same destination pixels should not be used from two
               threads at once. It is safe to use the same source pixels
               from multiple threads.

 @param width : `the width of the block to copy, in pixels.`
 @param height : `the height of the block to copy, in pixels.`
 @param src_format : `an SDL_PixelFormat value of the 'src' pixels format.`
 @param src_colorspace : `an SDL_Colorspace value describing the colorspace of
                          the 'src' pixels.`
 @param src_properties : `an SDL_PropertiesID with additional source color
                          properties, or 0.`
 @param src : `a pointer to the source pixels.`
 @param src_pitch : `the pitch of the source pixels, in bytes.`
 @param dst_format : `an SDL_PixelFormat value of the 'dst' pixels format.`
 @param dst_colorspace : `an SDL_Colorspace value describing the colorspace of
                          the 'dst' pixels.`
 @param dst_properties : `an SDL_PropertiesID with additional destination color
                          properties, or 0.`
 @param dst : `a pointer to be filled in with new pixel data.`
 @param dst_pitch : `the pitch of the destination pixels, in bytes.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool convert_pixels_and_colorspace(CInt width, CInt height, SDLPixelFormat src_format, SDLColorspace src_colorspace, SDLPropertiesID src_properties, void* src, CInt src_pitch, SDLPixelFormat dst_format, SDLColorspace dst_colorspace, SDLPropertiesID dst_properties, void* dst, CInt dst_pitch) @extern("SDL_ConvertPixelsAndColorspace");

<*
 Premultiply the alpha on a block of pixels.
 This function is available since SDL 3.2.0.

 This is safe to use with src == dst, but not for other overlapping areas.

 threadsafety: The same destination pixels should not be used from two
               threads at once. It is safe to use the same source pixels
               from multiple threads.

 @param width : `the width of the block to convert, in pixels.`
 @param height : `the height of the block to convert, in pixels.`
 @param src_format : `an SDL_PixelFormat value of the 'src' pixels format.`
 @param src : `a pointer to the source pixels.`
 @param src_pitch : `the pitch of the source pixels, in bytes.`
 @param dst_format : `an SDL_PixelFormat value of the 'dst' pixels format.`
 @param dst : `a pointer to be filled in with premultiplied pixel data.`
 @param dst_pitch : `the pitch of the destination pixels, in bytes.`
 @param linear : `true to convert from sRGB to linear space for the alpha
                  multiplication, false to do multiplication in sRGB space.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool premultiply_alpha(CInt width, CInt height, SDLPixelFormat src_format, void* src, CInt src_pitch, SDLPixelFormat dst_format, void* dst, CInt dst_pitch, bool linear) @extern("SDL_PremultiplyAlpha");

<*
 Premultiply the alpha in a surface.
 This function is available since SDL 3.2.0.

 This is safe to use with src == dst, but not for other overlapping areas.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to modify.`
 @param linear : `true to convert from sRGB to linear space for the alpha
                  multiplication, false to do multiplication in sRGB space.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.premultiply_alpha(&surface, bool linear) @extern("SDL_PremultiplySurfaceAlpha");

<*
 Clear a surface with a specific color, with floating point precision.
 This function is available since SDL 3.2.0.

 This function handles all surface formats, and ignores any clip rectangle.

 If the surface is YUV, the color is assumed to be in the sRGB colorspace,
 otherwise the color is assumed to be in the colorspace of the suface.

 threadsafety: This function is not thread safe.

 @param surface : `the SDL_Surface to clear.`
 @param r : `the red component of the pixel, normally in the range 0-1.`
 @param g : `the green component of the pixel, normally in the range 0-1.`
 @param b : `the blue component of the pixel, normally in the range 0-1.`
 @param a : `the alpha component of the pixel, normally in the range 0-1.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.clear(&surface, float r, float g, float b, float a) @extern("SDL_ClearSurface");

<*
 Perform a fast fill of a rectangle with a specific color.
 This function is available since SDL 3.2.0.

 `color` should be a pixel of the format used by the surface, and can be
 generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 alpha component then the destination is simply filled with that alpha
 information, no blending takes place.

 If there is a clip rectangle set on the destination (set via
 SDL_SetSurfaceClipRect()), then this function will fill based on the
 intersection of the clip rectangle and `rect`.
 This function is not thread safe.

 @param dst : `the SDL_Surface structure that is the drawing target.`
 @param rect : `the SDL_Rect structure representing the rectangle to fill, or
                NULL to fill the entire surface.`
 @param color : `the color to fill with.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.fill_rect(&dst, SDLRect* rect, uint color) @extern("SDL_FillSurfaceRect");

<*
 Perform a fast fill of a set of rectangles with a specific color.
 This function is available since SDL 3.2.0.

 `color` should be a pixel of the format used by the surface, and can be
 generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an
 alpha component then the destination is simply filled with that alpha
 information, no blending takes place.

 If there is a clip rectangle set on the destination (set via
 SDL_SetSurfaceClipRect()), then this function will fill based on the
 intersection of the clip rectangle and `rect`.
 This function is not thread safe.

 @param dst : `the SDL_Surface structure that is the drawing target.`
 @param rects : `an array of SDL_Rects representing the rectangles to fill.`
 @param count : `the number of rectangles in the array.`
 @param color : `the color to fill with.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.fill_rects(&dst, SDLRect* rects, CInt count, uint color) @extern("SDL_FillSurfaceRects");

<*
 Performs a fast blit from the source surface to the destination surface
 with clipping.
 This function is available since SDL 3.2.0.

 If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or
 `dst`) is copied while ensuring clipping to `dst->clip_rect`.

 The blit function should not be called on a locked surface.

 The blit semantics for surfaces with and without blending and colorkey are
 defined as follows:

 ```
    RGBA->RGB:
      Source surface blend mode set to SDL_BLENDMODE_BLEND:
       alpha-blend (using the source alpha-channel and per-surface alpha)
       SDL_SRCCOLORKEY ignored.
     Source surface blend mode set to SDL_BLENDMODE_NONE:
       copy RGB.
       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
       RGB values of the source color key, ignoring alpha in the
       comparison.

   RGB->RGBA:
     Source surface blend mode set to SDL_BLENDMODE_BLEND:
       alpha-blend (using the source per-surface alpha)
     Source surface blend mode set to SDL_BLENDMODE_NONE:
       copy RGB, set destination alpha to source per-surface alpha value.
     both:
       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
       source color key.

   RGBA->RGBA:
     Source surface blend mode set to SDL_BLENDMODE_BLEND:
       alpha-blend (using the source alpha-channel and per-surface alpha)
       SDL_SRCCOLORKEY ignored.
     Source surface blend mode set to SDL_BLENDMODE_NONE:
       copy all of RGBA to the destination.
       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
       RGB values of the source color key, ignoring alpha in the
       comparison.

   RGB->RGB:
     Source surface blend mode set to SDL_BLENDMODE_BLEND:
       alpha-blend (using the source per-surface alpha)
     Source surface blend mode set to SDL_BLENDMODE_NONE:
       copy RGB.
     both:
       if SDL_SRCCOLORKEY set, only copy the pixels that do not match the
       source color key.
 ```
 Only one thread should be using the `src` and `dst` surfaces at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, or NULL to copy the entire surface.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the x and y position in
                   the destination surface, or NULL for (0,0). The width and
                   height are ignored, and are copied from 'srcrect'. If you
                   want a specific width and height, you should use
                   SDL_BlitSurfaceScaled().`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect) @extern("SDL_BlitSurface");

<*
 Perform low-level surface blitting only.
 This function is available since SDL 3.2.0.

 This is a semi-private blit function and it performs low-level surface
 blitting, assuming the input rectangles have already been clipped.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, may not be NULL.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, may not be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_unchecked(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect) @extern("SDL_BlitSurfaceUnchecked");

<*
 Perform a scaled blit to a destination surface, which may be of a different
 format.
 This function is available since SDL 3.2.0.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, or NULL to copy the entire surface.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, or NULL to fill the entire
                   destination surface.`
 @param scaleMode : `the SDL_ScaleMode to be used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_scaled(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode) @extern("SDL_BlitSurfaceScaled");

<*
 Perform low-level surface scaled blitting only.
 This function is available since SDL 3.2.0.

 This is a semi-private function and it performs low-level surface blitting,
 assuming the input rectangles have already been clipped.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, may not be NULL.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, may not be NULL.`
 @param scaleMode : `the SDL_ScaleMode to be used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_unchecked_scaled(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode) @extern("SDL_BlitSurfaceUncheckedScaled");

<*
 Perform a stretched pixel copy from one surface to another.
 This function is available since SDL 3.4.0.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, or NULL to copy the entire surface.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, or NULL to fill the entire
                   destination surface.`
 @param scaleMode : `the SDL_ScaleMode to be used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.stretch(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect, SDLScaleMode scaleMode) @extern("SDL_StretchSurface");

<*
 Perform a tiled blit to a destination surface, which may be of a different
 format.
 This function is available since SDL 3.2.0.

 The pixels in `srcrect` will be repeated as many times as needed to
 completely fill `dstrect`.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, or NULL to copy the entire surface.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, or NULL to fill the entire surface.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_tiled(&src, SDLRect* srcrect, SDLSurface* dst, SDLRect* dstrect) @extern("SDL_BlitSurfaceTiled");

<*
 Perform a scaled and tiled blit to a destination surface, which may be of a
 different format.
 This function is available since SDL 3.2.0.

 The pixels in `srcrect` will be scaled and repeated as many times as needed
 to completely fill `dstrect`.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be
                   copied, or NULL to copy the entire surface.`
 @param scale : `the scale used to transform srcrect into the destination
                 rectangle, e.g. a 32x32 texture with a scale of 2 would fill
                 64x64 tiles.`
 @param scaleMode : `scale algorithm to be used.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, or NULL to fill the entire surface.`
 @returns `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_tiled_with_scale(&src, SDLRect* srcrect, float scale, SDLScaleMode scaleMode, SDLSurface* dst, SDLRect* dstrect) @extern("SDL_BlitSurfaceTiledWithScale");

<*
 Perform a scaled blit using the 9-grid algorithm to a destination surface,
 which may be of a different format.
 This function is available since SDL 3.2.0.

 The pixels in the source surface are split into a 3x3 grid, using the
 different corner sizes for each corner, and the sides and center making up
 the remaining pixels. The corners are then scaled using `scale` and fit
 into the corners of the destination rectangle. The sides and center are
 then stretched into place to cover the remaining destination rectangle.

 threadsafety: Only one thread should be using the `src` and `dst` surfaces
               at any given time.

 @param src : `the SDL_Surface structure to be copied from.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be used
                   for the 9-grid, or NULL to use the entire surface.`
 @param left_width : `the width, in pixels, of the left corners in 'srcrect'.`
 @param right_width : `the width, in pixels, of the right corners in 'srcrect'.`
 @param top_height : `the height, in pixels, of the top corners in 'srcrect'.`
 @param bottom_height : `the height, in pixels, of the bottom corners in
                         'srcrect'.`
 @param scale : `the scale used to transform the corner of 'srcrect' into the
                 corner of 'dstrect', or 0.0f for an unscaled blit.`
 @param scaleMode : `scale algorithm to be used.`
 @param dst : `the SDL_Surface structure that is the blit target.`
 @param dstrect : `the SDL_Rect structure representing the target rectangle in
                   the destination surface, or NULL to fill the entire surface.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.blit_9grid(&src, SDLRect* srcrect, CInt left_width, CInt right_width, CInt top_height, CInt bottom_height, float scale, SDLScaleMode scaleMode, SDLSurface* dst, SDLRect* dstrect) @extern("SDL_BlitSurface9Grid");

<*
 Map an RGB triple to an opaque pixel value for a surface.
 This function is available since SDL 3.2.0.

 This function maps the RGB color value to the specified pixel format and
 returns the pixel value best approximating the given RGB color value for
 the given pixel format.

 If the surface has a palette, the index of the closest matching color in
 the palette will be returned.

 If the surface pixel format has an alpha component it will be returned as
 all 1 bits (fully opaque).

 If the pixel format bpp (color depth) is less than 32-bpp then the unused
 upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 format the return value can be assigned to a Uint16, and similarly a Uint8
 for an 8-bpp format).

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the surface to use for the pixel format and palette.`
 @param r : `the red component of the pixel in the range 0-255.`
 @param g : `the green component of the pixel in the range 0-255.`
 @param b : `the blue component of the pixel in the range 0-255.`
 @return `a pixel value.`
*>
extern fn uint SDLSurface.map_rbg(&surface, char r, char g, char b) @extern("SDL_MapSurfaceRGB");

<*
 Map an RGBA quadruple to a pixel value for a surface.
 This function is available since SDL 3.2.0.

 This function maps the RGBA color value to the specified pixel format and
 returns the pixel value best approximating the given RGBA color value for
 the given pixel format.

 If the surface pixel format has no alpha component the alpha value will be
 ignored (as it will be in formats with a palette).

 If the surface has a palette, the index of the closest matching color in
 the palette will be returned.

 If the pixel format bpp (color depth) is less than 32-bpp then the unused
 upper bits of the return value can safely be ignored (e.g., with a 16-bpp
 format the return value can be assigned to a Uint16, and similarly a Uint8
 for an 8-bpp format).

 threadsafety: It is safe to call this function from any thread.

 @param surface : `the surface to use for the pixel format and palette.`
 @param r : `the red component of the pixel in the range 0-255.`
 @param g : `the green component of the pixel in the range 0-255.`
 @param b : `the blue component of the pixel in the range 0-255.`
 @param a : `the alpha component of the pixel in the range 0-255.`
 @return `a pixel value.`
*>
extern fn uint SDLSurface.map_rbga(&surface, char r, char g, char b, char a) @extern("SDL_MapSurfaceRGBA");

<*
 Retrieves a single pixel from a surface.
 This function is available since SDL 3.2.0.

 This function prioritizes correctness over speed: it is suitable for unit
 tests, but is not intended for use in a game engine.

 Like SDL_GetRGBA, this uses the entire 0..255 range when converting color
 components from pixel formats with less than 8 bits per RGB component.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to read.`
 @param x : `the horizontal coordinate, 0 <= x < width.`
 @param y : `the vertical coordinate, 0 <= y < height.`
 @param r : `a pointer filled in with the red channel, 0-255, or NULL to ignore
             this channel.`
 @param g : `a pointer filled in with the green channel, 0-255, or NULL to
             ignore this channel.`
 @param b : `a pointer filled in with the blue channel, 0-255, or NULL to
             ignore this channel.`
 @param a : `a pointer filled in with the alpha channel, 0-255, or NULL to
             ignore this channel.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.read_pixel(&surface, CInt x, CInt y, char* r, char* g, char* b, char* a) @extern("SDL_ReadSurfacePixel");

<*
 Retrieves a single pixel from a surface.
 This function is available since SDL 3.2.0.

 This function prioritizes correctness over speed: it is suitable for unit
 tests, but is not intended for use in a game engine.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to read.`
 @param x : `the horizontal coordinate, 0 <= x < width.`
 @param y : `the vertical coordinate, 0 <= y < height.`
 @param r : `a pointer filled in with the red channel, normally in the range
             0-1, or NULL to ignore this channel.`
 @param g : `a pointer filled in with the green channel, normally in the range
             0-1, or NULL to ignore this channel.`
 @param b : `a pointer filled in with the blue channel, normally in the range
             0-1, or NULL to ignore this channel.`
 @param a : `a pointer filled in with the alpha channel, normally in the range
             0-1, or NULL to ignore this channel.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.read_pixel_float(surface, CInt x, CInt y, float* r, float* g, float* b, float* a) @extern("SDL_ReadSurfacePixelFloat");

<*
 Writes a single pixel to a surface.
 This function is available since SDL 3.2.0.

 This function prioritizes correctness over speed: it is suitable for unit
 tests, but is not intended for use in a game engine.

 Like SDL_MapRGBA, this uses the entire 0..255 range when converting color
 components from pixel formats with less than 8 bits per RGB component.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to write.`
 @param x : `the horizontal coordinate, 0 <= x < width.`
 @param y : `the vertical coordinate, 0 <= y < height.`
 @param r : `the red channel value, 0-255.`
 @param g : `the green channel value, 0-255.`
 @param b : `the blue channel value, 0-255.`
 @param a : `the alpha channel value, 0-255.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.write_pixel(&surface, CInt x, CInt y, char r, char g, char b, char a) @extern("SDL_WriteSurfacePixel");

<*
 Writes a single pixel to a surface.
 This function is available since SDL 3.2.0.

 This function prioritizes correctness over speed: it is suitable for unit
 tests, but is not intended for use in a game engine.

 threadsafety: This function is not thread safe.

 @param surface : `the surface to write.`
 @param x : `the horizontal coordinate, 0 <= x < width.`
 @param y : `the vertical coordinate, 0 <= y < height.`
 @param r : `the red channel value, normally in the range 0-1.`
 @param g : `the green channel value, normally in the range 0-1.`
 @param b : `the blue channel value, normally in the range 0-1.`
 @param a : `the alpha channel value, normally in the range 0-1.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLSurface.write_pixel_float(&surface, CInt x, CInt y, float r, float g, float b, float a) @extern("SDL_WriteSurfacePixelFloat");
