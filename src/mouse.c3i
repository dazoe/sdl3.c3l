<*
 Any GUI application has to deal with the mouse, and SDL provides functions
 to manage mouse input and the displayed cursor.

 Most interactions with the mouse will come through the event subsystem.
 Moving a mouse generates an SDL_EVENT_MOUSE_MOTION event, pushing a button
 generates SDL_EVENT_MOUSE_BUTTON_DOWN, etc, but one can also query the
 current state of the mouse at any time with SDL_GetMouseState().

 For certain games, it's useful to disassociate the mouse cursor from mouse
 input. An FPS, for example, would not want the player's motion to stop as
 the mouse hits the edge of the window. For these scenarios, use
 SDL_SetWindowRelativeMouseMode(), which hides the cursor, grabs mouse input
 to the window, and reads mouse input no matter how far it moves.

 Games that want the system to track the mouse but want to draw their own
 cursor can use SDL_HideCursor() and SDL_ShowCursor(). It might be more
 efficient to let the system manage the cursor, if possible, using
 SDL_SetCursor() with a custom image made through SDL_CreateColorCursor(),
 or perhaps just a specific system cursor from SDL_CreateSystemCursor().

 SDL can, on many platforms, differentiate between multiple connected mice,
 allowing for interesting input scenarios and multiplayer games. They can be
 enumerated with SDL_GetMice(), and SDL will send SDL_EVENT_MOUSE_ADDED and
 SDL_EVENT_MOUSE_REMOVED events as they are connected and unplugged.

 Since many apps only care about basic mouse input, SDL offers a virtual
 mouse device for touch and pen input, which often can make a desktop
 application work on a touchscreen phone without any code changes. Apps that
 care about touch/pen separately from mouse input should filter out events
 with a `which` field of SDL_TOUCH_MOUSEID/SDL_PEN_MOUSEID.

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryMouse
*>
module sdl;

<*
 This is a unique ID for a mouse for the time it is connected to the system,
 and is never reused for the lifetime of the application.
 This datatype is available since SDL 3.2.0.

 If the mouse is disconnected and reconnected, it will get a new ID.

 The value 0 is an invalid ID.
*>
typedef SDLMouseID = uint;

<*
 The structure used to identify an SDL cursor.
 This struct is available since SDL 3.2.0.

 This is opaque data.
*>
typedef SDLCursor = void;

<*
 Cursor types for SDL_CreateSystemCursor().
 This enum is available since SDL 3.2.0.
*>
enum SDLSystemCursor : const CInt
{
    DEFAULT,      /**< Default cursor. Usually an arrow. */
    TEXT,         /**< Text selection. Usually an I-beam. */
    WAIT,         /**< Wait. Usually an hourglass or watch or spinning ball. */
    CROSSHAIR,    /**< Crosshair. */
    PROGRESS,     /**< Program is busy but still interactive. Usually it's WAIT with an arrow. */
    NWSE_RESIZE,  /**< Double arrow pointing northwest and southeast. */
    NESW_RESIZE,  /**< Double arrow pointing northeast and southwest. */
    EW_RESIZE,    /**< Double arrow pointing west and east. */
    NS_RESIZE,    /**< Double arrow pointing north and south. */
    MOVE,         /**< Four pointed arrow pointing north, south, east, and west. */
    NOT_ALLOWED,  /**< Not permitted. Usually a slashed circle or crossbones. */
    POINTER,      /**< Pointer that indicates a link. Usually a pointing hand. */
    NW_RESIZE,    /**< Window resize top-left. This may be a single arrow or a double arrow like NWSE_RESIZE. */
    N_RESIZE,     /**< Window resize top. May be NS_RESIZE. */
    NE_RESIZE,    /**< Window resize top-right. May be NESW_RESIZE. */
    E_RESIZE,     /**< Window resize right. May be EW_RESIZE. */
    SE_RESIZE,    /**< Window resize bottom-right. May be NWSE_RESIZE. */
    S_RESIZE,     /**< Window resize bottom. May be NS_RESIZE. */
    SW_RESIZE,    /**< Window resize bottom-left. May be NESW_RESIZE. */
    W_RESIZE,     /**< Window resize left. May be EW_RESIZE. */
    COUNT,
}

<*
 Scroll direction types for the Scroll event
 This enum is available since SDL 3.2.0.
*>
enum SDLMouseWheelDirection : const CInt
{
    NORMAL,    /**< The scroll direction is normal */
    FLIPPED    /**< The scroll direction is flipped / natural */
}

<*
 A bitmask of pressed mouse buttons, as reported by SDL_GetMouseState, etc.
 This datatype is available since SDL 3.2.0.

 - Button 1: Left mouse button
 - Button 2: Middle mouse button
 - Button 3: Right mouse button
 - Button 4: Side mouse button 1
 - Button 5: Side mouse button 2
*>
bitstruct SDLMouseButtonFlags : uint {
    bool left :     0;
    bool middle :   1;
    bool right :    2;
    bool x1 :       3;
    bool x2 :       4;
}

/* Function prototypes */

<*
 Return whether a mouse is currently connected.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `true if a mouse is connected, false otherwise.`
*>
extern fn bool has_mouse() @extern("SDL_HasMouse");

<*
 Get a list of currently connected mice.
 This function is available since SDL 3.2.0.

 Note that this will include any device or virtual driver that includes
 mouse functionality, including some game controllers, KVM switches, etc.
 You should wait for input from a device before you consider it actively in
 use.

 threadsafety: This function should only be called on the main thread.

 @param count : `a pointer filled in with the number of mice returned, may be
              NULL.`
 @return `a 0 terminated array of mouse instance IDs or NULL on failure;
          call SDL_GetError() for more information. This should be freed
          with SDL_free() when it is no longer needed.`
*>
extern fn SDLMouseID* get_mice(CInt* count) @extern("SDL_GetMice");

<*
 Get the name of a mouse.
 This function is available since SDL 3.2.0.

 This function returns "" if the mouse doesn't have a name.

 threadsafety: This function should only be called on the main thread.

 @param instance_id : `the mouse instance ID.`
 @return `the name of the selected mouse, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn ZString get_mouse_name_for_id(SDLMouseID instance_id) @extern("SDL_GetMouseNameForID");

<*
 Get the window which currently has mouse focus.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `the window with mouse focus.`
*>
extern fn SDLWindow* get_mouse_focus() @extern("SDL_GetMouseFocus");

<*
 Query SDL's cache for the synchronous mouse button state and the
 window-relative SDL-cursor position.
 This function is available since SDL 3.2.0.

 This function returns the cached synchronous state as SDL understands it
 from the last pump of the event queue.

 To query the platform for immediate asynchronous state, use
 SDL_GetGlobalMouseState.

 Passing non-NULL pointers to `x` or `y` will write the destination with
 respective x or y coordinates relative to the focused window.

 In Relative Mode, the SDL-cursor's position usually contradicts the
 platform-cursor's position as manually calculated from
 SDL_GetGlobalMouseState() and SDL_GetWindowPosition.

 threadsafety: This function should only be called on the main thread.

 @param x : `a pointer to receive the SDL-cursor's x-position from the focused
          window's top left corner, can be NULL if unused.`
 @param y : `a pointer to receive the SDL-cursor's y-position from the focused
          window's top left corner, can be NULL if unused.`
 @return `a 32-bit bitmask of the button state that can be bitwise-compared
          against the SDL_BUTTON_MASK(X) macro.`
*>
extern fn SDLMouseButtonFlags get_mouse_state(float *x, float *y) @extern("SDL_GetMouseState");

<*
 Query the platform for the asynchronous mouse button state and the
 desktop-relative platform-cursor position.
 This function is available since SDL 3.2.0.

 This function immediately queries the platform for the most recent
 asynchronous state, more costly than retrieving SDL's cached state in
 SDL_GetMouseState().

 Passing non-NULL pointers to `x` or `y` will write the destination with
 respective x or y coordinates relative to the desktop.

 In Relative Mode, the platform-cursor's position usually contradicts the
 SDL-cursor's position as manually calculated from SDL_GetMouseState() and
 SDL_GetWindowPosition.

 This function can be useful if you need to track the mouse outside of a
 specific window and SDL_CaptureMouse() doesn't fit your needs. For example,
 it could be useful if you need to track the mouse while dragging a window,
 where coordinates relative to a window might not be in sync at all times.

 threadsafety: This function should only be called on the main thread.

 @param x : `a pointer to receive the platform-cursor's x-position from the
          desktop's top left corner, can be NULL if unused.`
 @param y : `a pointer to receive the platform-cursor's y-position from the
          desktop's top left corner, can be NULL if unused.`
 @return `a 32-bit bitmask of the button state that can be bitwise-compared
          against the SDL_BUTTON_MASK(X) macro.`
*>
extern fn SDLMouseButtonFlags get_global_mouse_state(float *x, float *y) @extern("SDL_GetGlobalMouseState");

<*
 Query SDL's cache for the synchronous mouse button state and accumulated
 mouse delta since last call.
 This function is available since SDL 3.2.0.

 This function returns the cached synchronous state as SDL understands it
 from the last pump of the event queue.

 To query the platform for immediate asynchronous state, use
 SDL_GetGlobalMouseState.

 Passing non-NULL pointers to `x` or `y` will write the destination with
 respective x or y deltas accumulated since the last call to this function
 (or since event initialization).

 This function is useful for reducing overhead by processing relative mouse
 inputs in one go per-frame instead of individually per-event, at the
 expense of losing the order between events within the frame (e.g. quickly
 pressing and releasing a button within the same frame).

 threadsafety: This function should only be called on the main thread.

 @param x : `a pointer to receive the x mouse delta accumulated since last
          call, can be NULL if unused.`
 @param y : `a pointer to receive the y mouse delta accumulated since last
          call, can be NULL if unused.`
 @return `a 32-bit bitmask of the button state that can be bitwise-compared
          against the SDL_BUTTON_MASK(X) macro.`
*>
extern fn SDLMouseButtonFlags get_relative_mouse_state(float *x, float *y) @extern("SDL_GetRelativeMouseState");

<*
 Move the mouse cursor to the given position within the window.
 This function is available since SDL 3.2.0.

 This function generates a mouse motion event if relative mode is not
 enabled. If relative mode is enabled, you can force mouse events for the
 warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.

 Note that this function will appear to succeed, but not actually move the
 mouse when used over Microsoft Remote Desktop.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to move the mouse into, or NULL for the current
               mouse focus.`
 @param x : `the x coordinate within the window.`
 @param y : `the y coordinate within the window.`
*>
extern fn void SDLWindow.warp_mouse(&window, float x, float y) @extern("SDL_WarpMouseInWindow");

<*
 Move the mouse to the given position in global screen space.
 This function is available since SDL 3.2.0.

 This function generates a mouse motion event.

 A failure of this function usually means that it is unsupported by a
 platform.

 Note that this function will appear to succeed, but not actually move the
 mouse when used over Microsoft Remote Desktop.

 threadsafety: This function should only be called on the main thread.

 @param x : `the x coordinate.`
 @param y : `the y coordinate.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool warp_mouse_global(float x, float y) @extern("SDL_WarpMouseGlobal");

<*
 Set relative mouse mode for a window.
 This function is available since SDL 3.2.0.

 While the window has focus and relative mouse mode is enabled, the cursor
 is hidden, the mouse position is constrained to the window, and SDL will
 report continuous relative mouse motion even if the mouse is at the edge of
 the window.

 If you'd like to keep the mouse position fixed while in relative mode you
 can use SDL_SetWindowMouseRect(). If you'd like the cursor to be at a
 specific location when relative mode ends, you should use
 SDL_WarpMouseInWindow() before disabling relative mode.

 This function will flush any pending mouse motion for this window.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to change.`
 @param enabled : `true to enable relative mode, false to disable.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLWindow.set_relative_mouse_mode(&window, bool enabled) @extern("SDL_SetWindowRelativeMouseMode");

<*
 Query whether relative mouse mode is enabled for a window.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window to query.`
 @return `true if relative mode is enabled for a window or false otherwise.`
*>
extern fn bool SDLWindow.get_relative_mouse_mode(&window) @extern("SDL_GetWindowRelativeMouseMode");

<*
 Capture the mouse and to track input outside an SDL window.
 This function is available since SDL 3.2.0.

 Capturing enables your app to obtain mouse events globally, instead of just
 within your window. Not all video targets support this function. When
 capturing is enabled, the current window will get all mouse events, but
 unlike relative mode, no change is made to the cursor and it is not
 restrained to your window.

 This function may also deny mouse input to other windows--both those in
 your application and others on the system--so you should use this function
 sparingly, and in small bursts. For example, you might want to track the
 mouse while the user is dragging something, until the user releases a mouse
 button. It is not recommended that you capture the mouse for long periods
 of time, such as the entire time your app is running. For that, you should
 probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),
 depending on your goals.

 While captured, mouse events still report coordinates relative to the
 current (foreground) window, but those coordinates may be outside the
 bounds of the window (including negative values). Capturing is only allowed
 for the foreground window. If the window loses focus while capturing, the
 capture will be disabled automatically.

 While capturing is enabled, the current window will have the
 `SDL_WINDOW_MOUSE_CAPTURE` flag set.

 Please note that SDL will attempt to "auto capture" the mouse while the
 user is pressing a button; this is to try and make mouse behavior more
 consistent between platforms, and deal with the common case of a user
 dragging the mouse outside of the window. This means that if you are
 calling SDL_CaptureMouse() only to deal with this situation, you do not
 have to (although it is safe to do so). If this causes problems for your
 app, you can disable auto capture by setting the
 `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.

 threadsafety: This function should only be called on the main thread.

 @param enabled : `true to enable capturing, false to disable.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool capture_mouse(bool enabled) @extern("SDL_CaptureMouse");

<*
 Create a cursor using the specified bitmap data and mask (in MSB format).
 This function is available since SDL 3.2.0.

 `mask` has to be in MSB (Most Significant Bit) format.

 The cursor width (`w`) must be a multiple of 8 bits.

 The cursor is created in black and white according to the following:

 - data=0, mask=1: white
 - data=1, mask=1: black
 - data=0, mask=0: transparent
 - data=1, mask=0: inverted color if possible, black if not.

 Cursors created with this function must be freed with SDL_DestroyCursor().

 If you want to have a color cursor, or create your cursor from an
 SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can
 hide the cursor and draw your own as part of your game's rendering, but it
 will be bound to the framerate.

 Also, SDL_CreateSystemCursor() is available, which provides several
 readily-available system cursors to pick from.

 threadsafety: This function should only be called on the main thread.

 @param data : `the color value for each pixel of the cursor.`
 @param mask : `the mask value for each pixel of the cursor.`
 @param w : `the width of the cursor.`
 @param h : `the height of the cursor.`
 @param hot_x : `the x-axis offset from the left of the cursor image to the
              mouse x position, in the range of 0 to 'w' - 1.`
 @param hot_y : `the y-axis offset from the top of the cursor image to the
              mouse y position, in the range of 0 to 'h' - 1.`
 @return `a new cursor with the specified parameters on success or NULL on
          failure; call SDL_GetError() for more information.`
*>
extern fn SDLCursor* create_cursor(void* data, void* mask, int w, int h, int hot_x, int hot_y) @extern("SDL_CreateCursor");

<*
 Create a color cursor.
 This function is available since SDL 3.2.0.

 If this function is passed a surface with alternate representations, the
 surface will be interpreted as the content to be used for 100% display
 scale, and the alternate representations will be used for high DPI
 situations. For example, if the original surface is 32x32, then on a 2x
 macOS display or 200% display scale on Windows, a 64x64 version of the
 image will be used, if available. If a matching version of the image isn't
 available, the closest larger size image will be downscaled to the
 appropriate size and be used instead, if available. Otherwise, the closest
 smaller image will be upscaled and be used instead.

 threadsafety: This function should only be called on the main thread.

 @param surface : `an SDL_Surface structure representing the cursor image.`
 @param hot_x : `the x position of the cursor hot spot.`
 @param hot_y : `the y position of the cursor hot spot.`
 @return `the new cursor on success or NULL on failure; call SDL_GetError()
          for more information.`
*>
extern fn SDLCursor* create_color_cursor(SDLSurface* surface, int hot_x, int hot_y) @extern("SDL_CreateColorCursor");

<*
 Create a system cursor.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param id : `an SDL_SystemCursor enum value.`
 @return `a cursor on success or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLCursor* create_system_cursor(SDLSystemCursor id) @extern("SDL_CreateSystemCursor");

<*
 Set the active cursor.
 This function is available since SDL 3.2.0.

 This function sets the currently active cursor to the specified one. If the
 cursor is currently visible, the change will be immediately represented on
 the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if
 this is desired for any reason.

 threadsafety: This function should only be called on the main thread.

 @param cursor : `a cursor to make active.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool set_cursor(SDLCursor *cursor) @extern("SDL_SetCursor");

<*
 Get the active cursor.
 This function is available since SDL 3.2.0.

 This function returns a pointer to the current cursor which is owned by the
 library. It is not necessary to free the cursor with SDL_DestroyCursor().

 threadsafety: This function should only be called on the main thread.

 @return `the active cursor or NULL if there is no mouse.`
*>
extern fn SDLCursor* get_cursor() @extern("SDL_GetCursor");

<*
 Get the default cursor.
 This function is available since SDL 3.2.0.

 You do not have to call SDL_DestroyCursor() on the return value, but it is
 safe to do so.

 threadsafety: This function should only be called on the main thread.

 @return `the default cursor on success or NULL on failuree; call
          SDL_GetError() for more information.`
*>
extern fn SDLCursor* get_default_cursor() @extern("SDL_GetDefaultCursor");

<*
 Free a previously-created cursor.
 This function is available since SDL 3.2.0.

 Use this function to free cursor resources created with SDL_CreateCursor(),
 SDL_CreateColorCursor() or SDL_CreateSystemCursor().

 threadsafety: This function should only be called on the main thread.

 @param cursor : `the cursor to free.`
*>
extern fn void SDLCursor.destroy(&cursor) @extern("SDL_DestroyCursor");

<*
 Show the cursor.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool show_cursor() @extern("SDL_ShowCursor");

<*
 Hide the cursor.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool hide_cursor() @extern("SDL_HideCursor");

<*
 Return whether the cursor is currently being shown.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @return `true if the cursor is being shown, or false if the cursor is
          hidden.`
*>
extern fn bool cursor_visible() @extern("SDL_CursorVisible");
