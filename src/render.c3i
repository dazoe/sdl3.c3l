
<*
 Header file for SDL 2D rendering functions.

 This API supports the following features:

 - single pixel points
 - single pixel lines
 - filled rectangles
 - texture images
 - 2D polygons

 The primitives may be drawn in opaque, blended, or additive modes.

 The texture images may be drawn in opaque, blended, or additive modes. They
 can have an additional color tint or alpha modulation applied to them, and
 may also be stretched with linear interpolation.

 This API is designed to accelerate simple 2D operations. You may want more
 functionality such as polygons and particle effects and in that case you
 should use SDL's OpenGL/Direct3D support, the SDL3 GPU API, or one of the
 many good 3D engines.

 These functions must be called from the main thread. See this bug for
 details: https://github.com/libsdl-org/SDL/issues/986

 For more information, see
 https://wiki.libsdl.org/SDL3/CategoryRender
*>
module sdl;

<*
 The name of the software renderer.
 This macro is available since SDL 3.2.0.
*>
const SOFTWARE_RENDERER = "software";

<*
 Vertex structure.
 This struct is available since SDL 3.2.0.
*>
struct SDLVertex
{
	SDLFPoint position;        /**< Vertex position, in SDLRenderer coordinates  */
	SDLFColor color;           /**< Vertex color */
	SDLFPoint tex_coord;       /**< Normalized texture coordinates, if needed */
}

<*
 The access pattern allowed for a texture.
 This enum is available since SDL 3.2.0.
*>
enum SDLTextureAccess : const CInt
{
	STATIC,    /**< Changes rarely, not lockable */
	STREAMING, /**< Changes frequently, lockable */
	TARGET,    /**< Texture can be used as a render target */
}

<*
 How the logical size is mapped to the output.
 This enum is available since SDL 3.2.0.
*>
enum SDLRendererLogicalPresentation : const CInt
{
	DISABLED,        /**< There is no logical size in effect */
	STRETCH,         /**< The rendered content is stretched to the output resolution */
	LETTERBOX,       /**< The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars */
	OVERSCAN,        /**< The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds */
	INTEGER_SCALE,   /**< The rendered content is scaled up by integer multiples to fit the output resolution */
}

<*
 A structure representing rendering state
 This struct is available since SDL 3.2.0.
*>
typedef SDLRenderer = void;

<*
 An efficient driver-specific representation of pixel data
 This struct is available since SDL 3.2.0.
*>
struct SDLTexture
{
	SDLPixelFormat format;      /**< The format of the texture, read-only */
	CInt w;                      /**< The width of the texture, read-only. */
	CInt h;                      /**< The height of the texture, read-only. */

	CInt refcount;               /**< Application reference count, used when freeing texture */
}


/* Function prototypes */

<*
 Get the number of 2D rendering drivers available for the current display.
 This function is available since SDL 3.2.0.

 A render driver is a set of code that handles rendering and texture
 management on a particular display. Normally there is only one, but some
 drivers may have several available with different capabilities.

 There may be none if SDL was compiled without render support.

 threadsafety: It is safe to call this function from any thread.

 @return `the number of built in render drivers.`
*>
extern fn CInt get_num_render_drivers() @extern("SDL_GetNumRenderDrivers");

<*
 Use this function to get the name of a built in 2D rendering driver.
 This function is available since SDL 3.2.0.

 The list of rendering drivers is given in the order that they are normally
 initialized by default; the drivers that seem more reasonable to choose
 first (as far as the SDL developers believe) are earlier in the list.

 The names of drivers are all simple, low-ASCII identifiers, like "opengl",
 "direct3d12" or "metal". These never have Unicode characters, and are not
 meant to be proper names.

 threadsafety: It is safe to call this function from any thread.

 @param index : `the index of the rendering driver; the value ranges from 0 to
              SDL_GetNumRenderDrivers() - 1.`
 @return `the name of the rendering driver at the requested index, or NULL
          if an invalid index was specified.`
*>
extern fn ZString get_render_driver(CInt index) @extern("SDL_GetRenderDriver");

<*
 Create a window and default renderer.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param title : `the title of the window, in UTF-8 encoding.`
 @param width : `the width of the window.`
 @param height : `the height of the window.`
 @param window_flags : `the flags used to create the window (see
                     SDL_CreateWindow()).`
 @param window : `a pointer filled with the window, or NULL on error.`
 @param renderer : `a pointer filled with the renderer, or NULL on error.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool create_window_and_renderer(ZString title, CInt width, CInt height, SDLWindowFlags window_flags, SDLWindow** window, SDLRenderer** renderer) @extern("SDL_CreateWindowAndRenderer");

<*
 Create a 2D rendering context for a window.
 This function is available since SDL 3.2.0.

 If you want a specific renderer, you can specify its name here. A list of
 available renderers can be obtained by calling SDL_GetRenderDriver()
 multiple times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you
 don't need a specific renderer, specify NULL and SDL will attempt to choose
 the best option for you, based on what is available on the user's system.

 If `name` is a comma-separated list, SDL will try each name, in the order
 listed, until one succeeds or all of them fail.

 By default the rendering size matches the window size in pixels, but you
 can call SDL_SetRenderLogicalPresentation() to change the content size and
 scaling options.

 threadsafety: This function should only be called on the main thread.

 @param window : `the window where rendering is displayed.`
 @param name : `the name of the rendering driver to initialize, or NULL to let
             SDL choose one.`
 @return `a valid rendering context or NULL if there was an error; call
          SDL_GetError() for more information.`
*>
extern fn SDLRenderer* create_renderer(SDLWindow* window, ZString name) @extern("SDL_CreateRenderer");

<*
 Create a 2D rendering context for a window, with the specified properties.
 This function is available since SDL 3.2.0.

 These are the supported properties:

 - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver
   to use, if a specific one is desired
 - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is
   displayed, required if this isn't a software renderer using a surface
 - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering
   is displayed, if you want a software renderer without a window
 - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace
   value describing the colorspace for output to the display, defaults to
   SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers
   support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and
   supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing
   still uses the sRGB colorspace, but values can go beyond 1.0 and float
   (linear) format textures can be used for HDR content.
 - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want
   present synchronized with the refresh rate. This property can take any
   value that is supported by SDL_SetRenderVSync() for the renderer.

 With the vulkan renderer:

 - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use
   with the renderer, optional.
 - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use
   with the renderer, optional.
 - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the
   VkPhysicalDevice to use with the renderer, optional.
 - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use
   with the renderer, optional.
 - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the
   queue family index used for rendering.
 - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the
   queue family index used for presentation.

 threadsafety: This function should only be called on the main thread.

 @param props : `the properties to use.`
 @return `a valid rendering context or NULL if there was an error; call
          SDL_GetError() for more information.`
*>
extern fn SDLRenderer* create_renderer_with_properties(SDLPropertiesID props) @extern("SDL_CreateRendererWithProperties");

enum SDLPropRendererCreate : const inline ZString
{
	NAME_STRING =                                "SDL.renderer.create.name",
	WINDOW_POINTER =                             "SDL.renderer.create.window",
	SURFACE_POINTER =                            "SDL.renderer.create.surface",
	OUTPUT_COLORSPACE_NUMBER =                   "SDL.renderer.create.output_colorspace",
	PRESENT_VSYNC_NUMBER =                       "SDL.renderer.create.present_vsync",
	VULKAN_INSTANCE_POINTER =                    "SDL.renderer.create.vulkan.instance",
	VULKAN_SURFACE_NUMBER =                      "SDL.renderer.create.vulkan.surface",
	VULKAN_PHYSICAL_DEVICE_POINTER =             "SDL.renderer.create.vulkan.physical_device",
	VULKAN_DEVICE_POINTER =                      "SDL.renderer.create.vulkan.device",
	VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER =  "SDL.renderer.create.vulkan.graphics_queue_family_index",
	VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER =   "SDL.renderer.create.vulkan.present_queue_family_index",
}

<*
 Create a 2D software rendering context for a surface.
 This function is available since SDL 3.2.0.

 Two other API which can be used to create SDL_Renderer:
 SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_
 create a software renderer, but they are intended to be used with an
 SDL_Window as the final destination and not an SDL_Surface.

 threadsafety: This function should only be called on the main thread.

 @param surface : `the SDL_Surface structure representing the surface where
                rendering is done.`
 @return `a valid rendering context or NULL if there was an error; call
          SDL_GetError() for more information.`
*>
extern fn SDLRenderer* SDLSurface.create_software_renderer(&surface) @extern("SDL_CreateSoftwareRenderer");

<*
 Get the renderer associated with a window.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param window : `the window to query.`
 @return `the rendering context on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLRenderer* SDLWindow.get_renderer(&window) @extern("SDL_GetRenderer");

<*
 Get the window associated with a renderer.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param renderer : `the renderer to query.`
 @return `the window on success or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLWindow* SDLRenderer.get_window(&renderer) @extern("SDL_GetRenderWindow");

<*
 Get the name of a renderer.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param renderer : `the rendering context.`
 @return `the name of the selected renderer, or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn ZString SDLRenderer.get_name(&renderer) @extern("SDL_GetRendererName");

<*
 Get the properties associated with a renderer.
 This function is available since SDL 3.2.0.

 The following read-only properties are provided by SDL:

 - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver
 - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is
   displayed, if any
 - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is
   displayed, if this is a software renderer without a window
 - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting
 - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width
   and height
 - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)
   array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,
   representing the available texture formats for this renderer.
 - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_Colorspace value
   describing the colorspace for output to the display, defaults to
   SDL_COLORSPACE_SRGB.
 - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is
   SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with
   HDR enabled. This property can change dynamically when
   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the
   SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is
   automatically multiplied into the color scale. This property can change
   dynamically when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.
 - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range
   that can be displayed, in terms of the SDR white point. When HDR is not
   enabled, this will be 1.0. This property can change dynamically when
   SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.

 With the direct3d renderer:

 - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated
   with the renderer

 With the direct3d11 renderer:

 - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated
   with the renderer
 - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1
   associated with the renderer. This may change when the window is resized.

 With the direct3d12 renderer:

 - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated
   with the renderer
 - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4
   associated with the renderer.
 - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue
   associated with the renderer

 With the vulkan renderer:

 - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated
   with the renderer
 - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated
   with the renderer
 - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice
   associated with the renderer
 - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with
   the renderer
 - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue
   family index used for rendering
 - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue
   family index used for presentation
 - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of
   swapchain images, or potential frames in flight, used by the Vulkan
   renderer

 With the gpu renderer:

 - `SDL_PROP_RENDERER_GPU_DEVICE_POINTER`: the SDL_GPUDevice associated with
   the renderer

 threadsafety: It is safe to call this function from any thread.

 @param renderer : `the rendering context.`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLRenderer.get_properties(&renderer) @extern("SDL_GetRendererProperties");

enum SDLPropRenderer : const inline ZString
{
	NAME_STRING =                               "SDL.renderer.name",
	WINDOW_POINTER =                            "SDL.renderer.window",
	SURFACE_POINTER =                           "SDL.renderer.surface",
	VSYNC_NUMBER =                              "SDL.renderer.vsync",
	MAX_TEXTURE_SIZE_NUMBER =                   "SDL.renderer.max_texture_size",
	TEXTURE_FORMATS_POINTER =                   "SDL.renderer.texture_formats",
	OUTPUT_COLORSPACE_NUMBER =                  "SDL.renderer.output_colorspace",
	HDR_ENABLED_BOOLEAN =                       "SDL.renderer.HDR_enabled",
	SDR_WHITE_POINT_FLOAT =                     "SDL.renderer.SDR_white_point",
	HDR_HEADROOM_FLOAT =                        "SDL.renderer.HDR_headroom",
	D3D9_DEVICE_POINTER =                       "SDL.renderer.d3d9.device",
	D3D11_DEVICE_POINTER =                      "SDL.renderer.d3d11.device",
	D3D11_SWAPCHAIN_POINTER =                   "SDL.renderer.d3d11.swap_chain",
	D3D12_DEVICE_POINTER =                      "SDL.renderer.d3d12.device",
	D3D12_SWAPCHAIN_POINTER =                   "SDL.renderer.d3d12.swap_chain",
	D3D12_COMMAND_QUEUE_POINTER =               "SDL.renderer.d3d12.command_queue",
	VULKAN_INSTANCE_POINTER =                   "SDL.renderer.vulkan.instance",
	VULKAN_SURFACE_NUMBER =                     "SDL.renderer.vulkan.surface",
	VULKAN_PHYSICAL_DEVICE_POINTER =            "SDL.renderer.vulkan.physical_device",
	VULKAN_DEVICE_POINTER =                     "SDL.renderer.vulkan.device",
	VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER = "SDL.renderer.vulkan.graphics_queue_family_index",
	VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER =  "SDL.renderer.vulkan.present_queue_family_index",
	VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER =       "SDL.renderer.vulkan.swapchain_image_count",
	GPU_DEVICE_POINTER =                        "SDL.renderer.gpu.device",
}

<*
 Get the output size in pixels of a rendering context.
 This function is available since SDL 3.2.0.

 This returns the true output size in pixels, ignoring any render targets or
 logical size and presentation.

 For the output size of the current rendering target, with logical size
 adjustments, use SDL_GetCurrentRenderOutputSize() instead.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param w : `a pointer filled in with the width in pixels.`
 @param h : `a pointer filled in with the height in pixels.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_output_size(&renderer, CInt* w, CInt* h) @extern("SDL_GetRenderOutputSize");

<*
 Get the current output size in pixels of a rendering context.
 This function is available since SDL 3.2.0.

 If a rendering target is active, this will return the size of the rendering
 target in pixels, otherwise return the value of SDL_GetRenderOutputSize().

 Rendering target or not, the output will be adjusted by the current logical
 presentation state, dictated by SDL_SetRenderLogicalPresentation().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param w : `a pointer filled in with the current width.`
 @param h : `a pointer filled in with the current height.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_current_output_size(&renderer, CInt* w, CInt* h) @extern("SDL_GetCurrentRenderOutputSize");

<*
 Create a texture for a rendering context.
 This function is available since SDL 3.2.0.

 The contents of a texture when first created are not defined.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param format : `one of the enumerated values in SDL_PixelFormat.`
 @param access : `one of the enumerated values in SDL_TextureAccess.`
 @param w : `the width of the texture in pixels.`
 @param h : `the height of the texture in pixels.`
 @return `the created texture or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLTexture* SDLRenderer.create_texture(&renderer, SDLPixelFormat format, SDLTextureAccess access, CInt w, CInt h) @extern("SDL_CreateTexture");

<*
 Create a texture from an existing surface.
 This function is available since SDL 3.2.0.

 The surface is not modified or freed by this function.

 The SDL_TextureAccess hint for the created texture is
 `SDL_TEXTUREACCESS_STATIC`.

 The pixel format of the created texture may be different from the pixel
 format of the surface, and can be queried using the
 SDL_PROP_TEXTURE_FORMAT_NUMBER property.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param surface : `the SDL_Surface structure containing pixel data used to fill
                the texture.`
 @return `the created texture or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLTexture* SDLRenderer.create_texture_from_surface(&renderer, SDLSurface *surface) @extern("SDL_CreateTextureFromSurface");

<*
 Create a texture for a rendering context with the specified properties.
 This function is available since SDL 3.2.0.

 These are the supported properties:

 - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_Colorspace value
   describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR
   for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,
   SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for
   YUV textures.
 - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in
   SDL_PixelFormat, defaults to the best RGBA format for the renderer
 - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in
   SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC
 - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in
   pixels, required
 - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in
   pixels, required
 - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating
   point textures, this defines the value of 100% diffuse white, with higher
   values being displayed in the High Dynamic Range headroom. This defaults
   to 100 for HDR10 textures and 1.0 for floating point textures.
 - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating
   point textures, this defines the maximum dynamic range used by the
   content, in terms of the SDR white point. This would be equivalent to
   maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.
   If this is defined, any values outside the range supported by the display
   will be scaled into the available HDR headroom, otherwise they are
   clipped.

 With the direct3d11 renderer:

 - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D
   associated with the texture, if you want to wrap an existing texture.
 - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
   associated with the U plane of a YUV texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
   associated with the V plane of a YUV texture, if you want to wrap an
   existing texture.

 With the direct3d12 renderer:

 - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource
   associated with the texture, if you want to wrap an existing texture.
 - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource
   associated with the U plane of a YUV texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource
   associated with the V plane of a YUV texture, if you want to wrap an
   existing texture.

 With the metal renderer:

 - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef
   associated with the texture, if you want to create a texture from an
   existing pixel buffer.

 With the opengl renderer:

 - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture
   associated with the texture, if you want to wrap an existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
   associated with the UV plane of an NV12 texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture
   associated with the U plane of a YUV texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture
   associated with the V plane of a YUV texture, if you want to wrap an
   existing texture.

 With the opengles2 renderer:

 - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   associated with the texture, if you want to wrap an existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   associated with the texture, if you want to wrap an existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
   associated with the UV plane of an NV12 texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
   associated with the U plane of a YUV texture, if you want to wrap an
   existing texture.
 - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
   associated with the V plane of a YUV texture, if you want to wrap an
   existing texture.

 With the vulkan renderer:

 - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout
   VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if
   you want to wrap an existing texture.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param props : `the properties to use.`
 @return `the created texture or NULL on failure; call SDL_GetError() for
          more information.`
*>
extern fn SDLTexture* SDLRenderer.create_texture_with_properties(&renderer, SDLPropertiesID props) @extern("SDL_CreateTextureWithProperties");

enum SDLPropTextureCreate : const inline ZString
{
	COLORSPACE_NUMBER =           "SDL.texture.create.colorspace",
	FORMAT_NUMBER =               "SDL.texture.create.format",
	ACCESS_NUMBER =               "SDL.texture.create.access",
	WIDTH_NUMBER =                "SDL.texture.create.width",
	HEIGHT_NUMBER =               "SDL.texture.create.height",
	SDR_WHITE_POINT_FLOAT =       "SDL.texture.create.SDR_white_point",
	HDR_HEADROOM_FLOAT =          "SDL.texture.create.HDR_headroom",
	D3D11_TEXTURE_POINTER =       "SDL.texture.create.d3d11.texture",
	D3D11_TEXTURE_U_POINTER =     "SDL.texture.create.d3d11.texture_u",
	D3D11_TEXTURE_V_POINTER =     "SDL.texture.create.d3d11.texture_v",
	D3D12_TEXTURE_POINTER =       "SDL.texture.create.d3d12.texture",
	D3D12_TEXTURE_U_POINTER =     "SDL.texture.create.d3d12.texture_u",
	D3D12_TEXTURE_V_POINTER =     "SDL.texture.create.d3d12.texture_v",
	METAL_PIXELBUFFER_POINTER =   "SDL.texture.create.metal.pixelbuffer",
	OPENGL_TEXTURE_NUMBER =       "SDL.texture.create.opengl.texture",
	OPENGL_TEXTURE_UV_NUMBER =    "SDL.texture.create.opengl.texture_uv",
	OPENGL_TEXTURE_U_NUMBER =     "SDL.texture.create.opengl.texture_u",
	OPENGL_TEXTURE_V_NUMBER =     "SDL.texture.create.opengl.texture_v",
	OPENGLES2_TEXTURE_NUMBER =    "SDL.texture.create.opengles2.texture",
	OPENGLES2_TEXTURE_UV_NUMBER = "SDL.texture.create.opengles2.texture_uv",
	OPENGLES2_TEXTURE_U_NUMBER =  "SDL.texture.create.opengles2.texture_u",
	OPENGLES2_TEXTURE_V_NUMBER =  "SDL.texture.create.opengles2.texture_v",
	VULKAN_TEXTURE_NUMBER =       "SDL.texture.create.vulkan.texture",
}

<*
 Get the properties associated with a texture.
 This function is available since SDL 3.2.0.

 The following read-only properties are provided by SDL:

 - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_Colorspace value describing
   the texture colorspace.
 - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in
   SDL_PixelFormat.
 - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in
   SDL_TextureAccess.
 - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.
 - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.
 - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point
   textures, this defines the value of 100% diffuse white, with higher
   values being displayed in the High Dynamic Range headroom. This defaults
   to 100 for HDR10 textures and 1.0 for other textures.
 - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point
   textures, this defines the maximum dynamic range used by the content, in
   terms of the SDR white point. If this is defined, any values outside the
   range supported by the display will be scaled into the available HDR
   headroom, otherwise they are clipped. This defaults to 1.0 for SDR
   textures, 4.0 for HDR10 textures, and no default for floating point
   textures.

 With the direct3d11 renderer:

 - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated
   with the texture
 - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D
   associated with the U plane of a YUV texture
 - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D
   associated with the V plane of a YUV texture

 With the direct3d12 renderer:

 - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated
   with the texture
 - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated
   with the U plane of a YUV texture
 - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated
   with the V plane of a YUV texture

 With the vulkan renderer:

 - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the
   texture

 With the opengl renderer:

 - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated
   with the texture
 - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture
   associated with the UV plane of an NV12 texture
 - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated
   with the U plane of a YUV texture
 - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated
   with the V plane of a YUV texture
 - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the
   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)
 - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of
   the texture (0.0 - 1.0)
 - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of
   the texture (0.0 - 1.0)

 With the opengles2 renderer:

 - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture
   associated with the texture
 - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture
   associated with the UV plane of an NV12 texture
 - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture
   associated with the U plane of a YUV texture
 - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture
   associated with the V plane of a YUV texture
 - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the
   texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)

 threadsafety: It is safe to call this function from any thread.

 @param texture : `the texture to query.`
 @return `a valid property ID on success or 0 on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLPropertiesID SDLTexture.get_properties(&texture) @extern("SDL_GetTextureProperties");

enum SDLPropTexture : const inline ZString
{
	COLORSPACE_NUMBER =                  "SDL.texture.colorspace",
	FORMAT_NUMBER =                      "SDL.texture.format",
	ACCESS_NUMBER =                      "SDL.texture.access",
	WIDTH_NUMBER =                       "SDL.texture.width",
	HEIGHT_NUMBER =                      "SDL.texture.height",
	SDR_WHITE_POINT_FLOAT =              "SDL.texture.SDR_white_point",
	HDR_HEADROOM_FLOAT =                 "SDL.texture.HDR_headroom",
	D3D11_TEXTURE_POINTER =              "SDL.texture.d3d11.texture",
	D3D11_TEXTURE_U_POINTER =            "SDL.texture.d3d11.texture_u",
	D3D11_TEXTURE_V_POINTER =            "SDL.texture.d3d11.texture_v",
	D3D12_TEXTURE_POINTER =              "SDL.texture.d3d12.texture",
	D3D12_TEXTURE_U_POINTER =            "SDL.texture.d3d12.texture_u",
	D3D12_TEXTURE_V_POINTER =            "SDL.texture.d3d12.texture_v",
	OPENGL_TEXTURE_NUMBER =              "SDL.texture.opengl.texture",
	OPENGL_TEXTURE_UV_NUMBER =           "SDL.texture.opengl.texture_uv",
	OPENGL_TEXTURE_U_NUMBER =            "SDL.texture.opengl.texture_u",
	OPENGL_TEXTURE_V_NUMBER =            "SDL.texture.opengl.texture_v",
	OPENGL_TEXTURE_TARGET_NUMBER =       "SDL.texture.opengl.target",
	OPENGL_TEX_W_FLOAT =                 "SDL.texture.opengl.tex_w",
	OPENGL_TEX_H_FLOAT =                 "SDL.texture.opengl.tex_h",
	OPENGLES2_TEXTURE_NUMBER =           "SDL.texture.opengles2.texture",
	OPENGLES2_TEXTURE_UV_NUMBER =        "SDL.texture.opengles2.texture_uv",
	OPENGLES2_TEXTURE_U_NUMBER =         "SDL.texture.opengles2.texture_u",
	OPENGLES2_TEXTURE_V_NUMBER =         "SDL.texture.opengles2.texture_v",
	OPENGLES2_TEXTURE_TARGET_NUMBER =    "SDL.texture.opengles2.target",
	VULKAN_TEXTURE_NUMBER =              "SDL.texture.vulkan.texture",
}

<*
 Get the renderer that created an SDL_Texture.
 This function is available since SDL 3.2.0.

 threadsafety: It is safe to call this function from any thread.

 @param texture : `the texture to query.`
 @return `a pointer to the SDL_Renderer that created the texture, or NULL on
          failure; call SDL_GetError() for more information.`
*>
extern fn SDLRenderer* SDLTexture.get_renderer(&texture) @extern("SDL_GetRendererFromTexture");

<*
 Get the size of a texture, as floating point values.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param w : `a pointer filled in with the width of the texture in pixels. This
          argument can be NULL if you don't need this information.`
 @param h : `a pointer filled in with the height of the texture in pixels. This
          argument can be NULL if you don't need this information.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_size(&texture, float* w, float* h) @extern("SDL_GetTextureSize");

<*
 Set an additional color value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 When this texture is rendered, during the copy operation each source color
 channel is modulated by the appropriate color value according to the
 following formula:

 `srcC = srcC * (color / 255)`

 Color modulation is not always supported by the renderer; it will return
 false if color modulation is not supported.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param r : `the red color value multiplied into copy operations.`
 @param g : `the green color value multiplied into copy operations.`
 @param b : `the blue color value multiplied into copy operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_color_mod(&texture, char r, char g, char b) @extern("SDL_SetTextureColorMod");

<*
 Set an additional color value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 When this texture is rendered, during the copy operation each source color
 channel is modulated by the appropriate color value according to the
 following formula:

 `srcC = srcC * color`

 Color modulation is not always supported by the renderer; it will return
 false if color modulation is not supported.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param r : `the red color value multiplied into copy operations.`
 @param g : `the green color value multiplied into copy operations.`
 @param b : `the blue color value multiplied into copy operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_color_mod_float(&texture, float r, float g, float b) @extern("SDL_SetTextureColorModFloat");

<*
 Get the additional color value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param r : `a pointer filled in with the current red color value.`
 @param g : `a pointer filled in with the current green color value.`
 @param b : `a pointer filled in with the current blue color value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_color_mod(&texture, char* r, char* g, char* b) @extern("SDL_GetTextureColorMod");

<*
 Get the additional color value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param r : `a pointer filled in with the current red color value.`
 @param g : `a pointer filled in with the current green color value.`
 @param b : `a pointer filled in with the current blue color value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_color_mod_float(&texture, float* r, float* g, float* b) @extern("SDL_GetTextureColorModFloat");

<*
 Set an additional alpha value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 When this texture is rendered, during the copy operation the source alpha
 value is modulated by this alpha value according to the following formula:

 `srcA = srcA * (alpha / 255)`

 Alpha modulation is not always supported by the renderer; it will return
 false if alpha modulation is not supported.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param alpha : `the source alpha value multiplied into copy operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_alpha_mod(&texture, char alpha) @extern("SDL_SetTextureAlphaMod");

<*
 Set an additional alpha value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 When this texture is rendered, during the copy operation the source alpha
 value is modulated by this alpha value according to the following formula:

 `srcA = srcA * alpha`

 Alpha modulation is not always supported by the renderer; it will return
 false if alpha modulation is not supported.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param alpha : `the source alpha value multiplied into copy operations.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_alpha_mod_float(&texture, float alpha) @extern("SDL_SetTextureAlphaModFloat");

<*
 Get the additional alpha value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param alpha : `a pointer filled in with the current alpha value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_alpha_mod(&texture, char* alpha) @extern("SDL_GetTextureAlphaMod");

<*
 Get the additional alpha value multiplied into render copy operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param alpha : `a pointer filled in with the current alpha value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_alpha_mod_float(&texture, float* alpha) @extern("SDL_GetTextureAlphaModFloat");

<*
 Set the blend mode for a texture, used by SDL_RenderTexture().
 This function is available since SDL 3.2.0.

 If the blend mode is not supported, the closest supported mode is chosen
 and this function returns false.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param blendMode : `the SDL_BlendMode to use for texture blending.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_blend_mode(&texture, SDLBlendMode blendMode) @extern("SDL_SetTextureBlendMode");

<*
 Get the blend mode used for texture copy operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param blendMode : `a pointer filled in with the current SDL_BlendMode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_blend_mode(&texture, SDLBlendMode* blendMode) @extern("SDL_GetTextureBlendMode");

<*
 Set the scale mode used for texture scale operations.
 This function is available since SDL 3.2.0.

 The default texture scale mode is SDL_SCALEMODE_LINEAR.

 If the scale mode is not supported, the closest supported mode is chosen.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param scaleMode : `the SDL_ScaleMode to use for texture scaling.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.set_scale_mode(&texture, SDLScaleMode scaleMode) @extern("SDL_SetTextureScaleMode");

<*
 Get the scale mode used for texture scale operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to query.`
 @param scaleMode : `a pointer filled in with the current scale mode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.get_scale_mode(&texture, SDLScaleMode* scaleMode) @extern("SDL_GetTextureScaleMode");

<*
 Update the given texture rectangle with new pixel data.
 This function is available since SDL 3.2.0.

 The pixel data must be in the pixel format of the texture, which can be
 queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.

 This is a fairly slow function, intended for use with static textures that
 do not change often.

 If the texture is intended to be updated often, it is preferred to create
 the texture as streaming and use the locking functions referenced below.
 While this function will work with streaming textures, for optimization
 reasons you may not get the pixels back if you lock the texture afterward.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param rect : `an SDL_Rect structure representing the area to update, or NULL
             to update the entire texture.`
 @param pixels : `the raw pixel data in the format of the texture.`
 @param pitch : `the number of bytes in a row of pixel data, including padding
              between lines.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.update(&texture, SDLRect* rect, void* pixels, CInt pitch) @extern("SDL_UpdateTexture");

<*
 Update a rectangle within a planar YV12 or IYUV texture with new pixel
 data.
 This function is available since SDL 3.2.0.

 You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 block of Y and U/V planes in the proper order, but this function is
 available if your pixel data is not contiguous.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param rect : `a pointer to the rectangle of pixels to update, or NULL to
             update the entire texture.`
 @param y_plane : `the raw pixel data for the Y plane.`
 @param y_pitch : `the number of bytes between rows of pixel data for the Y
               plane.`
 @param u_plane : `the raw pixel data for the U plane.`
 @param u_pitch : `the number of bytes between rows of pixel data for the U
               plane.`
 @param v_plane : `the raw pixel data for the V plane.`
 @param v_pitch : `the number of bytes between rows of pixel data for the V
               plane.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.update_yuv(&texture, SDLRect* rect, char* y_plane, CInt y_pitch, char* u_plane, CInt u_pitch, char* v_plane, CInt v_pitch) @extern("SDL_UpdateYUVTexture");

<*
 Update a rectangle within a planar NV12 or NV21 texture with new pixels.
 This function is available since SDL 3.2.0.

 You can use SDL_UpdateTexture() as long as your pixel data is a contiguous
 block of NV12/21 planes in the proper order, but this function is available
 if your pixel data is not contiguous.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to update.`
 @param rect : `a pointer to the rectangle of pixels to update, or NULL to
             update the entire texture.`
 @param y_plane : `the raw pixel data for the Y plane.`
 @param y_pitch : `the number of bytes between rows of pixel data for the Y
               plane.`
 @param uv_plane : `the raw pixel data for the UV plane.`
 @param uv_pitch : `the number of bytes between rows of pixel data for the UV
                plane.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.update_nv(&texture, SDLRect* rect, char* y_plane, CInt y_pitch, char* uv_plane, CInt uv_pitch) @extern("SDL_UpdateNVTexture");

<*
 Lock a portion of the texture for **write-only** pixel access.
 This function is available since SDL 3.2.0.

 As an optimization, the pixels made available for editing don't necessarily
 contain the old texture data. This is a write-only operation, and if you
 need to keep a copy of the texture data you should do that at the
 application level.

 You must use SDL_UnlockTexture() to unlock the pixels and apply any
 changes.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to lock for access, which was created with
                'SDL_TEXTUREACCESS_STREAMING'.`
 @param rect : `an SDL_Rect structure representing the area to lock for access;
             NULL to lock the entire texture.`
 @param pixels : `this is filled in with a pointer to the locked pixels,
               appropriately offset by the locked area.`
 @param pitch : `this is filled in with the pitch of the locked pixels; the
              pitch is the length of one row in bytes.`
 @return `true on success or false if the texture is not valid or was not
          created with 'SDL_TEXTUREACCESS_STREAMING'; call SDL_GetError()
          for more information.`
*>
extern fn bool SDLTexture.lock(&texture, SDLRect* rect, void** pixels, CInt* pitch) @extern("SDL_LockTexture");

<*
 Lock a portion of the texture for **write-only** pixel access, and expose
 it as a SDL surface.
 This function is available since SDL 3.2.0.

 Besides providing an SDL_Surface instead of raw pixel data, this function
 operates like SDL_LockTexture.

 As an optimization, the pixels made available for editing don't necessarily
 contain the old texture data. This is a write-only operation, and if you
 need to keep a copy of the texture data you should do that at the
 application level.

 You must use SDL_UnlockTexture() to unlock the pixels and apply any
 changes.

 The returned surface is freed internally after calling SDL_UnlockTexture()
 or SDL_DestroyTexture(). The caller should not free it.

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to lock for access, which must be created with
                'SDL_TEXTUREACCESS_STREAMING'.`
 @param rect : `a pointer to the rectangle to lock for access. If the rect is
             NULL, the entire texture will be locked.`
 @param surface : `a pointer to an SDL surface of size **rect**. Don't assume
                any specific pixel content.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLTexture.lock_to_surface(&texture, SDLRect* rect, SDLSurface** surface) @extern("SDL_LockTextureToSurface");

<*
 Unlock a texture, uploading the changes to video memory, if needed.
 This function is available since SDL 3.2.0.

 **Warning**: Please note that SDL_LockTexture() is intended to be
 write-only; it will not guarantee the previous contents of the texture will
 be provided. You must fully initialize any area of a texture that you lock
 before unlocking it, as the pixels might otherwise be uninitialized memory.

 Which is to say: locking and immediately unlocking a texture can result in
 corrupted textures, depending on the renderer in use.

 threadsafety: This function should only be called on the main thread.

 @param texture : `a texture locked by SDL_LockTexture().`
*>
extern fn void SDLTexture.unlock(&texture) @extern("SDL_UnlockTexture");

<*
 Set a texture as the current rendering target.
 This function is available since SDL 3.2.0.

 The default render target is the window for which the renderer was created.
 To stop rendering to a texture and render to the window again, call this
 function with a NULL `texture`.

 Viewport, cliprect, scale, and logical presentation are unique to each
 render target. Get and set functions for these states apply to the current
 render target set by this function, and those states persist on each target
 when the current render target changes.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param texture : `the targeted texture, which must be created with the
                'SDL_TEXTUREACCESS_TARGET' flag, or NULL to render to the
                window instead of a texture.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_target(&renderer, SDLTexture* texture) @extern("SDL_SetRenderTarget");

<*
 Get the current render target.
 This function is available since SDL 3.2.0.

 The default render target is the window for which the renderer was created,
 and is reported a NULL here.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `the current render target or NULL for the default render target.`
*>
extern fn SDLTexture* SDLRenderer.get_target(&renderer) @extern("SDL_GetRenderTarget");

<*
 Set a device-independent resolution and presentation mode for rendering.
 This function is available since SDL 3.2.0.

 This function sets the width and height of the logical rendering output.
 The renderer will act as if the current render target is always the
 requested dimensions, scaling to the actual resolution as necessary.

 This can be useful for games that expect a fixed size, but would like to
 scale the output to whatever is available, regardless of how a user resizes
 a window, or if the display is high DPI.

 Logical presentation can be used with both render target textures and the
 renderer's window; the state is unique to each render target, and this
 function sets the state for the current render target. It might be useful
 to draw to a texture that matches the window dimensions with logical
 presentation enabled, and then draw that texture across the entire window
 with logical presentation disabled. Be careful not to render both with
 logical presentation enabled, however, as this could produce
 double-letterboxing, etc.

 You can disable logical coordinates by setting the mode to
 SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel
 resolution of the render target; it is safe to toggle logical presentation
 during the rendering of a frame: perhaps most of the rendering is done to
 specific dimensions but to make fonts look sharp, the app turns off logical
 presentation while drawing text, for example.

 For the renderer's window, letterboxing is drawn into the framebuffer if
 logical presentation is enabled during SDL_RenderPresent; be sure to
 reenable it before presenting if you were toggling it, otherwise the
 letterbox areas might have artifacts from previous frames (or artifacts
 from external overlays, etc). Letterboxing is never drawn into texture
 render targets; be sure to call SDL_RenderClear() before drawing into the
 texture so the letterboxing areas are cleared, if appropriate.

 You can convert coordinates in an event into rendering coordinates using
 SDL_ConvertEventToRenderCoordinates().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param w : `the width of the logical resolution.`
 @param h : `the height of the logical resolution.`
 @param mode : `the presentation mode used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_logical_presentation(&renderer, CInt w, CInt h, SDLRendererLogicalPresentation mode) @extern("SDL_SetRenderLogicalPresentation");

<*
 Get device independent resolution and presentation mode for rendering.
 This function is available since SDL 3.2.0.

 This function gets the width and height of the logical rendering output, or
 the output size in pixels if a logical resolution is not enabled.

 Each render target has its own logical presentation state. This function
 gets the state for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param w : `an int to be filled with the width.`
 @param h : `an int to be filled with the height.`
 @param mode : `the presentation mode used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_logical_presentation(&renderer, CInt* w, CInt* h, SDLRendererLogicalPresentation* mode) @extern("SDL_GetRenderLogicalPresentation");

<*
 Get the final presentation rectangle for rendering.
 This function is available since SDL 3.2.0.

 This function returns the calculated rectangle used for logical
 presentation, based on the presentation mode and output size. If logical
 presentation is disabled, it will fill the rectangle with the output size,
 in pixels.

 Each render target has its own logical presentation state. This function
 gets the rectangle for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `a pointer filled in with the final presentation rectangle, may
             be NULL.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_logical_presentation_rect(&renderer, SDLFRect* rect) @extern("SDL_GetRenderLogicalPresentationRect");

<*
 Get a point in render coordinates when given a point in window coordinates.
 This function is available since SDL 3.2.0.

 This takes into account several states:

 - The window dimensions.
 - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 - The scale (SDL_SetRenderScale)
 - The viewport (SDL_SetRenderViewport)

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param window_x : `the x coordinate in window coordinates.`
 @param window_y : `the y coordinate in window coordinates.`
 @param x : `a pointer filled with the x coordinate in render coordinates.`
 @param y : `a pointer filled with the y coordinate in render coordinates.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.coordinates_from_window(&renderer, float window_x, float window_y, float* x, float* y) @extern("SDL_RenderCoordinatesFromWindow");

<*
 Get a point in window coordinates when given a point in render coordinates.
 This function is available since SDL 3.2.0.

 This takes into account several states:

 - The window dimensions.
 - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 - The scale (SDL_SetRenderScale)
 - The viewport (SDL_SetRenderViewport)

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param x : `the x coordinate in render coordinates.`
 @param y : `the y coordinate in render coordinates.`
 @param window_x : `a pointer filled with the x coordinate in window
                 coordinates.`
 @param window_y : `a pointer filled with the y coordinate in window
                 coordinates.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.coordinates_to_window(&renderer, float x, float y, float* window_x, float* window_y) @extern("SDL_RenderCoordinatesToWindow");

<*
 Convert the coordinates in an event to render coordinates.
 This function is available since SDL 3.2.0.

 This takes into account several states:

 - The window dimensions.
 - The logical presentation settings (SDL_SetRenderLogicalPresentation)
 - The scale (SDL_SetRenderScale)
 - The viewport (SDL_SetRenderViewport)

 Various event types are converted with this function: mouse, touch, pen,
 etc.

 Touch coordinates are converted from normalized coordinates in the window
 to non-normalized rendering coordinates.

 Relative mouse coordinates (xrel and yrel event fields) are _also_
 converted. Applications that do not want these fields converted should use
 SDL_RenderCoordinatesFromWindow() on the specific event fields instead of
 converting the entire event structure.

 Once converted, coordinates may be outside the rendering area.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param event : `the event to modify.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.convert_event_to_coordinates(&renderer, SDLEvent* event) @extern("SDL_ConvertEventToRenderCoordinates");

<*
 Set the drawing area for rendering on the current target.
 This function is available since SDL 3.2.0.

 Drawing will clip to this area (separately from any clipping done with
 SDL_SetRenderClipRect), and the top left of the area will become coordinate
 (0, 0) for future drawing commands.

 The area's width and height must be >= 0.

 Each render target has its own viewport. This function sets the viewport
 for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `the SDL_Rect structure representing the drawing area, or NULL
             to set the viewport to the entire target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_viewport(&renderer, SDLRect* rect) @extern("SDL_SetRenderViewport");

<*
 Get the drawing area for the current target.
 This function is available since SDL 3.2.0.

 Each render target has its own viewport. This function gets the viewport
 for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `an SDL_Rect structure filled in with the current drawing area.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_viewport(&renderer, SDLRect* rect) @extern("SDL_GetRenderViewport");

<*
 Return whether an explicit rectangle was set as the viewport.
 This function is available since SDL 3.2.0.

 This is useful if you're saving and restoring the viewport and want to know
 whether you should restore a specific rectangle or NULL.

 Each render target has its own viewport. This function checks the viewport
 for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `true if the viewport was set to a specific rectangle, or false if
          it was set to NULL (the entire target).`
*>
extern fn bool SDLRenderer.viewport_set(&renderer) @extern("SDL_RenderViewportSet");

<*
 Get the safe area for rendering within the current viewport.
 This function is available since SDL 3.2.0.

 Some devices have portions of the screen which are partially obscured or
 not interactive, possibly due to on-screen controls, curved edges, camera
 notches, TV overscan, etc. This function provides the area of the current
 viewport which is safe to have interactible content. You should continue
 rendering into the rest of the render target, but it should not contain
 visually important or interactible content.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `a pointer filled in with the area that is safe for interactive
             content.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_safe_area(&renderer, SDLRect* rect) @extern("SDL_GetRenderSafeArea");

<*
 Set the clip rectangle for rendering on the specified target.
 This function is available since SDL 3.2.0.

 Each render target has its own clip rectangle. This function sets the
 cliprect for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `an SDL_Rect structure representing the clip area, relative to
             the viewport, or NULL to disable clipping.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_clip_rect(&renderer, SDLRect* rect) @extern("SDL_SetRenderClipRect");

<*
 Get the clip rectangle for the current target.
 This function is available since SDL 3.2.0.

 Each render target has its own clip rectangle. This function gets the
 cliprect for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `an SDL_Rect structure filled in with the current clipping area
             or an empty rectangle if clipping is disabled.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_clip_rect(&renderer, SDLRect* rect) @extern("SDL_GetRenderClipRect");

<*
 Get whether clipping is enabled on the given render target.
 This function is available since SDL 3.2.0.

 Each render target has its own clip rectangle. This function checks the
 cliprect for the current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `true if clipping is enabled or false if not; call SDL_GetError()
          for more information.`
*>
extern fn bool SDLRenderer.clip_enabled(&renderer) @extern("SDL_RenderClipEnabled");

<*
 Set the drawing scale for rendering on the current target.
 This function is available since SDL 3.2.0.

 The drawing coordinates are scaled by the x/y scaling factors before they
 are used by the renderer. This allows resolution independent drawing with a
 single coordinate system.

 If this results in scaling or subpixel drawing by the rendering backend, it
 will be handled using the appropriate quality hints. For best results use
 integer scaling factors.

 Each render target has its own scale. This function sets the scale for the
 current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param scale_x : `the horizontal scaling factor.`
 @param scale_y : `the vertical scaling factor.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_scale(&renderer, float scale_x, float scale_y) @extern("SDL_SetRenderScale");

<*
 Get the drawing scale for the current target.
 This function is available since SDL 3.2.0.

 Each render target has its own scale. This function gets the scale for the
 current render target.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param scale_x : `a pointer filled in with the horizontal scaling factor.`
 @param scale_y : `a pointer filled in with the vertical scaling factor.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_scale(&renderer, float* scale_x, float* scale_y) @extern("SDL_GetRenderScale");

<*
 Set the color used for drawing operations.
 This function is available since SDL 3.2.0.

 Set the color for drawing or filling rectangles, lines, and points, and for
 SDL_RenderClear().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param r : `the red value used to draw on the rendering target.`
 @param g : `the green value used to draw on the rendering target.`
 @param b : `the blue value used to draw on the rendering target.`
 @param a : `the alpha value used to draw on the rendering target; usually
          'SDL_ALPHA_OPAQUE' (255). Use SDL_SetRenderDrawBlendMode to
          specify how the alpha channel is used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_draw_color(&renderer, char r, char g, char b, char a) @extern("SDL_SetRenderDrawColor");

<*
 Set the color used for drawing operations (Rect, Line and Clear).
 This function is available since SDL 3.2.0.

 Set the color for drawing or filling rectangles, lines, and points, and for
 SDL_RenderClear().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param r : `the red value used to draw on the rendering target.`
 @param g : `the green value used to draw on the rendering target.`
 @param b : `the blue value used to draw on the rendering target.`
 @param a : `the alpha value used to draw on the rendering target. Use
          SDL_SetRenderDrawBlendMode to specify how the alpha channel is
          used.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_draw_color_float(&renderer, float r, float g, float b, float a) @extern("SDL_SetRenderDrawColorFloat");

<*
 Get the color used for drawing operations (Rect, Line and Clear).
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param r : `a pointer filled in with the red value used to draw on the
          rendering target.`
 @param g : `a pointer filled in with the green value used to draw on the
          rendering target.`
 @param b : `a pointer filled in with the blue value used to draw on the
          rendering target.`
 @param a : `a pointer filled in with the alpha value used to draw on the
          rendering target; usually 'SDL_ALPHA_OPAQUE' (255).`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_draw_color(&renderer, char* r, char* g, char* b, char* a) @extern("SDL_GetRenderDrawColor");

<*
 Get the color used for drawing operations (Rect, Line and Clear).
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param r : `a pointer filled in with the red value used to draw on the
          rendering target.`
 @param g : `a pointer filled in with the green value used to draw on the
          rendering target.`
 @param b : `a pointer filled in with the blue value used to draw on the
          rendering target.`
 @param a : `a pointer filled in with the alpha value used to draw on the
          rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_draw_color_float(&renderer, float* r, float* g, float* b, float* a) @extern("SDL_GetRenderDrawColorFloat");

<*
 Set the color scale used for render operations.
 This function is available since SDL 3.2.0.

 The color scale is an additional scale multiplied into the pixel color
 value while rendering. This can be used to adjust the brightness of colors
 during HDR rendering, or changing HDR video brightness when playing on an
 SDR display.

 The color scale does not affect the alpha channel, only the color
 brightness.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param scale : `the color scale value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_color_scale(&renderer, float scale) @extern("SDL_SetRenderColorScale");

<*
 Get the color scale used for render operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param scale : `a pointer filled in with the current color scale value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_color_scale(&renderer, float* scale) @extern("SDL_GetRenderColorScale");

<*
 Set the blend mode used for drawing operations (Fill and Line).
 This function is available since SDL 3.2.0.

 If the blend mode is not supported, the closest supported mode is chosen.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param blendMode : `the SDL_BlendMode to use for blending.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_draw_blend_mode(&renderer, SDLBlendMode blendMode) @extern("SDL_SetRenderDrawBlendMode");

<*
 Get the blend mode used for drawing operations.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param blendMode : `a pointer filled in with the current SDL_BlendMode.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_draw_blend_mode(&renderer, SDLBlendMode* blendMode) @extern("SDL_GetRenderDrawBlendMode");

<*
 Clear the current rendering target with the drawing color.
 This function is available since SDL 3.2.0.

 This function clears the entire rendering target, ignoring the viewport and
 the clip rectangle. Note, that clearing will also set/fill all pixels of
 the rendering target to current renderer draw color, so make sure to invoke
 SDL_SetRenderDrawColor() when needed.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.clear(&renderer) @extern("SDL_RenderClear");

<*
 Draw a point on the current rendering target at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw a point.`
 @param x : `the x coordinate of the point.`
 @param y : `the y coordinate of the point.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.point(&renderer, float x, float y) @extern("SDL_RenderPoint");

<*
 Draw multiple points on the current rendering target at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw multiple points.`
 @param points : `the points to draw.`
 @param count : `the number of points to draw.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.points(&renderer, SDLFPoint* points, CInt count) @extern("SDL_RenderPoints");

<*
 Draw a line on the current rendering target at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw a line.`
 @param x1 : `the x coordinate of the start point.`
 @param y1 : `the y coordinate of the start point.`
 @param x2 : `the x coordinate of the end point.`
 @param y2 : `the y coordinate of the end point.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.line(&renderer, float x1, float y1, float x2, float y2) @extern("SDL_RenderLine");

<*
 Draw a series of connected lines on the current rendering target at
 subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw multiple lines.`
 @param points : `the points along the lines.`
 @param count : `the number of points, drawing count-1 lines.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.lines(&renderer, SDLFPoint* points, CInt count) @extern("SDL_RenderLines");

<*
 Draw a rectangle on the current rendering target at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw a rectangle.`
 @param rect : `a pointer to the destination rectangle, or NULL to outline the
             entire rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.rect(&renderer, SDLFRect* rect) @extern("SDL_RenderRect");

<*
 Draw some number of rectangles on the current rendering target at subpixel
 precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw multiple rectangles.`
 @param rects : `a pointer to an array of destination rectangles.`
 @param count : `the number of rectangles.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.rects(&renderer, SDLFRect* rects, CInt count) @extern("SDL_RenderRects");

<*
 Fill a rectangle on the current rendering target with the drawing color at
 subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should fill a rectangle.`
 @param rect : `a pointer to the destination rectangle, or NULL for the entire
             rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.fill_rect(&renderer, SDLFRect* rect) @extern("SDL_RenderFillRect");

<*
 Fill some number of rectangles on the current rendering target with the
 drawing color at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should fill multiple rectangles.`
 @param rects : `a pointer to an array of destination rectangles.`
 @param count : `the number of rectangles.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.fill_rects(&renderer, SDLFRect* rects, CInt count) @extern("SDL_RenderFillRects");

<*
 Copy a portion of the texture to the current rendering target at subpixel
 precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should copy parts of a texture.`
 @param texture : `the source texture.`
 @param srcrect : `a pointer to the source rectangle, or NULL for the entire
                texture.`
 @param dstrect : `a pointer to the destination rectangle, or NULL for the
                entire rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.texture(&renderer, SDLTexture* texture, SDLFRect* srcrect, SDLFRect* dstrect) @extern("SDL_RenderTexture");

<*
 Copy a portion of the source texture to the current rendering target, with
 rotation and flipping, at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should copy parts of a texture.`
 @param texture : `the source texture.`
 @param srcrect : `a pointer to the source rectangle, or NULL for the entire
                texture.`
 @param dstrect : `a pointer to the destination rectangle, or NULL for the
                entire rendering target.`
 @param angle : `an angle in degrees that indicates the rotation that will be
              applied to dstrect, rotating it in a clockwise direction.`
 @param center : `a pointer to a point indicating the point around which
               dstrect will be rotated (if NULL, rotation will be done
               around dstrect.w/2, dstrect.h/2).`
 @param flip : `an SDL_FlipMode value stating which flipping actions should be
             performed on the texture.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.texture_rotated(&renderer, SDLTexture *texture, SDLFRect* srcrect, SDLFRect* dstrect, double angle, SDLFPoint* center, SDLFlipMode flip) @extern("SDL_RenderTextureRotated");

<*
 Copy a portion of the source texture to the current rendering target, with
 affine transform, at subpixel precision.
 This function is available since SDL 3.2.0.

 threadsafety: You may only call this function from the main thread.

 @param renderer : `the renderer which should copy parts of a texture.`
 @param texture : `the source texture.`
 @param srcrect : `a pointer to the source rectangle, or NULL for the entire
                texture.`
 @param origin : `a pointer to a point indicating where the top-left corner of
               srcrect should be mapped to, or NULL for the rendering
               target's origin.`
 @param right : `a pointer to a point indicating where the top-right corner of
              srcrect should be mapped to, or NULL for the rendering
              target's top-right corner.`
 @param down : `a pointer to a point indicating where the bottom-left corner of
             srcrect should be mapped to, or NULL for the rendering target's
             bottom-left corner.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.texture_affine(&renderer, SDLTexture *texture, SDLFRect* srcrect, SDLFPoint* origin, SDLFPoint* right, SDLFPoint* down) @extern("SDL_RenderTextureAffine");

<*
 Tile a portion of the texture to the current rendering target at subpixel
 precision.
 This function is available since SDL 3.2.0.

 The pixels in `srcrect` will be repeated as many times as needed to
 completely fill `dstrect`.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should copy parts of a texture.`
 @param texture : `the source texture.`
 @param srcrect : `a pointer to the source rectangle, or NULL for the entire
                texture.`
 @param scale : `the scale used to transform srcrect into the destination
              rectangle, e.g. a 32x32 texture with a scale of 2 would fill
              64x64 tiles.`
 @param dstrect : `a pointer to the destination rectangle, or NULL for the
                entire rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.texture_tiled(&renderer, SDLTexture* texture, SDLFRect* srcrect, float scale, SDLFRect* dstrect) @extern("SDL_RenderTextureTiled");

<*
 Perform a scaled copy using the 9-grid algorithm to the current rendering
 target at subpixel precision.
 This function is available since SDL 3.2.0.

 The pixels in the texture are split into a 3x3 grid, using the different
 corner sizes for each corner, and the sides and center making up the
 remaining pixels. The corners are then scaled using `scale` and fit into
 the corners of the destination rectangle. The sides and center are then
 stretched into place to cover the remaining destination rectangle.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should copy parts of a texture.`
 @param texture : `the source texture.`
 @param srcrect : `the SDL_Rect structure representing the rectangle to be used
                for the 9-grid, or NULL to use the entire texture.`
 @param left_width : `the width, in pixels, of the left corners in 'srcrect'.`
 @param right_width : `the width, in pixels, of the right corners in 'srcrect'.`
 @param top_height : `the height, in pixels, of the top corners in 'srcrect'.`
 @param bottom_height : `the height, in pixels, of the bottom corners in
                      'srcrect'.`
 @param scale : `the scale used to transform the corner of 'srcrect' into the
              corner of 'dstrect', or 0.0f for an unscaled copy.`
 @param dstrect : `a pointer to the destination rectangle, or NULL for the
                entire rendering target.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.texture_9_grid(&renderer, SDLTexture* texture, SDLFRect* srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, SDLFRect* dstrect) @extern("SDL_RenderTexture9Grid");

<*
 Render a list of triangles, optionally using a texture and indices into the
 vertex array Color and alpha modulation is done per vertex
 (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param texture : `(optional) The SDL texture to use.`
 @param vertices : `vertices.`
 @param num_vertices : `number of vertices.`
 @param indices : `(optional) An array of integer indices into the 'vertices'
                array, if NULL all vertices will be rendered in sequential
                order.`
 @param num_indices : `number of indices.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.geometry(&renderer, SDLTexture* texture, SDLVertex* vertices, CInt num_vertices, CInt* indices, CInt num_indices) @extern("SDL_RenderGeometry");

<*
 Render a list of triangles, optionally using a texture and indices into the
 vertex arrays Color and alpha modulation is done per vertex
 (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param texture : `(optional) The SDL texture to use.`
 @param xy : `vertex positions.`
 @param xy_stride : `byte size to move from one element to the next element.`
 @param color : `vertex colors (as SDL_FColor).`
 @param color_stride : `byte size to move from one element to the next element.`
 @param uv : `vertex normalized texture coordinates.`
 @param uv_stride : `byte size to move from one element to the next element.`
 @param num_vertices : `number of vertices.`
 @param indices : `(optional) An array of indices into the 'vertices' arrays,
                if NULL all vertices will be rendered in sequential order.`
 @param num_indices : `number of indices.`
 @param size_indices : `index size: 1 (byte), 2 (short), 4 (int).`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.geometry_raw(&renderer, SDLTexture* texture, float* xy, CInt xy_stride, SDLFColor* color, CInt color_stride, float* uv, CInt uv_stride, CInt num_vertices, void* indices, CInt num_indices, CInt size_indices) @extern("SDL_RenderGeometryRaw");

<*
 Read pixels from the current rendering target.
 This function is available since SDL 3.2.0.

 The returned surface contains pixels inside the desired area clipped to the
 current viewport, and should be freed with SDL_DestroySurface().

 Note that this returns the actual pixels on the screen, so if you are using
 logical presentation you should use SDL_GetRenderLogicalPresentationRect()
 to get the area containing your content.

 **WARNING**: This is a very slow operation, and should not be used
 frequently. If you're using this on the main rendering target, it should be
 called after rendering and before SDL_RenderPresent().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @param rect : `an SDL_Rect structure representing the area to read, which will
             be clipped to the current viewport, or NULL for the entire
             viewport.`
 @return `a new SDL_Surface on success or NULL on failure; call
          SDL_GetError() for more information.`
*>
extern fn SDLSurface* SDLRenderer.read_pixels(&renderer, SDLRect* rect) @extern("SDL_RenderReadPixels");

<*
 Update the screen with any rendering performed since the previous call.
 This function is available since SDL 3.2.0.

 SDL's rendering functions operate on a backbuffer; that is, calling a
 rendering function such as SDL_RenderLine() does not directly put a line on
 the screen, but rather updates the backbuffer. As such, you compose your
 entire scene and *present* the composed backbuffer to the screen as a
 complete picture.

 Therefore, when using SDL's rendering API, one does all drawing intended
 for the frame, and then calls this function once per frame to present the
 final drawing to the user.

 The backbuffer should be considered invalidated after each present; do not
 assume that previous contents will exist between frames. You are strongly
 encouraged to call SDL_RenderClear() to initialize the backbuffer before
 starting each new frame's drawing, even if you plan to overwrite every
 pixel.

 Please note, that in case of rendering to a texture - there is **no need**
 to call `SDL_RenderPresent` after drawing needed objects to a texture, and
 should not be done; you are only required to change back the rendering
 target to default via `SDL_SetRenderTarget(renderer, NULL)` afterwards, as
 textures by themselves do not have a concept of backbuffers. Calling
 SDL_RenderPresent while rendering to a texture will still update the screen
 with any current drawing that has been done _to the window itself_.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.present(&renderer) @extern("SDL_RenderPresent");

<*
 Destroy the specified texture.
 This function is available since SDL 3.2.0.

 Passing NULL or an otherwise invalid texture will set the SDL error message
 to "Invalid texture".

 threadsafety: This function should only be called on the main thread.

 @param texture : `the texture to destroy.`
*>
extern fn void SDLTexture.destroy(&texture) @extern("SDL_DestroyTexture");

<*
 Destroy the rendering context for a window and free all associated
 textures.
 This function is available since SDL 3.2.0.

 This should be called before destroying the associated window.

 threadsafety: This function should only be called on the main thread.


 @param renderer : `the rendering context.`
*>
extern fn void SDLRenderer.destroy(&renderer) @extern("SDL_DestroyRenderer");

<*
 Force the rendering context to flush any pending commands and state.
 This function is available since SDL 3.2.0.

 You do not need to (and in fact, shouldn't) call this function unless you
 are planning to call into OpenGL/Direct3D/Metal/whatever directly, in
 addition to using an SDL_Renderer.

 This is for a very-specific case: if you are using SDL's render API, and
 you plan to make OpenGL/D3D/whatever calls in addition to SDL render API
 calls. If this applies, you should call this function between calls to
 SDL's render API and the low-level API you're using in cooperation.

 In all other cases, you can ignore this function.

 This call makes SDL flush any pending rendering work it was queueing up to
 do later in a single batch, and marks any internal cached state as invalid,
 so it'll prepare all its state again later, from scratch.

 This means you do not need to save state in your rendering code to protect
 the SDL renderer. However, there lots of arbitrary pieces of Direct3D and
 OpenGL state that can confuse things; you should use your best judgment and
 be prepared to make changes if specific state needs to be protected.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the rendering context.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.flush(&renderer) @extern("SDL_FlushRenderer");

<*
 Get the CAMetalLayer associated with the given Metal renderer.
 This function is available since SDL 3.2.0.

 This function returns `void *`, so SDL doesn't have to include Metal's
 headers, but it can be safely cast to a `CAMetalLayer *`.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer to query.`
 @return `a 'CAMetalLayer *'' on success, or NULL if the renderer isn't a
          Metal renderer.`
*>
extern fn void* SDLRenderer.get_metal_layer(&renderer) @extern("SDL_GetRenderMetalLayer");

<*
 Get the Metal command encoder for the current frame.
 This function is available since SDL 3.2.0.

 This function returns `void *`, so SDL doesn't have to include Metal's
 headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.

 This will return NULL if Metal refuses to give SDL a drawable to render to,
 which might happen if the window is hidden/minimized/offscreen. This
 doesn't apply to command encoders for render targets, just the window's
 backbuffer. Check your return values!

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer to query.`
 @return `an 'id<MTLRenderCommandEncoder>' on success, or NULL if the
          renderer isn't a Metal renderer or there was an error.`
*>
extern fn void* SDLRenderer.get_metal_command_encoder(&renderer) @extern("SDL_GetRenderMetalCommandEncoder");

<*
 Add a set of synchronization semaphores for the current frame.
 This function is available since SDL 3.2.0.

 The Vulkan renderer will wait for `wait_semaphore` before submitting
 rendering commands and signal `signal_semaphore` after rendering commands
 are complete for this frame.

 This should be called each frame that you want semaphore synchronization.
 The Vulkan renderer may have multiple frames in flight on the GPU, so you
 should have multiple semaphores that are used for synchronization. Querying
 SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the
 maximum number of semaphores you'll need.

 threadsafety: It is **NOT** safe to call this function from two threads at
               once.

 @param renderer : `the rendering context.`
 @param wait_stage_mask : `the VkPipelineStageFlags for the wait.`
 @param wait_semaphore : `a VkSempahore to wait on before rendering the current
                       frame, or 0 if not needed.`
 @param signal_semaphore : `a VkSempahore that SDL will signal when rendering
                         for the current frame is complete, or 0 if not
                         needed.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.add_vulkan_render_semaphores(&renderer, uint wait_stage_mask, long wait_semaphore, long signal_semaphore) @extern("SDL_AddVulkanRenderSemaphores");

<*
 Toggle VSync of the given renderer.
 This function is available since SDL 3.2.0.

 When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.

 The `vsync` parameter can be 1 to synchronize present with every vertical
 refresh, 2 to synchronize present with every second vertical refresh, etc.,
 SDL_RENDERER_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync), or
 SDL_RENDERER_VSYNC_DISABLED to disable. Not every value is supported by
 every driver, so you should check the return value to see whether the
 requested setting is supported.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer to toggle.`
 @param vsync : `the vertical refresh sync interval.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.set_vsync(&renderer, CInt vsync) @extern("SDL_SetRenderVSync");

const RENDERER_VSYNC_DISABLED = 0;
const RENDERER_VSYNC_ADAPTIVE = (-1);

<*
 Get VSync of the given renderer.
 This function is available since SDL 3.2.0.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer to toggle.`
 @param vsync : `an int filled with the current vertical refresh sync interval.
              See SDL_SetRenderVSync() for the meaning of the value.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.get_vsync(&renderer, CInt* vsync) @extern("SDL_GetRenderVSync");

<*
 The size, in pixels, of a single SDL_RenderDebugText() character.
 This macro is available since SDL 3.2.0.

 The font is monospaced and square, so this applies to all characters.
*>
const DEBUG_TEXT_FONT_CHARACTER_SIZE = 8;

<*
 Draw debug text to an SDL_Renderer.
 This function is available since SDL 3.2.0.

 This function will render a string of text to an SDL_Renderer. Note that
 this is a convenience function for debugging, with severe limitations, and
 not intended to be used for production apps and games.

 Among these limitations:

 - It accepts UTF-8 strings, but will only renders ASCII characters.
 - It has a single, tiny size (8x8 pixels). One can use logical presentation
   or scaling to adjust it, but it will be blurry.
 - It uses a simple, hardcoded bitmap font. It does not allow different font
   selections and it does not support truetype, for proper scaling.
 - It does no word-wrapping and does not treat newline characters as a line
   break. If the text goes out of the window, it's gone.

 For serious text rendering, there are several good options, such as
 SDL_ttf, stb_truetype, or other external libraries.

 On first use, this will create an internal texture for rendering glyphs.
 This texture will live until the renderer is destroyed.

 The text is drawn in the color specified by SDL_SetRenderDrawColor().

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw a line of text.`
 @param x : `the x coordinate where the top-left corner of the text will draw.`
 @param y : `the y coordinate where the top-left corner of the text will draw.`
 @param str : `the string to render.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.debug_text(&renderer, float x, float y, ZString str) @extern("SDL_RenderDebugText");

<*
 Draw debug text to an SDL_Renderer.
 This function is available since SDL 3.2.0.

 This function will render a printf()-style format string to a renderer.
 Note that this is a convenience function for debugging, with severe
 limitations, and is not intended to be used for production apps and games.

 For the full list of limitations and other useful information, see
 SDL_RenderDebugText.

 threadsafety: This function should only be called on the main thread.

 @param renderer : `the renderer which should draw the text.`
 @param x : `the x coordinate where the top-left corner of the text will draw.`
 @param y : `the y coordinate where the top-left corner of the text will draw.`
 @param fmt : `the format string to draw.`
 @param ... : `additional parameters matching % tokens in the 'fmt' string, if
            any.`
 @return `true on success or false on failure; call SDL_GetError() for more
          information.`
*>
extern fn bool SDLRenderer.debug_text_format(&renderer, float x, float y, ZString fmt, ...) @extern("SDL_RenderDebugTextFormat");
